import pygame
import random
import math

pygame.init()
screen = pygame.display.set_mode((1920, 1080)) #(1920, 1080)
WIDTH, HEIGHT = screen.get_size()
pygame.display.set_caption("Pixels Of Evasion")

# --- GAME OVER SCREEN ---
def GAME_OVER(final_score, p1, p2): 
    screen.fill(BLACK)
    over_text = big_font.render("GAME OVER", True, RED)
    if players == 1: score_text = font.render(f"Final Score: {final_score}", True, WHITE)
    elif p1 > p2: score_text = font.render(f"Player 1 wins by {p1}-{p2}.", True, WHITE)
    elif p1 < p2: score_text = font.render(f"Player 2 wins by {p2}-{p1}.", True, WHITE)
    elif p1 == p2: score_text = font.render(f"Both players tied with a score of {final_score}", True, WHITE)
    instr_text = font.render("Press space to return", True, GRAY)

    screen.blit(over_text, over_text.get_rect(center=(WIDTH//2, HEIGHT//2 - 50)))
    screen.blit(score_text, score_text.get_rect(center=(WIDTH//2, HEIGHT//2)))
    screen.blit(instr_text, instr_text.get_rect(center=(WIDTH//2, HEIGHT//2 + 50)))

    pygame.display.flip()

    waiting = True
    while waiting:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                waiting = False
            if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                print(f"Final score: {final_score}")
                if players == 2:
                    print(f"Player 1 score: {p1}")
                    print(f"Player 2 score: {p2}")
                return "TITLE"
        clock.tick(15)

# --- Colors ---
WHITE = (255, 255, 255)
SILVER = (175, 175, 175)
GRAY = (100, 100, 100)
BLACK = (0, 0, 0) #not used?
BROWN = (108, 65, 0)
CRISP = (50, 0, 0) #not used?
MAROON = (120, 0, 0)
BRONZE = (140, 45, 0)
BRICK = (140, 65, 65)
RED = (255, 0, 0)
LAVA = (200, 60, 0)
TAN = (155, 125, 95)
ORANGE = (255, 120, 0)
GOLD = (255, 195, 0) #NOT USED
YELLOW = (255, 255, 0)
SULFUR = (190, 190, 0)
OLIVE = (100, 100, 0)
LIME = (0, 255, 0)
GREEN = (0, 125, 0)
FOREST = (0, 60, 0) #NOT USED
TEAL = (0, 130, 130)
AQUA = (0, 190, 160)
TURQUOISE = (0, 255, 180)
ICE = (175, 255, 255)
CYAN = (0, 255, 255)
SKY = (105, 160, 225)
BLUE = (0, 0, 255)
NAVY = (0, 0, 100)
INDIGO = (110, 0, 200)
MAUVE = (145, 95, 140) #NOT USED
PURPLE = (162, 0, 255)
VIOLET = (130, 0, 130)
MAGENTA = (255, 0, 255)
PINK = (255, 140, 255)
HOT_PINK = (255, 0, 106)
CRIMSON = (150, 0, 48) #NOT USED

# --- Spawner Size ---
SPAWNER_SIZE = 50

# --- Player ---
players = 1
player_size = 50
player_speed = 8
player_lives = 3 # ORIGINAL VALUE 3
player2_lives = 3 # ORIGINAL VALUE 3
player_alive = True
player2_alive = True
player_frozen = False
player2_frozen = False
slow_until = 0
player_speed_base = player_speed
player2_slow_until = 0
player2_speed_base = player_speed
player_speed = player_speed_base
player2_speed = player2_speed_base
freeze_duration = 10000

# --- Enemy ---
enemy_size = 50 # ORIGINAL VALUE 50
enemies = []
available_enemy_types = []
locked_enemy_types = []
targetting_enemies = [2, 8, 11, 12, 14, 15, 19, 26, 27, 29]

# --- Spawner ---
spawner_pos = (WIDTH // 2 - SPAWNER_SIZE // 2, HEIGHT // 2 - SPAWNER_SIZE // 2)
initial_spawn_delay = 2000 # ORIGINAL VALUE 2000
last_spawn_time = pygame.time.get_ticks()
enemy_speed = 5
min_spawn_delay = 500  # ORIGINAL VALUE 500
spawn_rate = 20

player_x = player_size // 2
player_y = spawner_pos[1] + SPAWNER_SIZE // 2

player2_x = WIDTH - player_size // 2
player2_y = spawner_pos[1] + SPAWNER_SIZE // 2

# --- Enemy Health ---
basic_hp = 5 # 1
homing_hp = 2 # 2
fatal_hp = 3 # 3
flow_hp = 3 # 4
sticky_hp = 7 # 5
gloomy_hp = 9 # 6
trail_hp = 3 # 7
impostor_hp = 5 # 8
splitter_hp = 3 # 9
bomb_hp = 8 # 10
shooter_hp = 4 # 11
sniper_hp = 1 # 12
speedy_hp = 5 # 13
shotgun_hp = 4 # 14
voodoo_hp = 5 # 15
blind_hp = 6 # 16
motion_hp = 7 # 17
charger_hp = 3 # 18
rapidshooter_hp = 1 # 19
frostbite_hp = 4 # 20
addictive_hp = 7 # 21
laser_hp = 3 # 22
hardened_hp = 40 # 23
accelerator_hp = 5 # 24
cold_hp = 6 # 25
tracer_hp = 1 # 26
savage_hp = 2 # 27
teleporter_hp = 6 # 28
haunter_hp = 3 # 29
stream_hp = 4 # 30


# --- Scoring System & Text Size ---
score = 0
truescore = 0
score_p1 = truescore
score_p2 = truescore
font = pygame.font.SysFont(None, 40)
big_font = pygame.font.SysFont(None, 120)
enemy_font = pygame.font.SysFont(None, int(0.96 * enemy_size))
player_font = pygame.font.SysFont(None, int(0.96 * player_size))
regen_delay = 50
p1_regen_block_until = 0
p2_regen_block_until = 0
unlock_scores = []


# --- Clock ---
clock = pygame.time.Clock()
FPS = 60

# --- Trail ---
trail_squares = []
trail_lifetime_ms = 3000 # this is the length of the trail
trail_interval_ms = 450 # this is the distance between trail particles
trail_size = 10


# --- Projectiles ---
projectiles = []
bomb_projectile_speed = 2.5
shooter_projectile_speed = 5
sniper_projectile_speed = 10
shotgun_projectile_speed = 5
rapidshooter_projectile_speed = 5
frostbite_projectile_speed = 5
projectile_size = 10
shooter_delay = 3000
sniper_delay = 5500
shotgun_delay = 7500
rapidshooter_delay = 200
projectile_fire_rate = 10

bomb_projectile_amount = 8
frostbite_projectile_amount = 32

# --- Split Amount ---
split_amount = 2

# --- Acceleration ---
accel = 0.0
accel_rate = 0.02

# --- Harden ---
harden_break = 10

# --- Turn Speed ---
chase_turn = 5

# --- Stickiness ---
stickiness = 2000

# --- Addiction ---
addictive_pull_radius = 300
addictive_pull_strength = 10

# --- Player damage & heal flash ---
damage_flash_time = 0
player2_damage_flash_time = 0
heal_flash_time = 0
player2_heal_flash_time = 0
invincible_until = 0
player2_invincible_until = 0
invincibility_duration = 1000
player2_last_regen = 0
player2_regen_cooldown = 3000


def centered_rect_collision(x1, y1, s1, x2, y2, s2):
    half1 = s1 / 2
    half2 = s2 / 2
    return (
        abs(x1 - x2) < half1 + half2 and
        abs(y1 - y2) < half1 + half2
    )

def rotate_toward(current_angle, target_angle, turn_speed):
    difference = (target_angle - current_angle + math.pi) % (2 * math.pi) - math.pi
    if abs(difference) < turn_speed:
        return target_angle
    return current_angle + turn_speed * (1 if difference > 0 else -1)

def distance(x1, y1, x2, y2):
    return math.hypot(x2 - x1, y2 - y1)

def get_target_position(enemy):
    if enemy["target"] == 1:
        return player_x, player_y
    elif enemy["target"] == 2:
        return player2_x, player2_y
    else:
        return None

def reset_game_state():
    global player_x, player_y, player2_x, player2_y
    global player_lives, player2_lives
    global player_alive, player2_alive
    global enemies, projectiles, trail_squares
    global score, truescore, score_p1, score_p2
    global last_spawn_time, invincible_until, player2_invincible_until
    global spawn_enabled, p1_ready, p2_ready
    player_x = player_size // 2
    player_y = spawner_pos[1] + SPAWNER_SIZE // 2
    player2_x = WIDTH - player_size // 2
    player2_y = spawner_pos[1] + SPAWNER_SIZE // 2
    player_lives = player_health_setting
    player2_lives = player2_health_setting
    player_alive = True
    player2_alive = True
    enemies.clear()
    projectiles.clear()
    trail_squares.clear()
    score = 0
    truescore = 0
    score_p1 = 0
    score_p2 = 0
    last_spawn_time = pygame.time.get_ticks()
    invincible_until = 0
    player2_invincible_until = 0
    spawn_enabled = False
    p1_ready = False
    p2_ready = False

player_size_setting = 50
enemy_size_setting = 50
projectile_size_setting = 10
min_spawn_delay_setting = 500
max_spawn_delay_setting = 2000
spawn_delay_change_setting = 20
player_speed_setting = 8
enemy_speed_setting = 5
projectile_speed_setting = 5
regen_delay_setting = 50
player_health_setting = 3
player2_health_setting = 3
trail_duration_setting = 3000
trail_distance_setting = 450
freeze_duration_setting = 10000
invincibility_duration_setting = 1000
chaser_turn_amount_setting = 5
enemy_stick_setting = 2000
projectile_fire_rate_setting = 10
enemy_locks = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

basic_hp_setting = 5
homing_hp_setting = 2
fatal_hp_setting = 3
flow_hp_setting = 3
sticky_hp_setting = 7
gloomy_hp_setting = 9
trail_hp_setting = 3
impostor_hp_setting = 5
splitter_hp_setting = 3
split_amount_setting = 2
bomb_hp_setting = 8
bomb_projectile_amount_setting = 8
shooter_hp_setting = 4
sniper_hp_setting = 1
speedy_hp_setting = 5
shotgun_hp_setting = 4
shotgun_bullets_setting = 5
voodoo_hp_setting = 5
blind_hp_setting = 6
motion_hp_setting = 7
charger_hp_setting = 3
rapidshooter_hp_setting = 1
frostbite_hp_setting = 4
frostbite_projectile_amount_setting = 32
addictive_hp_setting = 7
addictive_pull_strength_setting = 10
addictive_pull_radius_setting = 300
laser_hp_setting = 3
hardened_hp_setting = 40
harden_break_setting = 10
accelerator_hp_setting = 5
cold_hp_setting = 6
tracer_hp_setting = 1
savage_hp_setting = 2
teleporter_hp_setting = 6
haunter_hp_setting = 3
stream_hp_setting = 4

def enemy_lock_setup(elock, enumber):
    global available_enemy_types
    global locked_enemy_types
    if elock == 0: available_enemy_types.append(enumber + 1)
    elif elock == 1: locked_enemy_types.append(enumber + 1)

def SETTINGS():
    global player_size_setting
    global enemy_size_setting
    global projectile_size_setting
    global min_spawn_delay_setting
    global max_spawn_delay_setting
    global spawn_delay_change_setting
    global player_speed_setting
    global enemy_speed_setting
    global projectile_speed_setting
    global regen_delay_setting
    global player_health_setting
    global player2_health_setting
    global trail_duration_setting
    global trail_distance_setting
    global freeze_duration_setting
    global invincibility_duration_setting
    global chaser_turn_amount_setting
    global enemy_stick_setting
    global projectile_fire_rate_setting
    global enemy_locks
    global basic_hp_setting
    global homing_hp_setting
    global fatal_hp_setting
    global flow_hp_setting
    global sticky_hp_setting
    global gloomy_hp_setting
    global trail_hp_setting
    global impostor_hp_setting
    global splitter_hp_setting
    global split_amount_setting
    global bomb_hp_setting
    global bomb_projectile_amount_setting
    global shooter_hp_setting
    global sniper_hp_setting
    global speedy_hp_setting
    global shotgun_hp_setting
    global shotgun_bullets_setting
    global voodoo_hp_setting
    global blind_hp_setting
    global motion_hp_setting
    global charger_hp_setting
    global rapidshooter_hp_setting
    global frostbite_hp_setting
    global frostbite_projectile_amount_setting
    global addictive_hp_setting
    global addictive_pull_strength_setting
    global addictive_pull_radius_setting
    global laser_hp_setting
    global hardened_hp_setting
    global harden_break_setting
    global accelerator_hp_setting
    global cold_hp_setting
    global tracer_hp_setting
    global savage_hp_setting
    global teleporter_hp_setting
    global haunter_hp_setting
    global stream_hp_setting
    
    running = True
    button_offset = 10
    scroll_y = 0
    scroll_speed = 25
    max_scroll = 3730 - HEIGHT
    enemy_locking_labels = ["Starter", "Locked", "Banned"]
    scrollbar_width = 20
    scrollbar_margin = 50
    scrollbar_track = pygame.Rect(
        WIDTH - scrollbar_width - scrollbar_margin,
        50,
        scrollbar_width,
        HEIGHT - 100
    )

    dragging_scrollbar = False

    player_size_plus_button = pygame.Rect(WIDTH//2 + 120, HEIGHT//2 - 20, 60, 60)
    player_size_minus_button = pygame.Rect(WIDTH//2 - 180, HEIGHT//2 - 20, 60, 60)
    
    while running:
        screen.fill(BLACK)
        text = big_font.render("Settings", True, WHITE)
        screen.blit(text, (50, 50 + scroll_y))
        info = font.render("Press Space to return", True, SILVER)
        screen.blit(info, (500, 80 + scroll_y))
        mouse_pos = pygame.mouse.get_pos()
        mouse_click = pygame.mouse.get_pressed()[0]
        plus_txt = font.render("+", True, BLACK)
        minus_txt = font.render("-", True, BLACK)


        content_height = max_scroll + HEIGHT
        view_height = HEIGHT

        handle_height = max(
            40,
            int(scrollbar_track.height * (view_height / content_height))
        )

        scroll_ratio = -scroll_y / max_scroll if max_scroll > 0 else 0

        handle_y = scrollbar_track.y + int(
            scroll_ratio * (scrollbar_track.height - handle_height)
        )

        scrollbar_handle = pygame.Rect(
            scrollbar_track.x,
            handle_y,
            scrollbar_width,
            handle_height
        )


        default_set_text = font.render("Set To Default", True, WHITE)
        default_set_button = pygame.Rect(50, 180 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, GRAY, default_set_button, border_radius=10)
        screen.blit(default_set_text, default_set_text.get_rect(center=default_set_button.center))
        if default_set_button.collidepoint(mouse_pos) and mouse_click:
            player_size_setting = 50
            enemy_size_setting = 50
            projectile_size_setting = 10
            min_spawn_delay_setting = 500
            max_spawn_delay_setting = 2000
            spawn_delay_change_setting = 20
            player_speed_setting = 8
            enemy_speed_setting = 5
            projectile_speed_setting = 5
            regen_delay_setting = 50
            player_health_setting = 3
            player2_health_setting = 3
            trail_duration_setting = 3000
            trail_distance_setting = 450
            freeze_duration_setting = 10000
            invincibility_duration_setting = 1000
            chaser_turn_amount_setting = 5
            enemy_stick_setting = 2000
            projectile_fire_rate_setting = 10
            enemy_locks = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

            basic_hp_setting = 5
            homing_hp_setting = 2
            fatal_hp_setting = 3
            flow_hp_setting = 3
            sticky_hp_setting = 7
            gloomy_hp_setting = 9
            trail_hp_setting = 3
            impostor_hp_setting = 5
            splitter_hp_setting = 3
            split_amount_setting = 2
            bomb_hp_setting = 8
            bomb_projectile_amount_setting = 8
            shooter_hp_setting = 4
            sniper_hp_setting = 1
            speedy_hp_setting = 5
            shotgun_hp_setting = 4
            shotgun_bullets_setting = 5
            voodoo_hp_setting = 5
            blind_hp_setting = 6
            motion_hp_setting = 7
            charger_hp_setting = 3
            rapidshooter_hp_setting = 1
            frostbite_hp_setting = 4
            frostbite_projectile_amount_setting = 32
            addictive_hp_setting = 7
            addictive_pull_strength_setting = 10
            addictive_pull_radius_setting = 300
            laser_hp_setting = 3
            hardened_hp_setting = 40
            harden_break_setting = 10
            accelerator_hp_setting = 5
            cold_hp_setting = 6
            tracer_hp_setting = 1
            savage_hp_setting = 2
            teleporter_hp_setting = 6
            haunter_hp_setting = 3
            stream_hp_setting = 4
            pygame.time.delay(200)


        max_spawn_delay_label = font.render("Starting Spawn Delay: " + str(max_spawn_delay_setting), True, WHITE)
        screen.blit(max_spawn_delay_label, (50, 240 + scroll_y))
        max_spawn_delay_minus_button = pygame.Rect(500, 240 - button_offset + scroll_y, 50, 50)
        max_spawn_delay_plus_button = pygame.Rect(560, 240 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, max_spawn_delay_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=max_spawn_delay_plus_button.center))
        pygame.draw.rect(screen, RED, max_spawn_delay_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=max_spawn_delay_minus_button.center))
        if max_spawn_delay_plus_button.collidepoint(mouse_pos) and mouse_click:
            max_spawn_delay_setting += 100
            if max_spawn_delay_setting > 5000:
                max_spawn_delay_setting = 5000
            pygame.time.delay(50)
        if max_spawn_delay_minus_button.collidepoint(mouse_pos) and mouse_click:
            max_spawn_delay_setting -= 100
            if max_spawn_delay_setting < 100 or max_spawn_delay_setting < min_spawn_delay_setting:
                max_spawn_delay_setting += 100
            pygame.time.delay(50)

            

        min_spawn_delay_label = font.render("Ending Spawn Delay: " + str(min_spawn_delay_setting), True, WHITE)
        screen.blit(min_spawn_delay_label, (50, 300 + scroll_y))
        min_spawn_delay_minus_button = pygame.Rect(500, 300 - button_offset + scroll_y, 50, 50)
        min_spawn_delay_plus_button = pygame.Rect(560, 300 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, min_spawn_delay_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=min_spawn_delay_plus_button.center))
        pygame.draw.rect(screen, RED, min_spawn_delay_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=min_spawn_delay_minus_button.center))
        if min_spawn_delay_plus_button.collidepoint(mouse_pos) and mouse_click:
            min_spawn_delay_setting += 100
            if min_spawn_delay_setting > 5000 or min_spawn_delay_setting > max_spawn_delay_setting:
                min_spawn_delay_setting -= 100
            pygame.time.delay(50)
        if min_spawn_delay_minus_button.collidepoint(mouse_pos) and mouse_click:
            min_spawn_delay_setting -= 100
            if min_spawn_delay_setting < 100:
                min_spawn_delay_setting = 100
            pygame.time.delay(50)


        


        spawn_delay_change_label = font.render("Spawn Delay Change: " + str(spawn_delay_change_setting), True, WHITE)
        screen.blit(spawn_delay_change_label, (50, 360 + scroll_y))
        spawn_delay_change_minus_button = pygame.Rect(500, 360 - button_offset + scroll_y, 50, 50)
        spawn_delay_change_plus_button = pygame.Rect(560, 360 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, spawn_delay_change_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=spawn_delay_change_plus_button.center))
        pygame.draw.rect(screen, RED, spawn_delay_change_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=spawn_delay_change_minus_button.center))
        if spawn_delay_change_plus_button.collidepoint(mouse_pos) and mouse_click:
            spawn_delay_change_setting += 2
            if spawn_delay_change_setting > 100:
                spawn_delay_change_setting = 100
            pygame.time.delay(50)
        if spawn_delay_change_minus_button.collidepoint(mouse_pos) and mouse_click:
            spawn_delay_change_setting -= 2
            if spawn_delay_change_setting < 2:
                spawn_delay_change_setting = 2
            pygame.time.delay(50)


        player_health_label = font.render("Player 1 Health: " + str(player_health_setting), True, WHITE)
        screen.blit(player_health_label, (50, 420 + scroll_y))
        player_health_minus_button = pygame.Rect(500, 420 - button_offset + scroll_y, 50, 50)
        player_health_plus_button = pygame.Rect(560, 420 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, player_health_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=player_health_plus_button.center))
        pygame.draw.rect(screen, RED, player_health_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=player_health_minus_button.center))
        if player_health_plus_button.collidepoint(mouse_pos) and mouse_click:
            player_health_setting += 1
            if player_health_setting > 99:
                player_health_setting = 99
            pygame.time.delay(50)
        if player_health_minus_button.collidepoint(mouse_pos) and mouse_click:
            player_health_setting -= 1
            if player_health_setting < 1:
                player_health_setting = 1
            pygame.time.delay(50)


        player2_health_label = font.render("Player 2 Health: " + str(player2_health_setting), True, WHITE)
        screen.blit(player2_health_label, (50, 480 + scroll_y))
        player2_health_minus_button = pygame.Rect(500, 480 - button_offset + scroll_y, 50, 50)
        player2_health_plus_button = pygame.Rect(560, 480 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, player2_health_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=player2_health_plus_button.center))
        pygame.draw.rect(screen, RED, player2_health_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=player2_health_minus_button.center))
        if player2_health_plus_button.collidepoint(mouse_pos) and mouse_click:
            player2_health_setting += 2
            if player2_health_setting > 99:
                player2_health_setting = 99
            pygame.time.delay(50)
        if player2_health_minus_button.collidepoint(mouse_pos) and mouse_click:
            player2_health_setting -= 1
            if player2_health_setting < 1:
                player2_health_setting = 1
            pygame.time.delay(50)


        if regen_delay_setting == 6767: regen_delay_label = font.render("No Regen", True, WHITE)
        else: regen_delay_label = font.render("Regen Delay: " + str(regen_delay_setting), True, WHITE)
        screen.blit(regen_delay_label, (50, 540 + scroll_y))
        regen_delay_minus_button = pygame.Rect(500, 540 - button_offset + scroll_y, 50, 50)
        regen_delay_plus_button = pygame.Rect(560, 540 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, regen_delay_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=regen_delay_plus_button.center))
        pygame.draw.rect(screen, RED, regen_delay_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=regen_delay_minus_button.center))
        if regen_delay_plus_button.collidepoint(mouse_pos) and mouse_click:
            regen_delay_setting += 5
            if regen_delay_setting > 150:
                regen_delay_setting = 6767
            pygame.time.delay(50)
        if regen_delay_minus_button.collidepoint(mouse_pos) and mouse_click:
            if regen_delay_setting == 6767:
                regen_delay_setting = 150
            else: regen_delay_setting -= 5
            if regen_delay_setting < 5:
                regen_delay_setting = 5
            pygame.time.delay(50)



        invincibility_duration_label = font.render("Invincibility Duration: " + str(invincibility_duration_setting), True, WHITE)
        screen.blit(invincibility_duration_label, (50, 600 + scroll_y))
        invincibility_duration_minus_button = pygame.Rect(500, 600 - button_offset + scroll_y, 50, 50)
        invincibility_duration_plus_button = pygame.Rect(560, 600 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, invincibility_duration_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=invincibility_duration_plus_button.center))
        pygame.draw.rect(screen, RED, invincibility_duration_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=invincibility_duration_minus_button.center))
        if invincibility_duration_plus_button.collidepoint(mouse_pos) and mouse_click:
            invincibility_duration_setting += 250
            if invincibility_duration_setting > 5000:
                invincibility_duration_setting = 5000
            pygame.time.delay(50)
        if invincibility_duration_minus_button.collidepoint(mouse_pos) and mouse_click:
            invincibility_duration_setting -= 250
            if invincibility_duration_setting < 0:
                invincibility_duration_setting = 0
            pygame.time.delay(50)



        freeze_duration_label = font.render("Freeze Duration: " + str(freeze_duration_setting), True, WHITE)
        screen.blit(freeze_duration_label, (50, 660 + scroll_y))
        freeze_duration_minus_button = pygame.Rect(500, 660 - button_offset + scroll_y, 50, 50)
        freeze_duration_plus_button = pygame.Rect(560, 660 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, freeze_duration_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=freeze_duration_plus_button.center))
        pygame.draw.rect(screen, RED, freeze_duration_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=freeze_duration_minus_button.center))
        if freeze_duration_plus_button.collidepoint(mouse_pos) and mouse_click:
            freeze_duration_setting += 500
            if freeze_duration_setting > 20000:
                freeze_duration_setting = 20000
            pygame.time.delay(50)
        if freeze_duration_minus_button.collidepoint(mouse_pos) and mouse_click:
            freeze_duration_setting -= 500
            if freeze_duration_setting < 0:
                freeze_duration_setting = 0
            pygame.time.delay(50)


        player_speed_label = font.render("Player Speed: " + str(player_speed_setting), True, WHITE)
        screen.blit(player_speed_label, (50, 720 + scroll_y))
        player_speed_minus_button = pygame.Rect(500, 720 - button_offset + scroll_y, 50, 50)
        player_speed_plus_button = pygame.Rect(560, 720 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, player_speed_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=player_speed_plus_button.center))
        pygame.draw.rect(screen, RED, player_speed_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=player_speed_minus_button.center))
        if player_speed_plus_button.collidepoint(mouse_pos) and mouse_click:
            player_speed_setting += 1
            if player_speed_setting > 20:
                player_speed_setting = 20
            pygame.time.delay(50)
        if player_speed_minus_button.collidepoint(mouse_pos) and mouse_click:
            player_speed_setting -= 1
            if player_speed_setting < 1:
                player_speed_setting = 1
            pygame.time.delay(50)


        player_size_label = font.render("Player Size: " + str(player_size_setting), True, WHITE)
        screen.blit(player_size_label, (50, 780 + scroll_y))
        player_size_minus_button = pygame.Rect(500, 780 - button_offset + scroll_y, 50, 50)
        player_size_plus_button = pygame.Rect(560, 780 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, player_size_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=player_size_plus_button.center))
        pygame.draw.rect(screen, RED, player_size_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=player_size_minus_button.center))
        if player_size_plus_button.collidepoint(mouse_pos) and mouse_click:
            player_size_setting += 5
            if player_size_setting > 150:
                player_size_setting = 150
            pygame.time.delay(50)
        if player_size_minus_button.collidepoint(mouse_pos) and mouse_click:
            player_size_setting -= 5
            if player_size_setting < 10:
                player_size_setting = 10
            pygame.time.delay(50)



        enemy_speed_label = font.render("Enemy Speed: " + str(enemy_speed_setting), True, WHITE)
        screen.blit(enemy_speed_label, (50, 840 + scroll_y))
        enemy_speed_minus_button = pygame.Rect(500, 840 - button_offset + scroll_y, 50, 50)
        enemy_speed_plus_button = pygame.Rect(560, 840 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, enemy_speed_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=enemy_speed_plus_button.center))
        pygame.draw.rect(screen, RED, enemy_speed_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=enemy_speed_minus_button.center))
        if enemy_speed_plus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_speed_setting += 1
            if enemy_speed_setting > 20:
                enemy_speed_setting = 20
            pygame.time.delay(50)
        if enemy_speed_minus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_speed_setting -= 1
            if enemy_speed_setting < 1:
                enemy_speed_setting = 1
            pygame.time.delay(50)




        enemy_size_label = font.render("Enemy Size: " + str(enemy_size_setting), True, WHITE)
        screen.blit(enemy_size_label, (50, 900 + scroll_y))
        enemy_size_minus_button = pygame.Rect(500, 900 - button_offset + scroll_y, 50, 50)
        enemy_size_plus_button = pygame.Rect(560, 900 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, enemy_size_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=enemy_size_plus_button.center))
        pygame.draw.rect(screen, RED, enemy_size_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=enemy_size_minus_button.center))
        if enemy_size_plus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_size_setting += 5
            if enemy_size_setting > 150:
                enemy_size_setting = 150
            pygame.time.delay(50)
        if enemy_size_minus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_size_setting -= 5
            if enemy_size_setting < 10:
                enemy_size_setting = 10
            pygame.time.delay(50)



        projectile_speed_label = font.render("Projectile Speed: " + str(projectile_speed_setting), True, WHITE)
        screen.blit(projectile_speed_label, (50, 960 + scroll_y))
        projectile_speed_minus_button = pygame.Rect(500, 960 - button_offset + scroll_y, 50, 50)
        projectile_speed_plus_button = pygame.Rect(560, 960 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, projectile_speed_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=projectile_speed_plus_button.center))
        pygame.draw.rect(screen, RED, projectile_speed_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=projectile_speed_minus_button.center))
        if projectile_speed_plus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_speed_setting += 1
            if projectile_speed_setting > 25:
                projectile_speed_setting = 25
            pygame.time.delay(50)
        if projectile_speed_minus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_speed_setting -= 1
            if projectile_speed_setting < 1:
                projectile_speed_setting = 1
            pygame.time.delay(50)



        projectile_fire_rate_label = font.render("Projectile Fire Rate: " + str(projectile_fire_rate_setting), True, WHITE)
        screen.blit(projectile_fire_rate_label, (50, 1020 + scroll_y))
        projectile_fire_rate_minus_button = pygame.Rect(500, 1020 - button_offset + scroll_y, 50, 50)
        projectile_fire_rate_plus_button = pygame.Rect(560, 1020 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, projectile_fire_rate_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=projectile_fire_rate_plus_button.center))
        pygame.draw.rect(screen, RED, projectile_fire_rate_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=projectile_fire_rate_minus_button.center))
        if projectile_fire_rate_plus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_fire_rate_setting += 1
            if projectile_fire_rate_setting > 40:
                projectile_fire_rate_setting = 40
            pygame.time.delay(50)
        if projectile_fire_rate_minus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_fire_rate_setting -= 1
            if projectile_fire_rate_setting < 1:
                projectile_fire_rate_setting = 1
            pygame.time.delay(50)

        

        projectile_size_label = font.render("Projectile/Trail Size: " + str(projectile_size_setting), True, WHITE)
        screen.blit(projectile_size_label, (50, 1080 + scroll_y))
        projectile_size_minus_button = pygame.Rect(500, 1080 - button_offset + scroll_y, 50, 50)
        projectile_size_plus_button = pygame.Rect(560, 1080 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, projectile_size_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=projectile_size_plus_button.center))
        pygame.draw.rect(screen, RED, projectile_size_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=projectile_size_minus_button.center))
        if projectile_size_plus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_size_setting += 2
            if projectile_size_setting > 50:
                projectile_size_setting = 50
            pygame.time.delay(50)
        if projectile_size_minus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_size_setting -= 2
            if projectile_size_setting < 2:
                projectile_size_setting = 2
            pygame.time.delay(50)



        trail_duration_label = font.render("Trail Duration: " + str(trail_duration_setting), True, WHITE)
        screen.blit(trail_duration_label, (50, 1140 + scroll_y))
        trail_duration_minus_button = pygame.Rect(500, 1140 - button_offset + scroll_y, 50, 50)
        trail_duration_plus_button = pygame.Rect(560, 1140 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, trail_duration_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=trail_duration_plus_button.center))
        pygame.draw.rect(screen, RED, trail_duration_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=trail_duration_minus_button.center))
        if trail_duration_plus_button.collidepoint(mouse_pos) and mouse_click:
            trail_duration_setting += 500
            if trail_duration_setting > 16000:
                trail_duration_setting = 16000
            pygame.time.delay(50)
        if trail_duration_minus_button.collidepoint(mouse_pos) and mouse_click:
            trail_duration_setting -= 500
            if trail_duration_setting < 500:
                trail_duration_setting = 500
            pygame.time.delay(50)


        trail_distance_label = font.render("Trail Distance: " + str(trail_distance_setting), True, WHITE)
        screen.blit(trail_distance_label, (50, 1200 + scroll_y))
        trail_distance_minus_button = pygame.Rect(500, 1200 - button_offset + scroll_y, 50, 50)
        trail_distance_plus_button = pygame.Rect(560, 1200 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, trail_distance_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=trail_distance_plus_button.center))
        pygame.draw.rect(screen, RED, trail_distance_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=trail_distance_minus_button.center))
        if trail_distance_plus_button.collidepoint(mouse_pos) and mouse_click:
            trail_distance_setting += 100
            if trail_distance_setting > 950:
                trail_distance_setting = 950
            pygame.time.delay(50)
        if trail_distance_minus_button.collidepoint(mouse_pos) and mouse_click:
            trail_distance_setting -= 100
            if trail_distance_setting < 50:
                trail_distance_setting = 50
            pygame.time.delay(50)



        chaser_turn_amount_label = font.render("Chaser Turn Speed: " + str(chaser_turn_amount_setting), True, WHITE)
        screen.blit(chaser_turn_amount_label, (50, 1260 + scroll_y))
        chaser_turn_amount_minus_button = pygame.Rect(500, 1260 - button_offset + scroll_y, 50, 50)
        chaser_turn_amount_plus_button = pygame.Rect(560, 1260 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, chaser_turn_amount_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=chaser_turn_amount_plus_button.center))
        pygame.draw.rect(screen, RED, chaser_turn_amount_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=chaser_turn_amount_minus_button.center))
        if chaser_turn_amount_plus_button.collidepoint(mouse_pos) and mouse_click:
            chaser_turn_amount_setting += 1
            if chaser_turn_amount_setting > 15:
                chaser_turn_amount_setting = 15
            pygame.time.delay(50)
        if chaser_turn_amount_minus_button.collidepoint(mouse_pos) and mouse_click:
            chaser_turn_amount_setting -= 1
            if chaser_turn_amount_setting < 1:
                chaser_turn_amount_setting = 1
            pygame.time.delay(50)



        enemy_stick_label = font.render("Wall Stick Duration: " + str(enemy_stick_setting), True, WHITE)
        screen.blit(enemy_stick_label, (50, 1320 + scroll_y))
        enemy_stick_minus_button = pygame.Rect(500, 1320 - button_offset + scroll_y, 50, 50)
        enemy_stick_plus_button = pygame.Rect(560, 1320 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, enemy_stick_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=enemy_stick_plus_button.center))
        pygame.draw.rect(screen, RED, enemy_stick_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=enemy_stick_minus_button.center))
        if enemy_stick_plus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_stick_setting += 500
            if enemy_stick_setting > 4000:
                enemy_stick_setting = 4000
            pygame.time.delay(50)
        if enemy_stick_minus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_stick_setting -= 500
            if enemy_stick_setting < 500:
                enemy_stick_setting = 500
            pygame.time.delay(50)



        all_starter_text = font.render("All Starter", True, WHITE)
        all_starter_button = pygame.Rect(50, 1380 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, GREEN, all_starter_button, border_radius=10)
        screen.blit(all_starter_text, all_starter_text.get_rect(center=all_starter_button.center))
        if all_starter_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = 0
            pygame.time.delay(200)
        all_locked_text = font.render("All Locked", True, WHITE)
        all_locked_button = pygame.Rect(300, 1380 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, SULFUR, all_locked_button, border_radius=10)
        screen.blit(all_locked_text, all_locked_text.get_rect(center=all_locked_button.center))
        if all_locked_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = 1
            pygame.time.delay(200)
        all_banned_text = font.render("All Banned", True, WHITE)
        all_banned_button = pygame.Rect(550, 1380 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, RED, all_banned_button, border_radius=10)
        screen.blit(all_banned_text, all_banned_text.get_rect(center=all_banned_button.center))
        if all_banned_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = 2
            pygame.time.delay(200)
        all_random_text = font.render("All Random", True, WHITE)
        all_random_button = pygame.Rect(800, 1380 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, PURPLE, all_random_button, border_radius=10)
        screen.blit(all_random_text, all_random_text.get_rect(center=all_random_button.center))
        if all_random_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = random.randrange(3)
            pygame.time.delay(200)



        basic_hp_label = font.render("Basic Enemy - HP: " + str(basic_hp_setting), True, GRAY)
        screen.blit(basic_hp_label, (50, 1440 + scroll_y))
        basic_hp_minus_button = pygame.Rect(500, 1440 - button_offset + scroll_y, 50, 50)
        basic_hp_plus_button = pygame.Rect(560, 1440 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, basic_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=basic_hp_plus_button.center))
        pygame.draw.rect(screen, RED, basic_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=basic_hp_minus_button.center))
        if basic_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            basic_hp_setting += 1
            if basic_hp_setting > 99:
                basic_hp_setting = 99
            pygame.time.delay(50)
        if basic_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            basic_hp_setting -= 1
            if basic_hp_setting < 1:
                basic_hp_setting = 1
            pygame.time.delay(50)
        basic_locks_text = font.render(enemy_locking_labels[enemy_locks[0]], True, BLACK)
        basic_locks_button = pygame.Rect(650, 1440 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, GRAY, basic_locks_button, border_radius=10)
        screen.blit(basic_locks_text, basic_locks_text.get_rect(center=basic_locks_button.center))
        if basic_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[0] > 1: enemy_locks[0] = 0
            else: enemy_locks[0] = enemy_locks[0] + 1
            pygame.time.delay(200)



        homing_hp_label = font.render("Homing Enemy - HP: " + str(homing_hp_setting), True, OLIVE)
        screen.blit(homing_hp_label, (50, 1500 + scroll_y))
        homing_hp_minus_button = pygame.Rect(500, 1500 - button_offset + scroll_y, 50, 50)
        homing_hp_plus_button = pygame.Rect(560, 1500 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, homing_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=homing_hp_plus_button.center))
        pygame.draw.rect(screen, RED, homing_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=homing_hp_minus_button.center))
        if homing_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            homing_hp_setting += 1
            if homing_hp_setting > 99:
                homing_hp_setting = 99
            pygame.time.delay(50)
        if homing_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            homing_hp_setting -= 1
            if homing_hp_setting < 1:
                homing_hp_setting = 1
            pygame.time.delay(50)
        homing_locks_text = font.render(enemy_locking_labels[enemy_locks[1]], True, BLACK)
        homing_locks_button = pygame.Rect(650, 1500 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, OLIVE, homing_locks_button, border_radius=10)
        screen.blit(homing_locks_text, homing_locks_text.get_rect(center=homing_locks_button.center))
        if homing_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[1] > 1: enemy_locks[1] = 0
            else: enemy_locks[1] = enemy_locks[1] + 1
            pygame.time.delay(200)


        fatal_hp_label = font.render("Fatal Enemy - HP: " + str(fatal_hp_setting), True, RED)
        screen.blit(fatal_hp_label, (50, 1560 + scroll_y))
        fatal_hp_minus_button = pygame.Rect(500, 1560 - button_offset + scroll_y, 50, 50)
        fatal_hp_plus_button = pygame.Rect(560, 1560 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, fatal_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=fatal_hp_plus_button.center))
        pygame.draw.rect(screen, RED, fatal_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=fatal_hp_minus_button.center))
        if fatal_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            fatal_hp_setting += 1
            if fatal_hp_setting > 99:
                fatal_hp_setting = 99
            pygame.time.delay(50)
        if fatal_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            fatal_hp_setting -= 1
            if fatal_hp_setting < 1:
                fatal_hp_setting = 1
            pygame.time.delay(50)
        fatal_locks_text = font.render(enemy_locking_labels[enemy_locks[2]], True, BLACK)
        fatal_locks_button = pygame.Rect(650, 1560 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, RED, fatal_locks_button, border_radius=10)
        screen.blit(fatal_locks_text, fatal_locks_text.get_rect(center=fatal_locks_button.center))
        if fatal_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[2] > 1: enemy_locks[2] = 0
            else: enemy_locks[2] = enemy_locks[2] + 1
            pygame.time.delay(200)



        flow_hp_label = font.render("Flow Enemy - HP: " + str(flow_hp_setting), True, TEAL)
        screen.blit(flow_hp_label, (50, 1620 + scroll_y))
        flow_hp_minus_button = pygame.Rect(500, 1620 - button_offset + scroll_y, 50, 50)
        flow_hp_plus_button = pygame.Rect(560, 1620 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, flow_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=flow_hp_plus_button.center))
        pygame.draw.rect(screen, RED, flow_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=flow_hp_minus_button.center))
        if flow_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            flow_hp_setting += 1
            if flow_hp_setting > 99:
                flow_hp_setting = 99
            pygame.time.delay(50)
        if flow_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            flow_hp_setting -= 1
            if flow_hp_setting < 1:
                flow_hp_setting = 1
            pygame.time.delay(50)
        flow_locks_text = font.render(enemy_locking_labels[enemy_locks[3]], True, BLACK)
        flow_locks_button = pygame.Rect(650, 1620 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, TEAL, flow_locks_button, border_radius=10)
        screen.blit(flow_locks_text, flow_locks_text.get_rect(center=flow_locks_button.center))
        if flow_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[3] > 1: enemy_locks[3] = 0
            else: enemy_locks[3] = enemy_locks[3] + 1
            pygame.time.delay(200)



        sticky_hp_label = font.render("Sticky Enemy - HP: " + str(sticky_hp_setting), True, GREEN)
        screen.blit(sticky_hp_label, (50, 1680 + scroll_y))
        sticky_hp_minus_button = pygame.Rect(500, 1680 - button_offset + scroll_y, 50, 50)
        sticky_hp_plus_button = pygame.Rect(560, 1680 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, sticky_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=sticky_hp_plus_button.center))
        pygame.draw.rect(screen, RED, sticky_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=sticky_hp_minus_button.center))
        if sticky_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            sticky_hp_setting += 1
            if sticky_hp_setting > 99:
                sticky_hp_setting = 99
            pygame.time.delay(50)
        if sticky_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            sticky_hp_setting -= 1
            if sticky_hp_setting < 1:
                sticky_hp_setting = 1
            pygame.time.delay(50)
        sticky_locks_text = font.render(enemy_locking_labels[enemy_locks[4]], True, BLACK)
        sticky_locks_button = pygame.Rect(650, 1680 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, GREEN, sticky_locks_button, border_radius=10)
        screen.blit(sticky_locks_text, sticky_locks_text.get_rect(center=sticky_locks_button.center))
        if sticky_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[4] > 1: enemy_locks[4] = 0
            else: enemy_locks[4] = enemy_locks[4] + 1
            pygame.time.delay(200)



        gloomy_hp_label = font.render("Gloomy Enemy - HP: " + str(gloomy_hp_setting), True, VIOLET)
        screen.blit(gloomy_hp_label, (50, 1740 + scroll_y))
        gloomy_hp_minus_button = pygame.Rect(500, 1740 - button_offset + scroll_y, 50, 50)
        gloomy_hp_plus_button = pygame.Rect(560, 1740 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, gloomy_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=gloomy_hp_plus_button.center))
        pygame.draw.rect(screen, RED, gloomy_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=gloomy_hp_minus_button.center))
        if gloomy_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            gloomy_hp_setting += 1
            if gloomy_hp_setting > 99:
                gloomy_hp_setting = 99
            pygame.time.delay(50)
        if gloomy_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            gloomy_hp_setting -= 1
            if gloomy_hp_setting < 1:
                gloomy_hp_setting = 1
            pygame.time.delay(50)
        gloomy_locks_text = font.render(enemy_locking_labels[enemy_locks[5]], True, BLACK)
        gloomy_locks_button = pygame.Rect(650, 1740 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, VIOLET, gloomy_locks_button, border_radius=10)
        screen.blit(gloomy_locks_text, gloomy_locks_text.get_rect(center=gloomy_locks_button.center))
        if gloomy_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[5] > 1: enemy_locks[5] = 0
            else: enemy_locks[5] = enemy_locks[5] + 1
            pygame.time.delay(200)



        trail_hp_label = font.render("Trail Enemy - HP: " + str(trail_hp_setting), True, LAVA)
        screen.blit(trail_hp_label, (50, 1800 + scroll_y))
        trail_hp_minus_button = pygame.Rect(500, 1800 - button_offset + scroll_y, 50, 50)
        trail_hp_plus_button = pygame.Rect(560, 1800 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, trail_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=trail_hp_plus_button.center))
        pygame.draw.rect(screen, RED, trail_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=trail_hp_minus_button.center))
        if trail_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            trail_hp_setting += 1
            if trail_hp_setting > 99:
                trail_hp_setting = 99
            pygame.time.delay(50)
        if trail_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            trail_hp_setting -= 1
            if trail_hp_setting < 1:
                trail_hp_setting = 1
            pygame.time.delay(50)
        trail_locks_text = font.render(enemy_locking_labels[enemy_locks[6]], True, BLACK)
        trail_locks_button = pygame.Rect(650, 1800 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, LAVA, trail_locks_button, border_radius=10)
        screen.blit(trail_locks_text, trail_locks_text.get_rect(center=trail_locks_button.center))
        if trail_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[6] > 1: enemy_locks[6] = 0
            else: enemy_locks[6] = enemy_locks[6] + 1
            pygame.time.delay(200)



        impostor_hp_label = font.render("Impostor Enemy - HP: " + str(impostor_hp_setting), True, WHITE)
        screen.blit(impostor_hp_label, (50, 1860 + scroll_y))
        impostor_hp_minus_button = pygame.Rect(500, 1860 - button_offset + scroll_y, 50, 50)
        impostor_hp_plus_button = pygame.Rect(560, 1860 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, impostor_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=impostor_hp_plus_button.center))
        pygame.draw.rect(screen, RED, impostor_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=impostor_hp_minus_button.center))
        if impostor_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            impostor_hp_setting += 1
            if impostor_hp_setting > 99:
                impostor_hp_setting = 99
            pygame.time.delay(50)
        if impostor_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            impostor_hp_setting -= 1
            if impostor_hp_setting < 1:
                impostor_hp_setting = 1
            pygame.time.delay(50)
        impostor_locks_text = font.render(enemy_locking_labels[enemy_locks[7]], True, BLACK)
        impostor_locks_button = pygame.Rect(650, 1860 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, WHITE, impostor_locks_button, border_radius=10)
        screen.blit(impostor_locks_text, impostor_locks_text.get_rect(center=impostor_locks_button.center))
        if impostor_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[7] > 1: enemy_locks[7] = 0
            else: enemy_locks[7] = enemy_locks[7] + 1
            pygame.time.delay(200)



        splitter_hp_label = font.render("Splitter Enemy - HP: " + str(splitter_hp_setting), True, LIME)
        screen.blit(splitter_hp_label, (50, 1920 + scroll_y))
        splitter_hp_minus_button = pygame.Rect(500, 1920 - button_offset + scroll_y, 50, 50)
        splitter_hp_plus_button = pygame.Rect(560, 1920 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, splitter_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=splitter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, splitter_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=splitter_hp_minus_button.center))
        if splitter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            splitter_hp_setting += 1
            if splitter_hp_setting > 99:
                splitter_hp_setting = 99
            pygame.time.delay(50)
        if splitter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            splitter_hp_setting -= 1
            if splitter_hp_setting < 1:
                splitter_hp_setting = 1
            pygame.time.delay(50)
        splitter_locks_text = font.render(enemy_locking_labels[enemy_locks[8]], True, BLACK)
        splitter_locks_button = pygame.Rect(650, 1920 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, LIME, splitter_locks_button, border_radius=10)
        screen.blit(splitter_locks_text, splitter_locks_text.get_rect(center=splitter_locks_button.center))
        if splitter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[8] > 1: enemy_locks[8] = 0
            else: enemy_locks[8] = enemy_locks[8] + 1
            pygame.time.delay(200)



        split_amount_label = font.render("Splits: " + str(split_amount_setting), True, LIME)
        screen.blit(split_amount_label, (276, 1980 + scroll_y))
        split_amount_minus_button = pygame.Rect(500, 1980 - button_offset + scroll_y, 50, 50)
        split_amount_plus_button = pygame.Rect(560, 1980 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, split_amount_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=split_amount_plus_button.center))
        pygame.draw.rect(screen, RED, split_amount_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=split_amount_minus_button.center))
        if split_amount_plus_button.collidepoint(mouse_pos) and mouse_click:
            split_amount_setting += 1
            if split_amount_setting > 20:
                split_amount_setting = 20
            pygame.time.delay(50)
        if split_amount_minus_button.collidepoint(mouse_pos) and mouse_click:
            split_amount_setting -= 1
            if split_amount_setting < 1:
                split_amount_setting += 1
            pygame.time.delay(50)



        bomb_hp_label = font.render("Bomb Enemy - HP: " + str(bomb_hp_setting), True, HOT_PINK)
        screen.blit(bomb_hp_label, (50, 2040 + scroll_y))
        bomb_hp_minus_button = pygame.Rect(500, 2040 - button_offset + scroll_y, 50, 50)
        bomb_hp_plus_button = pygame.Rect(560, 2040 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, bomb_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=bomb_hp_plus_button.center))
        pygame.draw.rect(screen, RED, bomb_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=bomb_hp_minus_button.center))
        if bomb_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            bomb_hp_setting += 1
            if bomb_hp_setting > 99:
                bomb_hp_setting = 99
            pygame.time.delay(50)
        if bomb_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            bomb_hp_setting -= 1
            if bomb_hp_setting < 1:
                bomb_hp_setting = 1
            pygame.time.delay(50)
        bomb_locks_text = font.render(enemy_locking_labels[enemy_locks[9]], True, BLACK)
        bomb_locks_button = pygame.Rect(650, 2040 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, HOT_PINK, bomb_locks_button, border_radius=10)
        screen.blit(bomb_locks_text, bomb_locks_text.get_rect(center=bomb_locks_button.center))
        if bomb_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[9] > 1: enemy_locks[9] = 0
            else: enemy_locks[9] = enemy_locks[9] + 1
            pygame.time.delay(200)



        bomb_projectile_amount_label = font.render("Bullets: " + str(bomb_projectile_amount_setting), True, HOT_PINK)
        screen.blit(bomb_projectile_amount_label, (251, 2100 + scroll_y))
        bomb_projectile_amount_minus_button = pygame.Rect(500, 2100 - button_offset + scroll_y, 50, 50)
        bomb_projectile_amount_plus_button = pygame.Rect(560, 2100 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, bomb_projectile_amount_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=bomb_projectile_amount_plus_button.center))
        pygame.draw.rect(screen, RED, bomb_projectile_amount_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=bomb_projectile_amount_minus_button.center))
        if bomb_projectile_amount_plus_button.collidepoint(mouse_pos) and mouse_click:
            bomb_projectile_amount_setting += 4
            if bomb_projectile_amount_setting > 64:
                bomb_projectile_amount_setting = 64
            pygame.time.delay(50)
        if bomb_projectile_amount_minus_button.collidepoint(mouse_pos) and mouse_click:
            bomb_projectile_amount_setting -= 4
            if bomb_projectile_amount_setting < 4:
                bomb_projectile_amount_setting = 4
            pygame.time.delay(50)



        shooter_hp_label = font.render("Shooter Enemy - HP: " + str(shooter_hp_setting), True, BRONZE)
        screen.blit(shooter_hp_label, (50, 2160 + scroll_y))
        shooter_hp_minus_button = pygame.Rect(500, 2160 - button_offset + scroll_y, 50, 50)
        shooter_hp_plus_button = pygame.Rect(560, 2160 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, shooter_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=shooter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, shooter_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=shooter_hp_minus_button.center))
        if shooter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            shooter_hp_setting += 1
            if shooter_hp_setting > 99:
                shooter_hp_setting = 99
            pygame.time.delay(50)
        if shooter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            shooter_hp_setting -= 1
            if shooter_hp_setting < 1:
                shooter_hp_setting = 1
            pygame.time.delay(50)
        shooter_locks_text = font.render(enemy_locking_labels[enemy_locks[10]], True, BLACK)
        shooter_locks_button = pygame.Rect(650, 2160 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BRONZE, shooter_locks_button, border_radius=10)
        screen.blit(shooter_locks_text, shooter_locks_text.get_rect(center=shooter_locks_button.center))
        if shooter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[10] > 1: enemy_locks[10] = 0
            else: enemy_locks[10] = enemy_locks[10] + 1
            pygame.time.delay(200)



        sniper_hp_label = font.render("Sniper Enemy - HP: " + str(sniper_hp_setting), True, INDIGO)
        screen.blit(sniper_hp_label, (50, 2220 + scroll_y))
        sniper_hp_minus_button = pygame.Rect(500, 2220 - button_offset + scroll_y, 50, 50)
        sniper_hp_plus_button = pygame.Rect(560, 2220 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, sniper_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=sniper_hp_plus_button.center))
        pygame.draw.rect(screen, RED, sniper_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=sniper_hp_minus_button.center))
        if sniper_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            sniper_hp_setting += 1
            if sniper_hp_setting > 99:
                sniper_hp_setting = 99
            pygame.time.delay(50)
        if sniper_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            sniper_hp_setting -= 1
            if sniper_hp_setting < 1:
                sniper_hp_setting = 1
            pygame.time.delay(50)
        sniper_locks_text = font.render(enemy_locking_labels[enemy_locks[11]], True, BLACK)
        sniper_locks_button = pygame.Rect(650, 2220 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, INDIGO, sniper_locks_button, border_radius=10)
        screen.blit(sniper_locks_text, sniper_locks_text.get_rect(center=sniper_locks_button.center))
        if sniper_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[11] > 1: enemy_locks[11] = 0
            else: enemy_locks[11] = enemy_locks[11] + 1
            pygame.time.delay(200)


        speedy_hp_label = font.render("Speedy Enemy - HP: " + str(speedy_hp_setting), True, SKY)
        screen.blit(speedy_hp_label, (50, 2280 + scroll_y))
        speedy_hp_minus_button = pygame.Rect(500, 2280 - button_offset + scroll_y, 50, 50)
        speedy_hp_plus_button = pygame.Rect(560, 2280 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, speedy_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=speedy_hp_plus_button.center))
        pygame.draw.rect(screen, RED, speedy_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=speedy_hp_minus_button.center))
        if speedy_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            speedy_hp_setting += 1
            if speedy_hp_setting > 99:
                speedy_hp_setting = 99
            pygame.time.delay(50)
        if speedy_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            speedy_hp_setting -= 1
            if speedy_hp_setting < 1:
                speedy_hp_setting = 1
            pygame.time.delay(50)
        speedy_locks_text = font.render(enemy_locking_labels[enemy_locks[12]], True, BLACK)
        speedy_locks_button = pygame.Rect(650, 2280 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, SKY, speedy_locks_button, border_radius=10)
        screen.blit(speedy_locks_text, speedy_locks_text.get_rect(center=speedy_locks_button.center))
        if speedy_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[12] > 1: enemy_locks[12] = 0
            else: enemy_locks[12] = enemy_locks[12] + 1
            pygame.time.delay(200)


        shotgun_hp_label = font.render("Shotgun Enemy - HP: " + str(shotgun_hp_setting), True, BRICK)
        screen.blit(shotgun_hp_label, (50, 2340 + scroll_y))
        shotgun_hp_minus_button = pygame.Rect(500, 2340 - button_offset + scroll_y, 50, 50)
        shotgun_hp_plus_button = pygame.Rect(560, 2340 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, shotgun_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=shotgun_hp_plus_button.center))
        pygame.draw.rect(screen, RED, shotgun_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=shotgun_hp_minus_button.center))
        if shotgun_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            shotgun_hp_setting += 1
            if shotgun_hp_setting > 99:
                shotgun_hp_setting = 99
            pygame.time.delay(50)
        if shotgun_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            shotgun_hp_setting -= 1
            if shotgun_hp_setting < 1:
                shotgun_hp_setting = 1
            pygame.time.delay(50)
        shotgun_locks_text = font.render(enemy_locking_labels[enemy_locks[13]], True, BLACK)
        shotgun_locks_button = pygame.Rect(650, 2340 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BRICK, shotgun_locks_button, border_radius=10)
        screen.blit(shotgun_locks_text, shotgun_locks_text.get_rect(center=shotgun_locks_button.center))
        if shotgun_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[13] > 1: enemy_locks[13] = 0
            else: enemy_locks[13] = enemy_locks[13] + 1
            pygame.time.delay(200)



        shotgun_bullets_label = font.render("Bullets: " + str(shotgun_bullets_setting), True, BRICK)
        screen.blit(shotgun_bullets_label, (287, 2400 + scroll_y))
        shotgun_bullets_minus_button = pygame.Rect(500, 2400 - button_offset + scroll_y, 50, 50)
        shotgun_bullets_plus_button = pygame.Rect(560, 2400 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, shotgun_bullets_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=shotgun_bullets_plus_button.center))
        pygame.draw.rect(screen, RED, shotgun_bullets_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=shotgun_bullets_minus_button.center))
        if shotgun_bullets_plus_button.collidepoint(mouse_pos) and mouse_click:
            shotgun_bullets_setting += 1
            if shotgun_bullets_setting > 21:
                shotgun_bullets_setting = 21
            pygame.time.delay(50)
        if shotgun_bullets_minus_button.collidepoint(mouse_pos) and mouse_click:
            shotgun_bullets_setting -= 1
            if shotgun_bullets_setting < 1:
                shotgun_bullets_setting += 1
            pygame.time.delay(50)



        voodoo_hp_label = font.render("Voodoo Enemy - HP: " + str(voodoo_hp_setting), True, MAGENTA)
        screen.blit(voodoo_hp_label, (50, 2460 + scroll_y))
        voodoo_hp_minus_button = pygame.Rect(500, 2460 - button_offset + scroll_y, 50, 50)
        voodoo_hp_plus_button = pygame.Rect(560, 2460 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, voodoo_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=voodoo_hp_plus_button.center))
        pygame.draw.rect(screen, RED, voodoo_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=voodoo_hp_minus_button.center))
        if voodoo_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            voodoo_hp_setting += 1
            if voodoo_hp_setting > 99:
                voodoo_hp_setting = 99
            pygame.time.delay(50)
        if voodoo_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            voodoo_hp_setting -= 1
            if voodoo_hp_setting < 1:
                voodoo_hp_setting = 1
            pygame.time.delay(50)
        voodoo_locks_text = font.render(enemy_locking_labels[enemy_locks[14]], True, BLACK)
        voodoo_locks_button = pygame.Rect(650, 2460 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, MAGENTA, voodoo_locks_button, border_radius=10)
        screen.blit(voodoo_locks_text, voodoo_locks_text.get_rect(center=voodoo_locks_button.center))
        if voodoo_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[14] > 1: enemy_locks[14] = 0
            else: enemy_locks[14] = enemy_locks[14] + 1
            pygame.time.delay(200)



        blind_hp_label = font.render("Blind Enemy - HP: " + str(blind_hp_setting), True, BLUE)
        screen.blit(blind_hp_label, (50, 2520 + scroll_y))
        blind_hp_minus_button = pygame.Rect(500, 2520 - button_offset + scroll_y, 50, 50)
        blind_hp_plus_button = pygame.Rect(560, 2520 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, blind_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=blind_hp_plus_button.center))
        pygame.draw.rect(screen, RED, blind_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=blind_hp_minus_button.center))
        if blind_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            blind_hp_setting += 1
            if blind_hp_setting > 99:
                blind_hp_setting = 99
            pygame.time.delay(50)
        if blind_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            blind_hp_setting -= 1
            if blind_hp_setting < 1:
                blind_hp_setting = 1
            pygame.time.delay(50)
        blind_locks_text = font.render(enemy_locking_labels[enemy_locks[15]], True, BLACK)
        blind_locks_button = pygame.Rect(650, 2520 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BLUE, blind_locks_button, border_radius=10)
        screen.blit(blind_locks_text, blind_locks_text.get_rect(center=blind_locks_button.center))
        if blind_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[15] > 1: enemy_locks[15] = 0
            else: enemy_locks[15] = enemy_locks[15] + 1
            pygame.time.delay(200)




        motion_hp_label = font.render("Motion Enemy - HP: " + str(motion_hp_setting), True, ORANGE)
        screen.blit(motion_hp_label, (50, 2580 + scroll_y))
        motion_hp_minus_button = pygame.Rect(500, 2580 - button_offset + scroll_y, 50, 50)
        motion_hp_plus_button = pygame.Rect(560, 2580 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, motion_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=motion_hp_plus_button.center))
        pygame.draw.rect(screen, RED, motion_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=motion_hp_minus_button.center))
        if motion_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            motion_hp_setting += 1
            if motion_hp_setting > 99:
                motion_hp_setting = 99
            pygame.time.delay(50)
        if motion_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            motion_hp_setting -= 1
            if motion_hp_setting < 1:
                motion_hp_setting = 1
            pygame.time.delay(50)
        motion_locks_text = font.render(enemy_locking_labels[enemy_locks[16]], True, BLACK)
        motion_locks_button = pygame.Rect(650, 2580 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, ORANGE, motion_locks_button, border_radius=10)
        screen.blit(motion_locks_text, motion_locks_text.get_rect(center=motion_locks_button.center))
        if motion_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[16] > 1: enemy_locks[16] = 0
            else: enemy_locks[16] = enemy_locks[16] + 1
            pygame.time.delay(200)


        charger_hp_label = font.render("Charger Enemy - HP: " + str(charger_hp_setting), True, YELLOW)
        screen.blit(charger_hp_label, (50, 2640 + scroll_y))
        charger_hp_minus_button = pygame.Rect(500, 2640 - button_offset + scroll_y, 50, 50)
        charger_hp_plus_button = pygame.Rect(560, 2640 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, charger_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=charger_hp_plus_button.center))
        pygame.draw.rect(screen, RED, charger_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=charger_hp_minus_button.center))
        if charger_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            charger_hp_setting += 1
            if charger_hp_setting > 99:
                charger_hp_setting = 99
            pygame.time.delay(50)
        if charger_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            charger_hp_setting -= 1
            if charger_hp_setting < 1:
                charger_hp_setting = 1
            pygame.time.delay(50)
        charger_locks_text = font.render(enemy_locking_labels[enemy_locks[17]], True, BLACK)
        charger_locks_button = pygame.Rect(650, 2640 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, YELLOW, charger_locks_button, border_radius=10)
        screen.blit(charger_locks_text, charger_locks_text.get_rect(center=charger_locks_button.center))
        if charger_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[17] > 1: enemy_locks[17] = 0
            else: enemy_locks[17] = enemy_locks[17] + 1
            pygame.time.delay(200)


        rapidshooter_hp_label = font.render("Rapidshooter Enemy - HP: " + str(rapidshooter_hp_setting), True, SILVER)
        screen.blit(rapidshooter_hp_label, (50, 2700 + scroll_y))
        rapidshooter_hp_minus_button = pygame.Rect(500, 2700 - button_offset + scroll_y, 50, 50)
        rapidshooter_hp_plus_button = pygame.Rect(560, 2700 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, rapidshooter_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=rapidshooter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, rapidshooter_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=rapidshooter_hp_minus_button.center))
        if rapidshooter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            rapidshooter_hp_setting += 1
            if rapidshooter_hp_setting > 99:
                rapidshooter_hp_setting = 99
            pygame.time.delay(50)
        if rapidshooter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            rapidshooter_hp_setting -= 1
            if rapidshooter_hp_setting < 1:
                rapidshooter_hp_setting = 1
            pygame.time.delay(50)
        rapidshooter_locks_text = font.render(enemy_locking_labels[enemy_locks[18]], True, BLACK)
        rapidshooter_locks_button = pygame.Rect(650, 2700 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, SILVER, rapidshooter_locks_button, border_radius=10)
        screen.blit(rapidshooter_locks_text, rapidshooter_locks_text.get_rect(center=rapidshooter_locks_button.center))
        if rapidshooter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[18] > 1: enemy_locks[18] = 0
            else: enemy_locks[18] = enemy_locks[18] + 1
            pygame.time.delay(200)



        frostbite_hp_label = font.render("Frostbite Enemy - HP: " + str(frostbite_hp_setting), True, CYAN)
        screen.blit(frostbite_hp_label, (50, 2760 + scroll_y))
        frostbite_hp_minus_button = pygame.Rect(500, 2760 - button_offset + scroll_y, 50, 50)
        frostbite_hp_plus_button = pygame.Rect(560, 2760 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, frostbite_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=frostbite_hp_plus_button.center))
        pygame.draw.rect(screen, RED, frostbite_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=frostbite_hp_minus_button.center))
        if frostbite_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            frostbite_hp_setting += 1
            if frostbite_hp_setting > 99:
                frostbite_hp_setting = 99
            pygame.time.delay(50)
        if frostbite_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            frostbite_hp_setting -= 1
            if frostbite_hp_setting < 1:
                frostbite_hp_setting = 1
            pygame.time.delay(50)
        frostbite_locks_text = font.render(enemy_locking_labels[enemy_locks[19]], True, BLACK)
        frostbite_locks_button = pygame.Rect(650, 2760 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, CYAN, frostbite_locks_button, border_radius=10)
        screen.blit(frostbite_locks_text, frostbite_locks_text.get_rect(center=frostbite_locks_button.center))
        if frostbite_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[19] > 1: enemy_locks[19] = 0
            else: enemy_locks[19] = enemy_locks[19] + 1
            pygame.time.delay(200)



        frostbite_projectile_amount_label = font.render("Bullets: " + str(frostbite_projectile_amount_setting), True, CYAN)
        screen.blit(frostbite_projectile_amount_label, (296, 2820 + scroll_y))
        frostbite_projectile_amount_minus_button = pygame.Rect(500, 2820 - button_offset + scroll_y, 50, 50)
        frostbite_projectile_amount_plus_button = pygame.Rect(560, 2820 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, frostbite_projectile_amount_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=frostbite_projectile_amount_plus_button.center))
        pygame.draw.rect(screen, RED, frostbite_projectile_amount_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=frostbite_projectile_amount_minus_button.center))
        if frostbite_projectile_amount_plus_button.collidepoint(mouse_pos) and mouse_click:
            frostbite_projectile_amount_setting += 4
            if frostbite_projectile_amount_setting > 128:
                frostbite_projectile_amount_setting = 128
            pygame.time.delay(50)
        if frostbite_projectile_amount_minus_button.collidepoint(mouse_pos) and mouse_click:
            frostbite_projectile_amount_setting -= 4
            if frostbite_projectile_amount_setting < 4:
                frostbite_projectile_amount_setting = 4
            pygame.time.delay(50)


        addictive_hp_label = font.render("Addictive Enemy - HP: " + str(addictive_hp_setting), True, PINK)
        screen.blit(addictive_hp_label, (50, 2880 + scroll_y))
        addictive_hp_minus_button = pygame.Rect(500, 2880 - button_offset + scroll_y, 50, 50)
        addictive_hp_plus_button = pygame.Rect(560, 2880 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, addictive_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=addictive_hp_plus_button.center))
        pygame.draw.rect(screen, RED, addictive_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=addictive_hp_minus_button.center))
        if addictive_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_hp_setting += 1
            if addictive_hp_setting > 99:
                addictive_hp_setting = 99
            pygame.time.delay(50)
        if addictive_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_hp_setting -= 1
            if addictive_hp_setting < 1:
                addictive_hp_setting = 1
            pygame.time.delay(50)
        addictive_locks_text = font.render(enemy_locking_labels[enemy_locks[20]], True, BLACK)
        addictive_locks_button = pygame.Rect(650, 2880 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, PINK, addictive_locks_button, border_radius=10)
        screen.blit(addictive_locks_text, addictive_locks_text.get_rect(center=addictive_locks_button.center))
        if addictive_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[20] > 1: enemy_locks[20] = 0
            else: enemy_locks[20] = enemy_locks[20] + 1
            pygame.time.delay(200)


        addictive_pull_strength_label = font.render("Strength: " + str(addictive_pull_strength_setting), True, PINK)
        screen.blit(addictive_pull_strength_label, (296, 2940 + scroll_y))
        addictive_pull_strength_minus_button = pygame.Rect(500, 2940 - button_offset + scroll_y, 50, 50)
        addictive_pull_strength_plus_button = pygame.Rect(560, 2940 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, addictive_pull_strength_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=addictive_pull_strength_plus_button.center))
        pygame.draw.rect(screen, RED, addictive_pull_strength_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=addictive_pull_strength_minus_button.center))
        if addictive_pull_strength_plus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_pull_strength_setting += 1
            if addictive_pull_strength_setting > 40:
                addictive_pull_strength_setting = 40
            pygame.time.delay(50)
        if addictive_pull_strength_minus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_pull_strength_setting -= 1
            if addictive_pull_strength_setting < 1:
                addictive_pull_strength_setting = 1
            pygame.time.delay(50)



        addictive_pull_radius_label = font.render("Radius: " + str(addictive_pull_radius_setting), True, PINK)
        screen.blit(addictive_pull_radius_label, (296, 3000 + scroll_y))
        addictive_pull_radius_minus_button = pygame.Rect(500, 3000 - button_offset + scroll_y, 50, 50)
        addictive_pull_radius_plus_button = pygame.Rect(560, 3000 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, addictive_pull_radius_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=addictive_pull_radius_plus_button.center))
        pygame.draw.rect(screen, RED, addictive_pull_radius_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=addictive_pull_radius_minus_button.center))
        if addictive_pull_radius_plus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_pull_radius_setting += 50
            if addictive_pull_radius_setting > 1000:
                addictive_pull_radius_setting = 1000
            pygame.time.delay(50)
        if addictive_pull_radius_minus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_pull_radius_setting -= 50
            if addictive_pull_radius_setting < 100:
                addictive_pull_radius_setting = 100
            pygame.time.delay(50)



        laser_hp_label = font.render("Laser Enemy - HP: " + str(laser_hp_setting), True, TURQUOISE)
        screen.blit(laser_hp_label, (50, 3060 + scroll_y))
        laser_hp_minus_button = pygame.Rect(500, 3060 - button_offset + scroll_y, 50, 50)
        laser_hp_plus_button = pygame.Rect(560, 3060 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, laser_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=laser_hp_plus_button.center))
        pygame.draw.rect(screen, RED, laser_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=laser_hp_minus_button.center))
        if laser_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            laser_hp_setting += 1
            if laser_hp_setting > 99:
                laser_hp_setting = 99
            pygame.time.delay(50)
        if laser_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            laser_hp_setting -= 1
            if laser_hp_setting < 1:
                laser_hp_setting = 1
            pygame.time.delay(50)
        laser_locks_text = font.render(enemy_locking_labels[enemy_locks[21]], True, BLACK)
        laser_locks_button = pygame.Rect(650, 3060 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, TURQUOISE, laser_locks_button, border_radius=10)
        screen.blit(laser_locks_text, laser_locks_text.get_rect(center=laser_locks_button.center))
        if laser_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[21] > 1: enemy_locks[21] = 0
            else: enemy_locks[21] = enemy_locks[21] + 1
            pygame.time.delay(200)



        hardened_hp_label = font.render("Hardened Enemy - HP: " + str(hardened_hp_setting), True, BROWN)
        screen.blit(hardened_hp_label, (50, 3180 + scroll_y))
        hardened_hp_minus_button = pygame.Rect(500, 3180 - button_offset + scroll_y, 50, 50)
        hardened_hp_plus_button = pygame.Rect(560, 3180 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, hardened_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=hardened_hp_plus_button.center))
        pygame.draw.rect(screen, RED, hardened_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=hardened_hp_minus_button.center))
        if hardened_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            hardened_hp_setting += 1
            if hardened_hp_setting > 99:
                hardened_hp_setting = 99
            pygame.time.delay(50)
        if hardened_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            hardened_hp_setting -= 1
            if hardened_hp_setting < 1:
                hardened_hp_setting = 1
            pygame.time.delay(50)
        hardened_locks_text = font.render(enemy_locking_labels[enemy_locks[22]], True, BLACK)
        hardened_locks_button = pygame.Rect(650, 3180 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BROWN, hardened_locks_button, border_radius=10)
        screen.blit(hardened_locks_text, hardened_locks_text.get_rect(center=hardened_locks_button.center))
        if hardened_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[22] > 1: enemy_locks[22] = 0
            else: enemy_locks[22] = enemy_locks[22] + 1
            pygame.time.delay(200)



        accelerator_hp_label = font.render("Accelerator Enemy - HP: " + str(accelerator_hp_setting), True, TAN)
        screen.blit(accelerator_hp_label, (50, 3240 + scroll_y))
        accelerator_hp_minus_button = pygame.Rect(500, 3240 - button_offset + scroll_y, 50, 50)
        accelerator_hp_plus_button = pygame.Rect(560, 3240 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, accelerator_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=accelerator_hp_plus_button.center))
        pygame.draw.rect(screen, RED, accelerator_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=accelerator_hp_minus_button.center))
        if accelerator_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            accelerator_hp_setting += 1
            if accelerator_hp_setting > 99:
                accelerator_hp_setting = 99
            pygame.time.delay(50)
        if accelerator_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            accelerator_hp_setting -= 1
            if accelerator_hp_setting < 1:
                accelerator_hp_setting = 1
            pygame.time.delay(50)
        accelerator_locks_text = font.render(enemy_locking_labels[enemy_locks[23]], True, BLACK)
        accelerator_locks_button = pygame.Rect(650, 3240 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, TAN, accelerator_locks_button, border_radius=10)
        screen.blit(accelerator_locks_text, accelerator_locks_text.get_rect(center=accelerator_locks_button.center))
        if accelerator_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[23] > 1: enemy_locks[23] = 0
            else: enemy_locks[23] = enemy_locks[23] + 1
            pygame.time.delay(200)



        cold_hp_label = font.render("Cold Enemy - HP: " + str(cold_hp_setting), True, ICE)
        screen.blit(cold_hp_label, (50, 3300 + scroll_y))
        cold_hp_minus_button = pygame.Rect(500, 3300 - button_offset + scroll_y, 50, 50)
        cold_hp_plus_button = pygame.Rect(560, 3300 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, cold_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=cold_hp_plus_button.center))
        pygame.draw.rect(screen, RED, cold_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=cold_hp_minus_button.center))
        if cold_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            cold_hp_setting += 1
            if cold_hp_setting > 99:
                cold_hp_setting = 99
            pygame.time.delay(50)
        if cold_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            cold_hp_setting -= 1
            if cold_hp_setting < 1:
                cold_hp_setting = 1
            pygame.time.delay(50)
        cold_locks_text = font.render(enemy_locking_labels[enemy_locks[24]], True, BLACK)
        cold_locks_button = pygame.Rect(650, 3300 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, ICE, cold_locks_button, border_radius=10)
        screen.blit(cold_locks_text, cold_locks_text.get_rect(center=cold_locks_button.center))
        if cold_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[24] > 1: enemy_locks[24] = 0
            else: enemy_locks[24] = enemy_locks[24] + 1
            pygame.time.delay(200)



        tracer_hp_label = font.render("Tracer Enemy - HP: " + str(tracer_hp_setting), True, SULFUR)
        screen.blit(tracer_hp_label, (50, 3360 + scroll_y))
        tracer_hp_minus_button = pygame.Rect(500, 3360 - button_offset + scroll_y, 50, 50)
        tracer_hp_plus_button = pygame.Rect(560, 3360 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, tracer_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=tracer_hp_plus_button.center))
        pygame.draw.rect(screen, RED, tracer_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=tracer_hp_minus_button.center))
        if tracer_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            tracer_hp_setting += 1
            if tracer_hp_setting > 99:
                tracer_hp_setting = 99
            pygame.time.delay(50)
        if tracer_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            tracer_hp_setting -= 1
            if tracer_hp_setting < 1:
                tracer_hp_setting = 1
            pygame.time.delay(50)
        tracer_locks_text = font.render(enemy_locking_labels[enemy_locks[25]], True, BLACK)
        tracer_locks_button = pygame.Rect(650, 3360 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, SULFUR, tracer_locks_button, border_radius=10)
        screen.blit(tracer_locks_text, tracer_locks_text.get_rect(center=tracer_locks_button.center))
        if tracer_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[25] > 1: enemy_locks[25] = 0
            else: enemy_locks[25] = enemy_locks[25] + 1
            pygame.time.delay(200)



        savage_hp_label = font.render("Savage Enemy - HP: " + str(savage_hp_setting), True, MAROON)
        screen.blit(savage_hp_label, (50, 3420 + scroll_y))
        savage_hp_minus_button = pygame.Rect(500, 3420 - button_offset + scroll_y, 50, 50)
        savage_hp_plus_button = pygame.Rect(560, 3420 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, savage_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=savage_hp_plus_button.center))
        pygame.draw.rect(screen, RED, savage_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=savage_hp_minus_button.center))
        if savage_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            savage_hp_setting += 1
            if savage_hp_setting > 99:
                savage_hp_setting = 99
            pygame.time.delay(50)
        if savage_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            savage_hp_setting -= 1
            if savage_hp_setting < 1:
                savage_hp_setting = 1
            pygame.time.delay(50)
        savage_locks_text = font.render(enemy_locking_labels[enemy_locks[26]], True, BLACK)
        savage_locks_button = pygame.Rect(650, 3420 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, MAROON, savage_locks_button, border_radius=10)
        screen.blit(savage_locks_text, savage_locks_text.get_rect(center=savage_locks_button.center))
        if savage_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[26] > 1: enemy_locks[26] = 0
            else: enemy_locks[26] = enemy_locks[26] + 1
            pygame.time.delay(200)



        teleporter_hp_label = font.render("Teleporter Enemy - HP: " + str(teleporter_hp_setting), True, PURPLE)
        screen.blit(teleporter_hp_label, (50, 3480 + scroll_y))
        teleporter_hp_minus_button = pygame.Rect(500, 3480 - button_offset + scroll_y, 50, 50)
        teleporter_hp_plus_button = pygame.Rect(560, 3480 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, teleporter_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=teleporter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, teleporter_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=teleporter_hp_minus_button.center))
        if teleporter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            teleporter_hp_setting += 1
            if teleporter_hp_setting > 99:
                teleporter_hp_setting = 99
            pygame.time.delay(50)
        if teleporter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            teleporter_hp_setting -= 1
            if teleporter_hp_setting < 1:
                teleporter_hp_setting = 1
            pygame.time.delay(50)
        teleporter_locks_text = font.render(enemy_locking_labels[enemy_locks[27]], True, BLACK)
        teleporter_locks_button = pygame.Rect(650, 3480 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, PURPLE, teleporter_locks_button, border_radius=10)
        screen.blit(teleporter_locks_text, teleporter_locks_text.get_rect(center=teleporter_locks_button.center))
        if teleporter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[27] > 1: enemy_locks[27] = 0
            else: enemy_locks[27] = enemy_locks[27] + 1
            pygame.time.delay(200)



        haunter_hp_label = font.render("Haunter Enemy - HP: " + str(haunter_hp_setting), True, NAVY)
        screen.blit(haunter_hp_label, (50, 3540 + scroll_y))
        haunter_hp_minus_button = pygame.Rect(500, 3540 - button_offset + scroll_y, 50, 50)
        haunter_hp_plus_button = pygame.Rect(560, 3540 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, haunter_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=haunter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, haunter_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=haunter_hp_minus_button.center))
        if haunter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            haunter_hp_setting += 1
            if haunter_hp_setting > 99:
                haunter_hp_setting = 99
            pygame.time.delay(50)
        if haunter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            haunter_hp_setting -= 1
            if haunter_hp_setting < 1:
                haunter_hp_setting = 1
            pygame.time.delay(50)
        haunter_locks_text = font.render(enemy_locking_labels[enemy_locks[28]], True, BLACK)
        haunter_locks_button = pygame.Rect(650, 3540 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, NAVY, haunter_locks_button, border_radius=10)
        screen.blit(haunter_locks_text, haunter_locks_text.get_rect(center=haunter_locks_button.center))
        if haunter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[28] > 1: enemy_locks[28] = 0
            else: enemy_locks[28] = enemy_locks[28] + 1
            pygame.time.delay(200)



        stream_hp_label = font.render("Stream Enemy - HP: " + str(stream_hp_setting), True, AQUA)
        screen.blit(stream_hp_label, (50, 3600 + scroll_y))
        stream_hp_minus_button = pygame.Rect(500, 3600 - button_offset + scroll_y, 50, 50)
        stream_hp_plus_button = pygame.Rect(560, 3600 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, stream_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=stream_hp_plus_button.center))
        pygame.draw.rect(screen, RED, stream_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=stream_hp_minus_button.center))
        if stream_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            stream_hp_setting += 1
            if stream_hp_setting > 99:
                stream_hp_setting = 99
            pygame.time.delay(50)
        if stream_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            stream_hp_setting -= 1
            if stream_hp_setting < 1:
                stream_hp_setting = 1
            pygame.time.delay(50)
        stream_locks_text = font.render(enemy_locking_labels[enemy_locks[29]], True, BLACK)
        stream_locks_button = pygame.Rect(650, 3600 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, AQUA, stream_locks_button, border_radius=10)
        screen.blit(stream_locks_text, stream_locks_text.get_rect(center=stream_locks_button.center))
        if stream_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[29] > 1: enemy_locks[29] = 0
            else: enemy_locks[29] = enemy_locks[29] + 1
            pygame.time.delay(200)



        harden_break_label = font.render("Unhardening Rate: " + str(harden_break_setting), True, WHITE)
        screen.blit(harden_break_label, (50, 3660 + scroll_y))
        harden_break_minus_button = pygame.Rect(500, 3660 - button_offset + scroll_y, 50, 50)
        harden_break_plus_button = pygame.Rect(560, 3660 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, harden_break_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=harden_break_plus_button.center))
        pygame.draw.rect(screen, RED, harden_break_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=harden_break_minus_button.center))
        if harden_break_plus_button.collidepoint(mouse_pos) and mouse_click:
            harden_break_setting += 1
            if harden_break_setting > 40:
                harden_break_setting = 40
            pygame.time.delay(50)
        if harden_break_minus_button.collidepoint(mouse_pos) and mouse_click:
            harden_break_setting -= 1
            if harden_break_setting < 1:
                harden_break_setting = 1
            pygame.time.delay(50)



        pygame.draw.rect(screen, GRAY, scrollbar_track, border_radius=6)
        pygame.draw.rect(screen, WHITE, scrollbar_handle, border_radius=6)

        

        for event in pygame.event.get():
            if event.type == pygame.MOUSEWHEEL:
                scroll_y += event.y * scroll_speed * 2
                scroll_y = max(min(scroll_y, 0), -max_scroll)
            if event.type == pygame.QUIT:
                pygame.quit(); exit()
            if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                if 0 in enemy_locks: running = False
            if event.type == pygame.MOUSEBUTTONDOWN:
                if scrollbar_handle.collidepoint(event.pos):
                    dragging_scrollbar = True
                    mouse_offset_y = event.pos[1] - scrollbar_handle.y

            if event.type == pygame.MOUSEBUTTONUP:
                dragging_scrollbar = False

            if event.type == pygame.MOUSEMOTION and dragging_scrollbar:
                new_y = event.pos[1] - mouse_offset_y
                new_y = max(
                    scrollbar_track.y,
                    min(new_y, scrollbar_track.bottom - handle_height)
                )

                ratio = (new_y - scrollbar_track.y) / (scrollbar_track.height - handle_height)
                scroll_y = -int(ratio * max_scroll)
        pygame.display.flip()
        clock.tick(60)

menu_font = pygame.font.Font(None, 48)
text_color = (255, 255, 255)

button_width, button_height = 200, 60
margin = 40
button_gap = 40

total_width = button_width * 2 + button_gap
start_x = (WIDTH - total_width) // 2
y_pos = HEIGHT - button_height - margin - 400


def apply_settings():
    global player_size, player_font, enemy_size, enemy_font, projectile_size, trail_size
    global min_spawn_delay, initial_spawn_delay, spawn_rate
    global player_speed, player_speed_base, player2_speed, player2_speed_base, enemy_speed
    global bomb_projectile_speed, shooter_projectile_speed, sniper_projectile_speed, shotgun_projectile_speed, rapidshooter_projectile_speed, frostbite_projectile_speed
    global regen_delay, player_lives, player2_lives
    global trail_lifetime_ms, trail_interval_ms
    global freeze_duration
    global invincibility_duration
    global chase_turn
    global stickiness
    global projectile_fire_rate
    global basic_hp
    global homing_hp
    global fatal_hp
    global flow_hp
    global sticky_hp
    global gloomy_hp
    global trail_hp
    global impostor_hp
    global splitter_hp, split_amount
    global bomb_hp, bomb_projectile_amount
    global shooter_hp
    global sniper_hp
    global speedy_hp
    global shotgun_hp
    global shotgun_bullets
    global voodoo_hp
    global blind_hp
    global motion_hp
    global charger_hp
    global rapidshooter_hp
    global frostbite_hp, frostbite_projectile_amount
    global addictive_hp, addictive_pull_radius, addictive_pull_strength
    global laser_hp
    global hardened_hp, harden_break
    global accelerator_hp
    global cold_hp
    global tracer_hp
    global savage_hp
    global teleporter_hp
    global haunter_hp
    global stream_hp
    

    # --- SETTINGS SET ---
    player_size = player_size_setting
    player_font = pygame.font.SysFont(None, int(0.96 * player_size))
    enemy_size = enemy_size_setting
    enemy_font = pygame.font.SysFont(None, int(0.96 * enemy_size))
    min_spawn_delay = min_spawn_delay_setting
    initial_spawn_delay = max_spawn_delay_setting
    projectile_size = projectile_size_setting
    trail_size = projectile_size_setting
    spawn_rate = spawn_delay_change_setting
    player_speed = player_speed_setting
    player_speed_base = player_speed_setting
    player2_speed = player_speed_setting
    player2_speed_base = player_speed_setting
    enemy_speed = enemy_speed_setting
    bomb_projectile_speed = 2.5 * (projectile_speed_setting / 5)
    shooter_projectile_speed = 5 * (projectile_speed_setting / 5)
    sniper_projectile_speed = 10 * (projectile_speed_setting / 5)
    shotgun_projectile_speed = 5 * (projectile_speed_setting / 5)
    rapidshooter_projectile_speed = 5 * (projectile_speed_setting / 5)
    frostbite_projectile_speed = 5 * (projectile_speed_setting / 5)
    regen_delay = regen_delay_setting
    player_lives = player_health_setting
    player2_lives = player2_health_setting
    trail_lifetime_ms = trail_duration_setting
    trail_interval_ms = trail_distance_setting
    freeze_duration = freeze_duration_setting
    invincibility_duration = invincibility_duration_setting
    chase_turn = chaser_turn_amount_setting
    stickiness = enemy_stick_setting
    projectile_fire_rate = projectile_fire_rate_setting
    basic_hp = basic_hp_setting
    homing_hp = homing_hp_setting
    fatal_hp = fatal_hp_setting
    flow_hp = flow_hp_setting
    sticky_hp = sticky_hp_setting
    gloomy_hp = gloomy_hp_setting
    trail_hp = trail_hp_setting
    impostor_hp = impostor_hp_setting
    splitter_hp = splitter_hp_setting
    split_amount = split_amount_setting
    bomb_hp = bomb_hp_setting
    bomb_projectile_amount = bomb_projectile_amount_setting
    shooter_hp = shooter_hp_setting
    sniper_hp = sniper_hp_setting
    speedy_hp = speedy_hp_setting
    shotgun_hp = shotgun_hp_setting
    shotgun_bullets = shotgun_bullets_setting
    voodoo_hp = voodoo_hp_setting
    blind_hp = blind_hp_setting
    motion_hp = motion_hp_setting
    charger_hp = charger_hp_setting
    rapidshooter_hp = rapidshooter_hp_setting
    frostbite_hp = frostbite_hp_setting
    frostbite_projectile_amount = frostbite_projectile_amount_setting
    addictive_hp = addictive_hp_setting
    addictive_pull_radius = addictive_pull_radius_setting
    addictive_pull_strength = addictive_pull_strength_setting
    laser_hp = laser_hp_setting
    hardened_hp = hardened_hp_setting
    harden_break = harden_break_setting
    accelerator_hp = accelerator_hp_setting
    cold_hp = cold_hp_setting
    tracer_hp = tracer_hp_setting
    savage_hp = savage_hp_setting
    teleporter_hp = teleporter_hp_setting
    haunter_hp = haunter_hp_setting
    stream_hp = stream_hp_setting
    
    available_enemy_types.clear()
    locked_enemy_types.clear()
    unlock_scores.clear()
    enemy_counter = 0
    for i in enemy_locks:
        enemy_lock_setup(i, enemy_counter)
        enemy_counter += 1
    random.shuffle(locked_enemy_types)
    unlocks = 0
    for unlocked in range(len(locked_enemy_types)):
        unlock_scores.append(100 * (1 + unlocked))

    


def TITLE_SCREEN():
    global players

    start_button = pygame.Rect(WIDTH//2 - 100, HEIGHT//2 - 50, 200, 60)
    settings_button = pygame.Rect(WIDTH//2 - 100, HEIGHT//2 + 150, 200, 60)
    button_1p = pygame.Rect(start_x, y_pos, button_width, button_height)
    button_2p = pygame.Rect(start_x + button_width + button_gap, y_pos, button_width, button_height)

    # Move the player buttons slightly DOWN so they sit under the Start button
    button_1p.x = WIDTH//2 - 220  # move left
    button_1p.y = HEIGHT//2 + 50

    button_2p.x = WIDTH//2 + 20   # move right
    button_2p.y = HEIGHT//2 + 50
    
    waiting = True
    while waiting:
        screen.fill((0, 0, 0))
        title_text = big_font.render("Pixels Of Evasion", True, (255, 0, 0))
        screen.blit(title_text, title_text.get_rect(center=(WIDTH//2, HEIGHT//2 - 150)))

        mouse_pos = pygame.mouse.get_pos()
        mouse_click = pygame.mouse.get_pressed()[0]

        # --- Start Game button (TOP) ---
        if players in [1, 2]:
            color = GREEN if start_button.collidepoint(mouse_pos) else FOREST
        else:
            color = LIME  # disabled look until a mode is chosen

        pygame.draw.rect(screen, color, start_button, border_radius=10)
        start_text = font.render("Start Game", True, (255, 255, 255))
        screen.blit(start_text, start_text.get_rect(center=start_button.center))

        if start_button.collidepoint(mouse_pos) and mouse_click and players in [1, 2]:
            apply_settings()
            reset_game_state()
            waiting = False

        # --- Settings button (TOP) ---
        if players in [1, 2]:
            color = BLUE if settings_button.collidepoint(mouse_pos) else NAVY
        else:
            color = SKY  # disabled look until a mode is chosen

        pygame.draw.rect(screen, color, settings_button, border_radius=10)
        settings_text = font.render("Settings", True, (255, 255, 255))
        screen.blit(settings_text, settings_text.get_rect(center=settings_button.center))

        if settings_button.collidepoint(mouse_pos) and mouse_click:
            SETTINGS()
            pygame.time.delay(200)   # <-- prevents instant selection
            continue

        # --- Player buttons (BELOW Start button) ---
        for rect, label, value in [(button_1p, "1 Player", 1), (button_2p, "2 Players", 2)]:
            if players == value:
                color = RED
            elif rect.collidepoint(mouse_pos):
                color = MAROON
            else:
                color = CRISP

            pygame.draw.rect(screen, color, rect, border_radius=10)
            text = font.render(label, True, text_color)
            screen.blit(text, text.get_rect(center=rect.center))

            if rect.collidepoint(mouse_pos) and mouse_click:
                players = value

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()

        pygame.display.flip()
        clock.tick(15)


TITLE_SCREEN()
spawn_enabled = False
p1_ready = False
p2_ready = False

running = True
while running:
    clock.tick(FPS)
    current_time = pygame.time.get_ticks()

    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            running = False

    keys = pygame.key.get_pressed()

    # Determine movement for Player 1
    if players == 1:
        p1_dx = (keys[pygame.K_d] or keys[pygame.K_RIGHT]) - (keys[pygame.K_a] or keys[pygame.K_LEFT])
        p1_dy = (keys[pygame.K_s] or keys[pygame.K_DOWN]) - (keys[pygame.K_w] or keys[pygame.K_UP])
    else:
        p1_dx = (keys[pygame.K_d]) - (keys[pygame.K_a])
        p1_dy = (keys[pygame.K_s]) - (keys[pygame.K_w])
    if p1_dx != 0 or p1_dy != 0:
        length1 = math.hypot(p1_dx, p1_dy)
        p1_dx = (p1_dx / length1) * player_speed
        p1_dy = (p1_dy / length1) * player_speed

    keys2 = pygame.key.get_pressed()
    
    # Determine movement for Player 2 (if exists)
    p2_dx, p2_dy = 0, 0
    if players == 2:
        p2_dx = ((keys[pygame.K_l]) - (keys[pygame.K_j]))
        p2_dy = ((keys[pygame.K_k]) - (keys[pygame.K_i]))
        if p2_dx != 0 or p2_dy != 0:
            length2 = math.hypot(p2_dx, p2_dy)
            p2_dx = p2_dx / length2 * player2_speed
            p2_dy = p2_dy / length2 * player2_speed

    # Move players
    if p1_dx != 0 or p1_dy != 0: p1_ready = True
    player_x += p1_dx
    player_y += p1_dy
    player_x = max(player_size / 2, min(WIDTH - player_size / 2, player_x))
    player_y = max(player_size / 2, min(HEIGHT - player_size / 2, player_y))

    if players == 2:
        if p2_dx != 0 or p2_dy != 0: p2_ready = True
        player2_x += p2_dx
        player2_y += p2_dy
        player2_x = max(player_size / 2, min(WIDTH - player_size / 2, player2_x))
        player2_y = max(player_size / 2, min(HEIGHT - player_size / 2, player2_y))

        if player_alive and player2_alive:
            if centered_rect_collision(player_x, player_y, player_size,
                               player2_x, player2_y, player_size):
                overlap_x = (player_size - abs(player_x - player2_x)) / 2
                overlap_y = (player_size - abs(player_y - player2_y)) / 2

                # Push both players apart along the smallest overlap axis
                if overlap_x < overlap_y:
                    if player_x < player2_x:
                        player_x -= overlap_x
                        player2_x += overlap_x
                    else:
                        player_x += overlap_x
                        player2_x -= overlap_x
                else:
                    if player_y < player2_y:
                        player_y -= overlap_y
                        player2_y += overlap_y
                    else:
                        player_y += overlap_y
                        player2_y -= overlap_y


    player_moving = (p1_dx != 0 or p1_dy != 0)

    if current_time > slow_until:
        player_speed = player_speed_base
        player_frozen = False
    if players == 2 and current_time > player2_slow_until:
        player2_speed = player2_speed_base
        player2_frozen = False

    # Update spawner activation
    if not spawn_enabled:
        if p1_ready and players == 1: spawn_enabled = True
        if p1_ready and p2_ready and players == 2: spawn_enabled = True


        
    # --- Dynamic Enemy Unlock ---
    while unlock_scores and truescore >= unlock_scores[0]:
        if len(locked_enemy_types) > 0:
            new_type = locked_enemy_types[0]
            available_enemy_types.append(new_type)
            locked_enemy_types.remove(new_type)
        unlock_scores.pop(0)

    # --- Enemy Spawning ---
    adjusted_score = score / 5  # scale back to old point rate
    spawn_delay = max(
        min_spawn_delay,
        initial_spawn_delay - int(adjusted_score * spawn_rate)
    )
    if spawn_enabled and current_time - last_spawn_time >= spawn_delay:
        enemy_type = random.choice(available_enemy_types)
        angle = random.uniform(0, 2 * math.pi)
        dx = math.cos(angle) * enemy_speed
        dy = math.sin(angle) * enemy_speed
        sussy_dx = math.cos(angle) * player_speed_base
        sussy_dy = math.sin(angle) * player_speed_base
        base_dx = dx
        base_dy = dy

        # Default values
        health = basic_hp
        shoot_delay = 1

        # Determine enemy attributes based on type
        if enemy_type == 1:
            dx *= 1; dy *= 1; health = basic_hp
        elif enemy_type == 2:
            dx *= 0.7; dy *= 0.7; health = homing_hp
        elif enemy_type == 3:
            dx *= 0.5; dy *= 0.5; health = fatal_hp
        elif enemy_type == 4:
            dx *= 2/3; dy *= 2/3; health = flow_hp
        elif enemy_type == 5:
            dx *= 1; dy *= 1; health = sticky_hp
        elif enemy_type == 6:
            dx *= 1; dy *= 1; health = gloomy_hp
        elif enemy_type == 7:
            dx *= 1; dy *= 1; health = trail_hp
        elif enemy_type == 8:
            health = impostor_hp
        elif enemy_type == 9:
            dx *= 1; dy *= 1; health = splitter_hp
        elif enemy_type == 10:
            dx *= 1; dy *= 1; health = bomb_hp
        elif enemy_type == 11:
            dx *= 0.9; dy *= 0.9; health = shooter_hp
            shoot_delay = shooter_delay
        elif enemy_type == 12:
            dx *= 0.3; dy *= 0.3; health = sniper_hp
            shoot_delay = sniper_delay
        elif enemy_type == 13:
            dx *= 2; dy *= 2; health = speedy_hp
        elif enemy_type == 14:
            dx *= 0.9; dy *= 0.9; health = shotgun_hp
            shoot_delay = shotgun_delay
        elif enemy_type == 15:
            dx *= 0.35; dy *= 0.35; health = voodoo_hp
        elif enemy_type == 16:
            dx *= 1.5; dy *= 1.5; health = blind_hp
        elif enemy_type == 17:
            dx *= 1.5; dy *= 1.5; health = motion_hp
        elif enemy_type == 18:
            dx *= 2; dy *= 2; health = charger_hp
        elif enemy_type == 19:
            dx *= 1.25; dy *= 1.25; health = rapidshooter_hp
            shoot_delay = rapidshooter_delay
        elif enemy_type == 20:
            dx *= 0.5; dy *= 0.5; health = frostbite_hp
        elif enemy_type == 21:
            dx *= 0.75; dy *= 0.75; health = addictive_hp
        elif enemy_type == 22:
            dx *= 0.65; dy *= 0.65; health = laser_hp
        elif enemy_type == 23:
            dx *= 0.5; dy *= 0.5; health = hardened_hp
        elif enemy_type == 24:
            base_dx = dx; base_dy = dy
            dx *= 0; dy *= 0; health = accelerator_hp
            accel = 0.0; accel_rate = 0.02
        elif enemy_type == 25:
            dx *= 0.5; dy *= 0.5; health = cold_hp
        elif enemy_type == 26:
            dx *= 0.7; dy *= 0.7; health = tracer_hp
        elif enemy_type == 27:
            dx *= 2/3; dy *= 2/3; health = savage_hp
        elif enemy_type == 28:
            dx *= 1; dy *= 1; health = teleporter_hp
        elif enemy_type == 29:
            dx *= 0.7; dy *= 0.7; health = haunter_hp
        elif enemy_type == 30:
            dx *= 2/3; dy *= 2/3; health = stream_hp

        if enemy_type in targetting_enemies:
            if players == 1:
                target = 1
            else:
                target = random.choice([1, 2])
        else: target = 0
            

        enemies.append({
            "dead": False,
            "x": spawner_pos[0]+25,
            "y": spawner_pos[1]+25,
            "target": target,
            "dx": dx,
            "dy": dy,
            "sussy_dx": sussy_dx,
            "sussy_dy": sussy_dy,
            "base_dx": base_dx,
            "base_dy": base_dy,
            "accel": accel,
            "accel_rate": accel_rate,
            "type": enemy_type,
            "angle": angle,
            "bounces": 0,
            "shrinking": False,
            "size": enemy_size,        # use the global default size initially
            "health": health,
            "ability": 1,
            "stopped": False,
            "stop_start_time": None,
            "last_trail_time": current_time,
            "last_shot_time": current_time,
            "shoot_delay": shoot_delay/(projectile_fire_rate/10),
            "spawn_protected": True,
            "spawn_time": current_time
        })
        last_spawn_time = current_time
        
        for enemy in enemies:
            if players == 2:
                if not player_alive and player2_alive:
                    enemy["target"] = 2
                elif not player2_alive and player_alive:
                    enemy["target"] = 1

    # --- Enemy Movement ---
    for enemy in enemies:
        enemy_died = False
        sz = enemy.get("size", enemy_size)
        if enemy["type"] == 1:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= basic_hp: enemy_died = True

        elif enemy["type"] == 2:
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                dx = tx - enemy["x"]; dy = ty - enemy["y"]
            else:
                dx, dy = 0, 0
            target_angle = math.atan2(dy, dx)
            enemy["angle"] = rotate_toward(enemy["angle"], target_angle, chase_turn/250)#THIS IS THE TURN SPEED 0.02
            enemy["dx"] = math.cos(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["dy"] = math.sin(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["angle"] = math.pi - enemy["angle"]; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["angle"] = -enemy["angle"]; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= homing_hp: enemy_died = True

        elif enemy["type"] == 3:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= fatal_hp: enemy_died = True

        elif enemy["type"] == 4:
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            speed_multiplier = 2.5 if closest_dist < 200+enemy_size/2+player_size/2 else 2/3
            enemy["x"] += enemy["dx"] * speed_multiplier
            enemy["y"] += enemy["dy"] * speed_multiplier
            bounced = False
            # X-axis bounce
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
                if enemy["x"] <= 0: enemy["x"] = 0
                elif enemy["x"] >= WIDTH - enemy_size: enemy["x"] = WIDTH - enemy_size/2
            # Y-axis bounce
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
                if enemy["y"] <= 0: enemy["y"] = 0
                elif enemy["y"] >= HEIGHT - enemy_size: enemy["y"] = HEIGHT - enemy_size/2
            # Update bounce count and health once per frame
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            # Remove enemy if health depleted
            if enemy["bounces"] >= flow_hp or enemy["health"] <= 0:
                enemy_died = True
                
        elif enemy["type"] == 5:
            if enemy["stopped"]:
                if current_time - enemy["stop_start_time"] >= stickiness:
                    enemy["stopped"] = False
            else:
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                bounced = False
                if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                    enemy["dx"] *= -1
                    bounced = True
                if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                    enemy["dy"] *= -1
                    bounced = True

                if bounced:
                    enemy["health"] -= 1
                    if enemy["health"] <= 0:
                        enemy_died = True
                    else:
                        enemy["stopped"] = True
                        enemy["stop_start_time"] = current_time

            if enemy["health"] <= 0:
                enemy_died = True

        elif enemy["type"] == 6:
            dist1 = distance(enemy["x"]-enemy_size/2, enemy["y"]-enemy_size/2, player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"]-enemy_size/2, enemy["y"]-enemy_size/2, player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            if closest_dist > 200+enemy_size/2+player_size/2:
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]
                bounced = False
                if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: 
                    enemy["dx"] *= -1; bounced = True
                if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: 
                    enemy["dy"] *= -1; bounced = True
                if bounced:
                    enemy["bounces"] += 1; enemy["health"] -= 1
                if enemy["health"] <= 0: enemy_died = True


        elif enemy["type"] == 7:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if current_time - enemy["last_trail_time"] >= trail_interval_ms:
                trail_squares.append({
                    "x": int(enemy["x"]),
                    "y": int(enemy["y"]),
                    "spawn": current_time,
                    "health": 3,
                    "color": LAVA
                })
                enemy["last_trail_time"] = current_time
            if enemy["health"] <= 0: enemy_died = True

        elif enemy["type"] == 8:
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                if (enemy["target"] == 1 and (p1_dx or p1_dy)) or (enemy["target"] == 2 and (p2_dx or p2_dy)):
                    if player_frozen == True and enemy["target"] == 1:
                        enemy["x"] += enemy["sussy_dx"] * 0.5
                        enemy["y"] += enemy["sussy_dy"] * 0.5
                    elif player2_frozen == True and enemy["target"] == 2:
                        enemy["x"] += enemy["sussy_dx"] * 0.5
                        enemy["y"] += enemy["sussy_dy"] * 0.5
                    else:
                        enemy["x"] += enemy["sussy_dx"]
                        enemy["y"] += enemy["sussy_dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["sussy_dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["sussy_dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= impostor_hp or enemy["health"] <= 0:
                enemy_died = True

        elif enemy["type"] == 9:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            if enemy.get("spawn_protected"):
                if pygame.time.get_ticks() - enemy["spawn_time"] > 500:
                    enemy.pop("spawn_protected")

            hit_edge = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                hit_edge = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                hit_edge = True

            if hit_edge:
                if enemy.get("spawn_protected"):
                    if enemy["x"] < enemy_size/2 or enemy["x"] > WIDTH - enemy_size/2:
                        enemy["dx"] *= -1
                    if enemy["y"] < enemy_size/2 or enemy["y"] > HEIGHT - enemy_size/2:
                        enemy["dy"] *= -1
                    length = math.hypot(enemy["dx"], enemy["dy"])

                    if length != 0:
                        enemy["dx"] = (enemy["dx"] / length) * enemy_speed
                        enemy["dy"] = (enemy["dy"] / length) * enemy_speed
                else:
                    if enemy["health"] > 1:
                        for i in range(split_amount):
                            angle = random.uniform(0, 2 * math.pi)
                            dx = math.cos(angle) * enemy_speed
                            dy = math.sin(angle) * enemy_speed
                            enemies.append({
                                "x": max(1 + enemy_size/2, min(WIDTH - enemy_size/2 - 1, enemy["x"])),
                                "y": max(1 + enemy_size/2, min(HEIGHT - enemy_size/2 - 1, enemy["y"])),
                                "dx": dx,
                                "dy": dy,
                                "type": 9,
                                "angle": angle,
                                "bounces": 0,
                                "health": enemy["health"] - 1,
                                "spawn_protected": True,
                                "spawn_time": pygame.time.get_ticks()
                            })
                    enemy["dead"] = True
                continue
            if enemy.get("waiting"):
                # Check if off edge now
                if 0 < enemy["x"] < WIDTH - enemy_size and 0 < enemy["y"] < HEIGHT - enemy_size:
                    enemy.pop("waiting")

                    
        elif enemy["type"] == 10:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["health"] -= 1

            # Proximity trigger  bomb kills itself and explodes
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            if min(dist1, dist2) < 150+enemy_size/2+player_size/2:
                for i in range(bomb_projectile_amount):  # fire 8 projectiles in all directions
                    ang = i * (2 * math.pi / bomb_projectile_amount)
                    dxp = math.cos(ang) * bomb_projectile_speed
                    dyp = math.sin(ang) * bomb_projectile_speed
                    projectiles.append({
                        "x": enemy["x"] + projectile_size/2,
                        "y": enemy["y"] + projectile_size/2,
                        "dx": dxp,
                        "dy": dyp
                    })
                enemy["health"] = 0
            if enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 11:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced: 
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= shooter_hp or enemy["health"] <= 0:
                enemy_died = True

            # Shoot at player
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                dist = math.hypot(dxp, dyp)
                dxp = dxp / dist * shooter_projectile_speed
                dyp = dyp / dist * shooter_projectile_speed
                projectiles.append({
                    "x": enemy["x"] + projectile_size/2,
                    "y": enemy["y"] + projectile_size/2,
                    "dx": dxp,
                    "dy": dyp,
                    "color": BRONZE   # add color key
                })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 12:  # Get Sniped
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced: 
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= sniper_hp or enemy["health"] <= 0:
                enemy_died = True
            # Shoot at player
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                dist = math.hypot(dxp, dyp)
                dxp = dxp / dist * sniper_projectile_speed
                dyp = dyp / dist * sniper_projectile_speed
                projectiles.append({
                    "x": enemy["x"] + projectile_size/2,
                    "y": enemy["y"] + projectile_size/2,
                    "dx": dxp,
                    "dy": dyp,
                    "color": INDIGO
                })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 13:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= speedy_hp: enemy_died = True
        elif enemy["type"] == 14:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= shotgun_hp or enemy["health"] <= 0:
                enemy_died = True

            # --- Fire 5 bullets in a spread ---
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                base_angle = math.atan2(dyp, dxp)
                spread = math.radians(150/shotgun_bullets)  # total spread angle
                for i in range(shotgun_bullets):
                    angle_offset = spread * (i - (shotgun_bullets - 1)/2) / 4  # center + 2 on each side
                    ang = base_angle + angle_offset
                    projectiles.append({
                        "x": enemy["x"] + projectile_size/2,
                        "y": enemy["y"] + projectile_size/2,
                        "dx": math.cos(ang) * shotgun_projectile_speed,
                        "dy": math.sin(ang) * shotgun_projectile_speed,
                        "color": BRICK
                    })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 15:  # Magenta Voodoo
            if enemy.get("shrinking"):
                enemy["size"] = enemy.get("size", "enemy_size") * 0.85 if isinstance(enemy.get("size", None), (int, float)) else sz * 0.85
                # update local size variable for subsequent checks/drawing
                sz = enemy["size"]
                if enemy["size"] < 2:
                    # remove immediately once tiny
                    if enemy in enemies:
                        enemy["dead"] = True
                    continue
            # movement using current size (sz)
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= sz/2 or enemy["x"] >= WIDTH - sz/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= sz/2 or enemy["y"] >= HEIGHT - sz/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
                # when it loses all HP from bounces, player takes 1 damage
                if enemy["health"] <= 0:
                    if current_time >= invincible_until:
                        if enemy["target"] == 1:
                            player_lives -= 1
                            p1_regen_block_until = score + regen_delay
                        if enemy["target"] == 2:
                            player2_lives -= 1
                            p2_regen_block_until = score + regen_delay
                        damage_flash_time = current_time
                        invincible_until = current_time + invincibility_duration
                        if player_lives <= 0:
                            player_alive = False
                        if player2_lives <= 0:
                            player2_alive = False
                    enemy_died = True
        elif enemy["type"] == 16:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= blind_hp or enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 17:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= motion_hp or enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 18:
            if enemy["stopped"]:
                if current_time - enemy["stop_start_time"] >= stickiness*4:
                    enemy["stopped"] = False
            else:
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                bounced = False
                if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                    enemy["dx"] *= -1
                    bounced = True
                if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                    enemy["dy"] *= -1
                    bounced = True

                if bounced:
                    enemy["health"] -= 1
                    if enemy["health"] <= 0:
                        enemy_died = True
                    else:
                        enemy["stopped"] = True
                        enemy["stop_start_time"] = current_time

            if enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 19:  # Rapid Shooter
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced: 
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= rapidshooter_hp or enemy["health"] <= 0:
                enemy_died = True

            # Shoot at player
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                dist = math.hypot(dxp, dyp)
                dxp = dxp / dist * rapidshooter_projectile_speed
                dyp = dyp / dist * rapidshooter_projectile_speed
                projectiles.append({
                    "x": enemy["x"] + projectile_size/2,
                    "y": enemy["y"] + projectile_size/2,
                    "dx": dxp,
                    "dy": dyp,
                    "color": SILVER   # add color key
                })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 20:  # Frostbite
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["health"] -= 1

            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            if min(dist1, dist2) < 150+enemy_size/2+player_size/2 and enemy["ability"] == 1:
                for i in range(frostbite_projectile_amount):
                    ang = i * (2 * math.pi / frostbite_projectile_amount)
                    dxp = math.cos(ang) * frostbite_projectile_speed
                    dyp = math.sin(ang) * frostbite_projectile_speed
                    projectiles.append({
                        "x": enemy["x"] + projectile_size/2,
                        "y": enemy["y"] + projectile_size/2,
                        "dx": dxp,
                        "dy": dyp,
                        "color": CYAN
                    })
                enemy["ability"] = 0
            if enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 21:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["health"] -= 1
                if enemy["health"] <= 0:
                    enemy_died = True

            pull_radius = addictive_pull_radius
            base_pull_strength = addictive_pull_strength
            if player_alive:
                dxp = enemy["x"] - player_x
                dyp = enemy["y"] - player_y
                dist = math.hypot(dxp, dyp)
                if dist < pull_radius-50+enemy_size/2+player_size/2 and dist > 1:
                    pull_strength = base_pull_strength * (1 - dist / (pull_radius-50+enemy_size/2+player_size/2))
                    player_x += (dxp / dist) * pull_strength
                    player_y += (dyp / dist) * pull_strength
            if players == 2 and player2_alive:
                dxp = enemy["x"] - player2_x
                dyp = enemy["y"] - player2_y
                dist = math.hypot(dxp, dyp)
                if dist < pull_radius and dist > 1:
                    pull_strength = base_pull_strength * (1 - dist / pull_radius)
                    player2_x += (dxp / dist) * pull_strength
                    player2_y += (dyp / dist) * pull_strength
        elif enemy["type"] == 22:
            if not enemy.get("laser_mode", False):
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                hit_left = enemy["x"] <= enemy_size/2
                hit_right = enemy["x"] >= WIDTH - enemy_size/2
                hit_top = enemy["y"] <= enemy_size/2
                hit_bottom = enemy["y"] >= HEIGHT - enemy_size/2
                if hit_left or hit_right or hit_top or hit_bottom:
                    enemy["health"] -= 1

                    if enemy["health"] <= 0:
                        enemy["laser_mode"] = True
                        enemy["laser_start"] = pygame.time.get_ticks()
                        enemy["damaged_p1"] = False
                        enemy["damaged_p2"] = False
                        if hit_left or hit_right:
                            enemy["laser_orientation"] = "horizontal"
                            enemy["laser_y"] = enemy["y"]
                        if hit_top or hit_bottom:
                            enemy["laser_orientation"] = "vertical"
                            enemy["laser_x"] = enemy["x"]
                    else:
                        if hit_left or hit_right:
                            enemy["dx"] *= -1
                        if hit_top or hit_bottom:
                            enemy["dy"] *= -1
            else:
                if current_time - enemy["laser_start"] >= 1000:
                    enemy["dead"] = True
                    continue
                laser_width = enemy_size
                if enemy["laser_orientation"] == "vertical":
                    lx = enemy["laser_x"]
                    if player_alive and not enemy["damaged_p1"]:
                        if abs(player_x - lx) < (player_size/2 + laser_width/2):
                            if current_time >= invincible_until:
                                player_lives -= 1
                                p1_regen_block_until = score + regen_delay
                                damage_flash_time = current_time
                                invincible_until = current_time + invincibility_duration
                                enemy["damaged_p1"] = True
                                if player_lives <= 0: player_alive = False

                    if players == 2 and player2_alive and not enemy["damaged_p2"]:
                        if player2_x + player_size > lx and player2_x < lx + laser_width:
                            if current_time >= player2_invincible_until:
                                player2_lives -= 1
                                p2_regen_block_until = score + regen_delay
                                player2_damage_flash_time = current_time
                                player2_invincible_until = current_time + invincibility_duration
                                enemy["damaged_p2"] = True
                                if player2_lives <= 0: player2_alive = False
                elif enemy["laser_orientation"] == "horizontal":
                    ly = enemy["laser_y"]
                    if player_alive and not enemy["damaged_p1"]:
                        if abs(player_y - ly) < (player_size/2 + laser_width/2):
                            if current_time >= invincible_until:
                                player_lives -= 1
                                p1_regen_block_until = score + regen_delay
                                damage_flash_time = current_time
                                invincible_until = current_time + invincibility_duration
                                enemy["damaged_p1"] = True
                                if player_lives <= 0: player_alive = False

                    if players == 2 and player2_alive and not enemy["damaged_p2"]:
                        if player2_y + player_size > ly and player2_y < ly + laser_width:
                            if current_time >= player2_invincible_until:
                                player2_lives -= 1
                                p2_regen_block_until = score + regen_delay
                                player2_damage_flash_time = current_time
                                player2_invincible_until = current_time + invincibility_duration
                                enemy["damaged_p2"] = True
                                if player2_lives <= 0: player2_alive = False
                continue
        elif enemy["type"] == 23:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True

            

            hardened_dps = 0.1 * (60 / FPS) * (harden_break / 10)

            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999

            if dist1 < 150+enemy_size/2+player_size/2:
                enemy["health"] -= hardened_dps
                if enemy["health"] < 1:
                    enemy["health"] = 1
            if dist2 < 150+enemy_size/2+player_size/2:
                enemy["health"] -= hardened_dps
                if enemy["health"] < 1:
                    enemy["health"] = 1
            if bounced:
                enemy["health"] -= 1
            if enemy["health"] < 1:
                enemy_died = True
        elif enemy["type"] == 24:
            enemy["accel"] += enemy.get("accel_rate", 0.02)
            vx = enemy.get("base_dx", enemy["dx"]) * enemy["accel"]
            vy = enemy.get("base_dy", enemy["dy"]) * enemy["accel"]

            speed_cap = enemy_speed * 1.5  # from your game settings
            speed = math.hypot(vx, vy)
            if speed > speed_cap:
                scale = speed_cap / speed
                vx *= scale
                vy *= scale

            enemy["dx"] = vx
            enemy["dy"] = vy
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["base_dx"] *= -1
                bounced = True
                if enemy["x"] <= enemy_size: enemy["x"] = enemy_size/2 + enemy["base_dx"]
                elif enemy["x"] >= WIDTH - enemy_size: enemy["x"] = WIDTH - enemy_size/2 + enemy["base_dx"]
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["base_dy"] *= -1
                bounced = True
                if enemy["y"] <= enemy_size: enemy["y"] = enemy_size/2 + enemy["base_dy"]
                elif enemy["y"] >= HEIGHT - enemy_size: enemy["y"] = HEIGHT - enemy_size/2 + enemy["base_dy"]

            if bounced:
                enemy["accel"] = 0.0
                enemy["dx"] = 0
                enemy["dy"] = 0
                enemy["bounces"] += 1
                enemy["health"] -= 1

            if enemy["bounces"] >= accelerator_hp or enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 25:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= cold_hp: enemy_died = True
        elif enemy["type"] == 26:
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                dx = tx - enemy["x"]; dy = ty - enemy["y"]
            else:
                dx, dy = 0, 0
            target_angle = math.atan2(dy, dx)
            enemy["angle"] = rotate_toward(enemy["angle"], target_angle, chase_turn/250)
            enemy["dx"] = math.cos(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["dy"] = math.sin(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["angle"] = math.pi - enemy["angle"]; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["angle"] = -enemy["angle"]; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if current_time - enemy["last_trail_time"] >= trail_interval_ms:
                trail_squares.append({
                    "x": int(enemy["x"]),
                    "y": int(enemy["y"]),
                    "spawn": current_time,
                    "health": 3,
                    "color": SULFUR
                })
                enemy["last_trail_time"] = current_time
            if enemy["bounces"] >= tracer_hp: enemy_died = True
        elif enemy["type"] == 27:
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            speed_multiplier = 2.5 if closest_dist < 200+enemy_size/2+player_size/2 else 2/3
            
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                dx = tx - enemy["x"]; dy = ty - enemy["y"]
            else:
                dx, dy = 0, 0
            target_angle = math.atan2(dy, dx)
            enemy["angle"] = rotate_toward(enemy["angle"], target_angle, chase_turn/250)
            enemy["dx"] = math.cos(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["dy"] = math.sin(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["x"] += enemy["dx"] * speed_multiplier; enemy["y"] += enemy["dy"] * speed_multiplier
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["angle"] = math.pi - enemy["angle"]; bounced = True
                if enemy["x"] <= 0: enemy["x"] = 0
                elif enemy["x"] >= WIDTH - enemy_size: enemy["x"] = WIDTH - enemy_size/2
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["angle"] = -enemy["angle"]; bounced = True
                if enemy["y"] <= 0: enemy["y"] = 0
                elif enemy["y"] >= HEIGHT - enemy_size: enemy["y"] = HEIGHT - enemy_size/2
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= savage_hp: enemy_died = True
        elif enemy["type"] == 28:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
                enemy["x"] = spawner_pos[0]+25
                enemy["y"] = spawner_pos[1]+25
            if enemy["bounces"] >= teleporter_hp: enemy_died = True
        elif enemy["type"] == 29:
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                dx = tx - enemy["x"]; dy = ty - enemy["y"]
            else:
                dx, dy = 0, 0
            target_angle = math.atan2(dy, dx)
            enemy["angle"] = rotate_toward(enemy["angle"], target_angle, chase_turn/250)
            enemy["dx"] = math.cos(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["dy"] = math.sin(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["angle"] = math.pi - enemy["angle"]; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["angle"] = -enemy["angle"]; bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
                enemy["x"] = spawner_pos[0]+25
                enemy["y"] = spawner_pos[1]+25
            if enemy["bounces"] >= haunter_hp: enemy_died = True
        elif enemy["type"] == 30:
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            speed_multiplier = 2.5 if closest_dist < 200+enemy_size/2+player_size/2 else 2/3
            enemy["x"] += enemy["dx"] * speed_multiplier
            enemy["y"] += enemy["dy"] * speed_multiplier
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["angle"] = math.pi - enemy["angle"]; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["angle"] = -enemy["angle"]; bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
                enemy["x"] = spawner_pos[0]+25
                enemy["y"] = spawner_pos[1]+25
            if enemy["bounces"] >= stream_hp or enemy["health"] <= 0:
                enemy_died = True














        if player_alive and centered_rect_collision(player_x, player_y, player_size,
                                            enemy["x"], enemy["y"], enemy_size):
            if enemy["type"] == 17:
                if not player_moving:  # Only damages if player is still
                    if current_time >= invincible_until:
                        player_lives -= 1
                        p1_regen_block_until = score + regen_delay
                        damage_flash_time = current_time
                        invincible_until = current_time + invincibility_duration
                        enemy["dead"] = True
                        if player_lives <= 0:
                            player_alive = False
                continue
            elif enemy["type"] == 16:
                if player_moving:  # Only damages if player is moving
                    if current_time >= invincible_until:
                        player_lives -= 1
                        p1_regen_block_until = score + regen_delay
                        damage_flash_time = current_time
                        invincible_until = current_time + invincibility_duration
                        enemy["dead"] = True
                        if player_lives <= 0:
                            player_alive = False
                continue
            elif enemy["type"] == 15:
                if not enemy.get("shrinking", False):
                    enemy["shrinking"] = True
                continue
            elif enemy["type"] == 21:                
                enemy["dead"] = True
                continue
            elif enemy["type"] == 22:
                if current_time >= invincible_until:
                    player_lives -= 1
                    p1_regen_block_until = score + regen_delay
                    damage_flash_time = current_time
                    invincible_until = current_time + invincibility_duration
                    if player_lives <= 0:
                        player_alive = False
                    if enemy.get("laser_mode", True): enemy["dead"] = True
                continue
            elif enemy["type"] == 25:
                slow_until = current_time + freeze_duration
                player_speed = player_speed_base / 2
                player_frozen = True
            elif enemy["type"] == 3:
                player_lives = 0
                player_alive = False
            else:
                if current_time >= invincible_until:
                    player_lives -= 1
                    p1_regen_block_until = score + regen_delay
                    damage_flash_time = current_time
                    invincible_until = current_time + invincibility_duration
                    enemy["dead"] = True
                    if player_lives <= 0:
                        player_alive = False
                continue
        if players == 2 and player2_alive and centered_rect_collision(player2_x, player2_y, player_size,
                                                                      enemy["x"], enemy["y"], enemy_size):
            if enemy["type"] == 17:
                if p2_dx == 0 and p2_dy == 0:  # not moving
                    if current_time >= player2_invincible_until:
                        player2_lives -= 1
                        p2_regen_block_until = score + regen_delay
                        player2_damage_flash_time = current_time
                        player2_invincible_until = current_time + invincibility_duration
                        enemy["dead"] = True
                        if player2_lives <= 0:
                            player2_alive = False
                continue
            elif enemy["type"] == 16:
                if (p2_dx != 0 or p2_dy != 0):
                    if current_time >= player2_invincible_until:
                        player2_lives -= 1
                        p2_regen_block_until = score + regen_delay
                        player2_damage_flash_time = current_time
                        player2_invincible_until = current_time + invincibility_duration
                        enemy["dead"] = True
                        if player2_lives <= 0:
                            player2_alive = False
                continue
            elif enemy["type"] == 15:
                if not enemy.get("shrinking", False):
                    enemy["shrinking"] = True
                continue
            elif enemy["type"] == 21:
                enemy["dead"] = True
                continue
            elif enemy["type"] == 22:
                if current_time >= player2_invincible_until:
                    player2_lives -= 1
                    p2_regen_block_until = score + regen_delay
                    player2_damage_flash_time = current_time
                    player2_invincible_until = current_time + invincibility_duration
                    if player2_lives <= 0:
                        player2_alive = False
                    if enemy.get("laser_mode", True): enemy["dead"] = True
                continue
            elif enemy["type"] == 25:
                player2_slow_until = current_time + freeze_duration
                player2_speed = player2_speed_base / 2
                player2_frozen = True
            elif enemy["type"] == 3:
                player2_lives = 0
                player2_alive = False
            else:
                if current_time >= player2_invincible_until:
                    player2_lives -= 1
                    p2_regen_block_until = score + regen_delay
                    player2_damage_flash_time = current_time
                    player2_invincible_until = current_time + invincibility_duration
                    enemy["dead"] = True
                    if player2_lives <= 0:
                        player2_alive = False
            continue
        if not player_alive and (players == 1 or not player2_alive):
            result = GAME_OVER(truescore, score_p1, score_p2)
            if result == "TITLE":
                TITLE_SCREEN()
                continue
            running = False
            break

        
        if enemy_died:
            if enemy in enemies:
                enemy["dead"] = True


    # --- Trail squares update ---
    new_trails = []
    for sq in trail_squares:
        if current_time - sq["spawn"] > trail_lifetime_ms:
            continue
        if player_alive and centered_rect_collision(player_x, player_y, player_size,
                                                    sq["x"], sq["y"], trail_size):
            if current_time >= invincible_until:
                player_lives -= 1
                p1_regen_block_until = score + regen_delay
                damage_flash_time = current_time
                invincible_until = current_time + invincibility_duration
                if player_lives <= 0:
                    player_alive = False
                    break
            sq["health"] -= 1
            if sq["health"] > 0:
                new_trails.append(sq)
            continue
        if players == 2 and player2_alive and centered_rect_collision(player2_x, player2_y, player_size,
                                                              sq["x"], sq["y"], trail_size):
            if current_time >= player2_invincible_until:
                player2_lives -= 1
                p2_regen_block_until = score + regen_delay
                player2_damage_flash_time = current_time
                player2_invincible_until = current_time + invincibility_duration
                if player2_lives <= 0:
                    player2_alive = False
                    break
            sq["health"] -= 1
            if sq["health"] > 0:
                new_trails.append(sq)
            continue
        new_trails.append(sq)
    trail_squares = new_trails

    # --- Projectiles movement ---
    new_projectiles = []
    for p in projectiles:
        # move (p stores center coordinates)
        p["x"] += p["dx"]
        p["y"] += p["dy"]

        # center-to-center collision test (more reliable with mixed coordinate conventions)
        player_cx = player_x + player_size / 2
        player_cy = player_y + player_size / 2
        proj_cx = p["x"]
        proj_cy = p["y"]

        # collision if distance < sum of radii
        if player_alive and centered_rect_collision(player_x, player_y, player_size,
                                                    p["x"] - projectile_size/2, p["y"] - projectile_size/2, projectile_size):
            if p.get("color") == CYAN:
                slow_until = current_time + freeze_duration  # 10 seconds
                player_speed = player_speed_base / 2
                player_frozen = True
            else:
                if current_time >= invincible_until:
                    player_lives -= 1
                    p1_regen_block_until = score + regen_delay
                    damage_flash_time = current_time
                    invincible_until = current_time + invincibility_duration
                    if player_lives <= 0:
                        player_alive = False
                        break
                continue
        if players == 2:
            player2_cx = player2_x + player_size / 2
            player2_cy = player2_y + player_size / 2
            if player2_alive and centered_rect_collision(player2_x, player2_y, player_size,
                                                    p["x"] - projectile_size/2, p["y"] - projectile_size/2, projectile_size):
                if p.get("color") == CYAN:
                    player2_slow_until = current_time + freeze_duration
                    player2_speed = player2_speed_base / 2
                    player2_frozen = True
                else:
                    if current_time >= player2_invincible_until:
                        player2_lives -= 1
                        p2_regen_block_until = score + regen_delay
                        player2_damage_flash_time = current_time
                        player2_invincible_until = current_time + invincibility_duration
                        if player2_lives <= 0:
                            player2_alive = False
                            break
                    continue

        # Keep projectile on screen (using center coords)
        if 0 - projectile_size < p["x"] < WIDTH + projectile_size and 0 - projectile_size < p["y"] < HEIGHT + projectile_size:
            new_projectiles.append(p)

    projectiles = new_projectiles

    enemies[:] = [e for e in enemies if not e.get("dead", False)]


    # --- Drawing ---
    screen.fill(BLACK)

    # draw spawner
    pygame.draw.rect(screen, BLACK, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE))
    pygame.draw.rect(screen, CRISP, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE), 3)


        # --- FULL SPAWNER INDICATOR --
    center = (spawner_pos[0] + SPAWNER_SIZE // 2,
        spawner_pos[1] + SPAWNER_SIZE // 2)

    if spawn_enabled:
        # Normal pulse + rotation once spawning starts
        indicator_ratio = min(1.0, (current_time - last_spawn_time) / spawn_delay)

        def lerp_color(c1, c2, t):
            return tuple(int(c1[i] + (c2[i] - c1[i]) * t) for i in range(3))

        pulse_color = lerp_color(CRISP, RED, indicator_ratio)

        # Glow
        glow_size = SPAWNER_SIZE * 4
        glow_surface = pygame.Surface((glow_size, glow_size), pygame.SRCALPHA).convert_alpha()
        alpha = int(40 + 180 * indicator_ratio)
        start_glow_radius = SPAWNER_SIZE * 2
        end_glow_radius = SPAWNER_SIZE // 2
        glow_radius = int(start_glow_radius * (1 - indicator_ratio) + end_glow_radius * indicator_ratio)
        r, g, b = pulse_color[:3]
        r = max(0, min(255, int(r)))
        g = max(0, min(255, int(g)))
        b = max(0, min(255, int(b)))
        safe_alpha = max(0, min(255, int(alpha)))
        pygame.draw.circle(glow_surface, (r, g, b, safe_alpha),
                           (glow_size // 2, glow_size // 2), glow_radius)
        screen.blit(glow_surface, (center[0] - glow_size // 2, center[1] - glow_size // 2))

        # Rotating arcs
        angle_progress = current_time / 500.0
        arc_radius = glow_radius + 5
        for i in range(3):
            start_angle = angle_progress + i * (2 * math.pi / 3)
            end_angle = start_angle + math.pi / 4
            r, g, b = pulse_color[:3]
            r = max(0, min(255, int(r)))
            g = max(0, min(255, int(g)))
            b = max(0, min(255, int(b)))
            safe_color = (r, g, b)
            pygame.draw.arc(screen, safe_color,
                            (center[0] - arc_radius, center[1] - arc_radius,
                             arc_radius * 2, arc_radius * 2),
                            start_angle, end_angle, 5)
    else:
        # Dormant look before player moves
        pulse_color = CRISP
        pygame.draw.rect(screen, pulse_color, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE), 3)
        pygame.draw.circle(screen, pulse_color, center, SPAWNER_SIZE // 2, 2)

    # --- spawner core ---
    pygame.draw.rect(screen, BLACK, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE))
    pygame.draw.rect(screen, CRISP, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE), 3)

    # draw trail squares
    for sq in trail_squares:
        color = sq.get("color", LAVA)
        pygame.draw.rect(screen, color, (sq["x"] - trail_size // 2, sq["y"] - trail_size // 2, trail_size, trail_size))

    # draw projectiles
    for p in projectiles:
        color = p.get("color", HOT_PINK)
        draw_x = int(p["x"] - projectile_size / 2)
        draw_y = int(p["y"] - projectile_size / 2)
        pygame.draw.rect(screen, color, (draw_x - projectile_size//2, draw_y - projectile_size//2, projectile_size, projectile_size))

    # draw enemies
    for enemy in enemies:
        if enemy["type"] == 1: color = GRAY
        elif enemy["type"] == 2: color = OLIVE
        elif enemy["type"] == 3: color = RED
        elif enemy["type"] == 4: color = TEAL
        elif enemy["type"] == 5: color = GREEN
        elif enemy["type"] == 6: color = VIOLET
        elif enemy["type"] == 7: color = LAVA
        elif enemy["type"] == 8:
            if player_frozen == True and enemy["target"] == 1: color = ICE
            elif player2_frozen == True and enemy["target"] == 2: color = ICE
            else: color = WHITE
        elif enemy["type"] == 9: color = LIME
        elif enemy["type"] == 10: color = HOT_PINK
        elif enemy["type"] == 11: color = BRONZE
        elif enemy["type"] == 12: color = INDIGO
        elif enemy["type"] == 13: color = SKY
        elif enemy["type"] == 14: color = BRICK
        elif enemy["type"] == 15: color = MAGENTA
        elif enemy["type"] == 16: color = BLUE
        elif enemy["type"] == 17: color = ORANGE
        elif enemy["type"] == 18: color = YELLOW
        elif enemy["type"] == 19: color = SILVER
        elif enemy["type"] == 20: color = CYAN
        elif enemy["type"] == 21: color = PINK
        elif enemy["type"] == 22: color = TURQUOISE
        elif enemy["type"] == 23: color = BROWN
        elif enemy["type"] == 24: color = TAN
        elif enemy["type"] == 25: color = ICE
        elif enemy["type"] == 26: color = SULFUR
        elif enemy["type"] == 27: color = MAROON
        elif enemy["type"] == 28: color = PURPLE
        elif enemy["type"] == 29: color = NAVY
        elif enemy["type"] == 30: color = AQUA


        
        if enemy["type"] == 22 and enemy.get("laser_mode", False):
            if enemy["laser_orientation"] == "vertical":
                pygame.draw.rect(screen, TURQUOISE, (enemy["laser_x"]-enemy_size/2, 0, enemy_size, HEIGHT))

            elif enemy["laser_orientation"] == "horizontal":
                pygame.draw.rect(screen, TURQUOISE, (0, enemy["laser_y"]-enemy_size/2, WIDTH, enemy_size))
            continue


        sz = int(enemy.get("size", enemy_size))
        pygame.draw.rect(
            screen,
            color,
            (enemy["x"] - sz // 2,
             enemy["y"] - sz // 2,
             sz,
             sz)
        )

        if players == 1: enemy_text_color = BLACK
        elif players == 2:
            if enemy["type"] in targetting_enemies:
                if enemy["target"] == 1: enemy_text_color = RED
                elif enemy["target"] == 2: enemy_text_color = BLUE
            else: enemy_text_color = BLACK
        
        if enemy["type"] == 8:
            if enemy["target"] == 1: text_surface = enemy_font.render(str(player_lives), True, enemy_text_color)
            elif enemy["target"] == 2: text_surface = enemy_font.render(str(player2_lives), True, enemy_text_color)
        else:
            text_surface = enemy_font.render(str(max(int(enemy.get("health", 0)), 0)), True, enemy_text_color)

        text_rect = text_surface.get_rect(center=(enemy["x"], enemy["y"]))
        screen.blit(text_surface, text_rect)

    
    # draw player (flash red if hit)
    if player_alive:
        if current_time - damage_flash_time < 100:
            pygame.draw.rect(screen, RED, (player_x - player_size//2, player_y - player_size//2, player_size, player_size))
        elif current_time - heal_flash_time < 150:
            pygame.draw.rect(screen, LIME, (player_x - player_size//2, player_y - player_size//2, player_size, player_size))
        elif player_frozen == True:
            pygame.draw.rect(screen, ICE, (player_x - player_size//2, player_y - player_size//2, player_size, player_size))
        else:
            pygame.draw.rect(screen, WHITE, (player_x - player_size//2, player_y - player_size//2, player_size, player_size))
        
    if players == 2 and player2_alive:
        if current_time - player2_damage_flash_time < 100:
            pygame.draw.rect(screen, RED, (player2_x - player_size//2, player2_y - player_size//2, player_size, player_size))
        elif current_time - player2_heal_flash_time < 150:
            pygame.draw.rect(screen, LIME, (player2_x - player_size//2, player2_y - player_size//2, player_size, player_size))
        elif player2_frozen == True:
            pygame.draw.rect(screen, ICE, (player2_x - player_size//2, player2_y - player_size//2, player_size, player_size))
        else:
            pygame.draw.rect(screen, WHITE, (player2_x - player_size//2, player2_y - player_size//2, player_size, player_size))

    if spawn_enabled:
        score += 0.1 * (60 / FPS) #SCORE SET
        if truescore < score:
            truescore = math.floor(score)
        if player_alive:
            score_p1 = truescore
        if player2_alive:
            score_p2 = truescore
    
    # draw player lives in center
    if players == 1: player_life_text = player_font.render(str(player_lives), True, BLACK)
    else: player_life_text = player_font.render(str(player_lives), True, RED)
    player_life_rect = player_life_text.get_rect(center=(player_x, player_y))
    screen.blit(player_life_text, player_life_rect)

    if players == 2:
        player2_life_text = player_font.render(str(player2_lives), True, BLUE)
        player2_life_rect = player2_life_text.get_rect(center=(player2_x, player2_y))
        screen.blit(player2_life_text, player2_life_rect)

    # draw HUD
    if players == 1:
        p1_text = font.render(f"Score: {score_p1}", True, WHITE)
        screen.blit(p1_text, (20, 20))
    elif players == 2:
        p1_text = font.render(f"P1 Score: {score_p1}", True, RED)
        screen.blit(p1_text, (20, 20))
        p2_text = font.render(f"P2 Score: {score_p2}", True, BLUE)
        screen.blit(p2_text, (20, 60))

    if player_alive and score >= p1_regen_block_until and player_lives < player_health_setting and regen_delay != 6767:
        player_lives += 1
        heal_flash_time = current_time
        p1_regen_block_until = score + regen_delay

    if players == 2 and player2_alive and score >= p2_regen_block_until and player2_lives < player2_health_setting and regen_delay != 6767:
        player2_lives += 1
        player2_heal_flash_time = current_time
        p2_regen_block_until = score + regen_delay

    if not player_alive and (players == 1 or not player2_alive):
        result = GAME_OVER(truescore, score_p1, score_p2)
        if result == "TITLE":
            TITLE_SCREEN()
            continue
        running = False
        break
    
    pygame.display.flip()

pygame.quit()
