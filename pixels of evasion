import pygame
import random
import math

pygame.init()
screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
WIDTH, HEIGHT = screen.get_size()
pygame.display.set_caption("Bullet Hell")

# --- GAME OVER SCREEN ---
def GAME_OVER(final_score, p1, p2): 
    screen.fill(BLACK)
    over_text = big_font.render("GAME OVER", True, RED)
    if players == 1: score_text = font.render(f"Final Score: {final_score}", True, WHITE)
    elif p1 > p2: score_text = font.render(f"Player 1 wins by {p1}-{p2}.", True, WHITE)
    elif p1 < p2: score_text = font.render(f"Player 2 wins by {p2}-{p1}.", True, WHITE)
    elif p1 == p2: score_text = font.render(f"Both players tied with a score of {final_score}", True, WHITE)
    instr_text = font.render("Press space to return", True, GRAY)

    screen.blit(over_text, over_text.get_rect(center=(WIDTH//2, HEIGHT//2 - 50)))
    screen.blit(score_text, score_text.get_rect(center=(WIDTH//2, HEIGHT//2)))
    screen.blit(instr_text, instr_text.get_rect(center=(WIDTH//2, HEIGHT//2 + 50)))

    pygame.display.flip()

    waiting = True
    while waiting:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                waiting = False
            if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                print(f"Final score: {final_score}")
                if players == 2:
                    print(f"Player 1 score: {p1}")
                    print(f"Player 2 score: {p2}")
                TITLE_SCREEN()
                return
        clock.tick(15)

# --- Colors ---
WHITE = (255, 255, 255)
SILVER = (175, 175, 175)
GRAY = (100, 100, 100)
BLACK = (0, 0, 0)
BROWN = (108, 65, 0)
CRISP = (50, 0, 0)
MAROON = (120, 0, 0)
BRONZE = (140, 45, 0)
BRICK = (140, 65, 65)
RED = (255, 0, 0)
LAVA = (200, 60, 0)
TAN = (155, 125, 95)
ORANGE = (255, 120, 0)
GOLD = (255, 195, 0)
YELLOW = (255, 255, 0)
SULFUR = (190, 190, 0)
OLIVE = (100, 100, 0)
LIME = (0, 255, 0)
GREEN = (0, 125, 0)
FOREST = (0, 60, 0)
TEAL = (0, 140, 140)
TURQUOISE = (0, 255, 180)
ICE = (175, 255, 255)
CYAN = (0, 255, 255)
SKY = (105, 160, 225)
BLUE = (0, 0, 255)
NAVY = (0, 0, 100)
INDIGO = (110, 0, 200)
MAUVE = (145, 95, 140)
PURPLE = (162, 0, 255)
MAGENTA = (255, 0, 255)
PINK = (255, 140, 255)
HOT_PINK = (255, 0, 106)

# --- Spawner Size ---
SPAWNER_SIZE = 50

# --- Player ---
players = 1
player_size = 50
player_speed = 8
player_lives = 3 # ORIGINAL VALUE 3
player2_lives = 3 # ORIGINAL VALUE 3
player_alive = True
player2_alive = True
player_frozen = False
player2_frozen = False
slow_until = 0
player_speed_base = player_speed
player2_slow_until = 0
player2_speed_base = player_speed
player_speed = player_speed_base
player2_speed = player2_speed_base

# --- Enemy ---
enemy_size = 50 # ORIGINAL VALUE 50
enemies = []

# --- Spawner ---
spawner_pos = (WIDTH // 2 - SPAWNER_SIZE // 2, HEIGHT // 2 - SPAWNER_SIZE // 2)
initial_spawn_delay = 2000 # ORIGINAL VALUE 2000
last_spawn_time = pygame.time.get_ticks()
enemy_speed = 5
min_spawn_delay = 500  # ORIGINAL VALUE 500
spawn_rate = 18

player_x = player_size
player_y = spawner_pos[1] + SPAWNER_SIZE // 2

player2_x = WIDTH - player_size
player2_y = spawner_pos[1] + SPAWNER_SIZE // 2

# --- Enemy Health ---
basic_hp = 5 # 1
homing_hp = 2 # 2
fatal_hp = 3 # 3
flow_hp = 3 # 4
sticky_hp = 7 # 5
gloomy_hp = 9 # 6
trail_hp = 3 # 7
impostor_hp = 5 # 8
splitter_hp = 3 # 9
bomb_hp = 8 # 10
shooter_hp = 4 # 11
sniper_hp = 1 # 12
speedy_hp = 5 # 13
shotgun_hp = 4 # 14
voodoo_hp = 5 # 15
blind_hp = 6 # 16
motion_hp = 7 # 17
charger_hp = 3 # 18
rapidshooter_hp = 1 # 19
frostbite_hp = 4 # 20
addictive_hp = 4 # 21
laser_hp = 3 # 22
hardened_hp = 40 # 23
accelerator_hp = 5 # 24
cold_hp = 9 # 25

# --- Scoring System & Text Size ---
score = 0
split_score = 0
score_p1 = score
score_p2 = score
font = pygame.font.SysFont(None, 40)
big_font = pygame.font.SysFont(None, 120)
enemy_font = pygame.font.SysFont(None, int(0.96 * enemy_size))
player_font = pygame.font.SysFont(None, int(0.96 * player_size))
regen_delay = 10
p1_regen_block_until = 0
p2_regen_block_until = 0


# --- Clock ---
clock = pygame.time.Clock()
FPS = 60

# --- Enemy unlocking ---
available_enemy_types = []
locked_enemy_types = []

# --- Trail for orange enemy ---
trail_squares = []
trail_lifetime_ms = 3000 # this is the length of the trail
trail_interval_ms = 450 # this is the distance between trail particles
trail_size = 10


# --- Projectiles ---
projectiles = []
bomb_projectile_speed = 2.5
shooter_projectile_speed = 5
sniper_projectile_speed = 10
shotgun_projectile_speed = 5
rapidshooter_projectile_speed = 5
frostbite_projectile_speed = 5
projectile_size = 10
shooter_delay = 3000
sniper_delay = 5500
shotgun_delay = 7500
rapidshooter_delay = 200


# --- Acceleration ---
accel = 0.0
accel_rate = 0.02

# --- Player damage flash ---
damage_flash_time = 0
player2_damage_flash_time = 0
invincible_until = 0
player2_invincible_until = 0
invincibility_duration = 1000
player2_last_regen = 0
player2_regen_cooldown = 3000

# +++ Regen indicator +++

heal_indicators = []
heal_duration = 500

def centered_rect_collision(x1, y1, s1, x2, y2, s2):
    half1 = s1 / 2
    half2 = s2 / 2
    return (
        abs(x1 - x2) < half1 + half2 and
        abs(y1 - y2) < half1 + half2
    )

def rotate_toward(current_angle, target_angle, turn_speed):
    difference = (target_angle - current_angle + math.pi) % (2 * math.pi) - math.pi
    if abs(difference) < turn_speed:
        return target_angle
    return current_angle + turn_speed * (1 if difference > 0 else -1)

def check_collision(px, py, pw, ph, ex, ey, ew, eh):
    return px < ex + ew and px + pw > ex and py < ey + eh and py + ph > ey

def distance(x1, y1, x2, y2):
    return math.hypot(x2 - x1, y2 - y1)

def get_target_position(enemy):
    if enemy["target"] == 1:
        return player_x, player_y
    elif enemy["target"] == 2:
        return player2_x, player2_y
    else:
        return None

# --- Default Settings ---
player_size_setting = 50
enemy_size_setting = 50
projectile_size_setting = 10
min_spawn_delay_setting = 500
max_spawn_delay_setting = 2000
spawn_delay_change_setting = 18
player_speed_setting = 8
enemy_speed_setting = 5
projectile_speed_setting = 5
regen_delay_setting = 10
player_health_setting = 3
player2_health_setting = 3
enemy_locks = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

basic_hp_setting = 5
homing_hp_setting = 2
fatal_hp_setting = 3
flow_hp_setting = 3
sticky_hp_setting = 7
gloomy_hp_setting = 9
trail_hp_setting = 3
impostor_hp_setting = 5
splitter_hp_setting = 3
bomb_hp_setting = 8
shooter_hp_setting = 4
sniper_hp_setting = 1
speedy_hp_setting = 5
shotgun_hp_setting = 4
voodoo_hp_setting = 5
blind_hp_setting = 6
motion_hp_setting = 7
charger_hp_setting = 3
rapidshooter_hp_setting = 1
frostbite_hp_setting = 4
addictive_hp_setting = 4
laser_hp_setting = 3
hardened_hp_setting = 40
accelerator_hp_setting = 5
cold_hp_setting = 9


def enemy_lock_setup(enemy):
    global available_enemy_types
    global locked_enemy_types
    global enemy_locks
    if enemy_locks[enemy] == 0: available_enemy_types.append(enemy + 1)
    if enemy_locks[enemy] == 1: locked_enemy_types.append(enemy + 1)

def SETTINGS():
    global player_size_setting
    global enemy_size_setting
    global projectile_size_setting
    global min_spawn_delay_setting
    global max_spawn_delay_setting
    global spawn_delay_change_setting
    global player_speed_setting
    global enemy_speed_setting
    global projectile_speed_setting
    global regen_delay_setting
    global player_health_setting
    global player2_health_setting
    global enemy_locks
    global basic_hp_setting
    global homing_hp_setting
    global fatal_hp_setting
    global flow_hp_setting
    global sticky_hp_setting
    global gloomy_hp_setting
    global trail_hp_setting
    global impostor_hp_setting
    global splitter_hp_setting
    global bomb_hp_setting
    global shooter_hp_setting
    global sniper_hp_setting
    global speedy_hp_setting
    global shotgun_hp_setting
    global voodoo_hp_setting
    global blind_hp_setting
    global motion_hp_setting
    global charger_hp_setting
    global rapidshooter_hp_setting
    global frostbite_hp_setting
    global addictive_hp_setting
    global laser_hp_setting
    global hardened_hp_setting
    global accelerator_hp_setting
    global cold_hp_setting
    
    running = True
    button_offset = 10
    scroll_y = 0
    scroll_speed = 25
    max_scroll = 1500
    enemy_locking_labels = ["Starter", "Locked", "Banned"]
    scrollbar_width = 20
    scrollbar_margin = 50
    scrollbar_track = pygame.Rect(
        WIDTH - scrollbar_width - scrollbar_margin,
        50,
        scrollbar_width,
        HEIGHT - 100
    )

    dragging_scrollbar = False

    player_size_plus_button = pygame.Rect(WIDTH//2 + 120, HEIGHT//2 - 20, 60, 60)
    player_size_minus_button = pygame.Rect(WIDTH//2 - 180, HEIGHT//2 - 20, 60, 60)
    
    while running:
        screen.fill(BLACK)
        text = big_font.render("Settings", True, WHITE)
        screen.blit(text, (50, 50 + scroll_y))
        info = font.render("Press Space to return", True, GRAY)
        screen.blit(info, (50, 150 + scroll_y))
        mouse_pos = pygame.mouse.get_pos()
        mouse_click = pygame.mouse.get_pressed()[0]
        plus_txt = font.render("+", True, BLACK)
        minus_txt = font.render("-", True, BLACK)


        content_height = max_scroll + HEIGHT
        view_height = HEIGHT

        handle_height = max(
            40,
            int(scrollbar_track.height * (view_height / content_height))
        )

        scroll_ratio = -scroll_y / max_scroll if max_scroll > 0 else 0

        handle_y = scrollbar_track.y + int(
            scroll_ratio * (scrollbar_track.height - handle_height)
        )

        scrollbar_handle = pygame.Rect(
            scrollbar_track.x,
            handle_y,
            scrollbar_width,
            handle_height
        )


        max_spawn_delay_label = font.render("Starting Spawn Delay: " + str(max_spawn_delay_setting), True, WHITE)
        screen.blit(max_spawn_delay_label, (50, 240 + scroll_y))
        max_spawn_delay_minus_button = pygame.Rect(500, 240 - button_offset + scroll_y, 50, 50)
        max_spawn_delay_plus_button = pygame.Rect(560, 240 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, max_spawn_delay_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=max_spawn_delay_plus_button.center))
        pygame.draw.rect(screen, RED, max_spawn_delay_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=max_spawn_delay_minus_button.center))
        if max_spawn_delay_plus_button.collidepoint(mouse_pos) and mouse_click:
            max_spawn_delay_setting += 100
            if max_spawn_delay_setting > 5000:
                max_spawn_delay_setting = 5000
            pygame.time.delay(50)
        if max_spawn_delay_minus_button.collidepoint(mouse_pos) and mouse_click:
            max_spawn_delay_setting -= 100
            if max_spawn_delay_setting < 100 or max_spawn_delay_setting < min_spawn_delay_setting:
                max_spawn_delay_setting += 100
            pygame.time.delay(50)

            

        min_spawn_delay_label = font.render("Ending Spawn Delay: " + str(min_spawn_delay_setting), True, WHITE)
        screen.blit(min_spawn_delay_label, (50, 300 + scroll_y))
        min_spawn_delay_minus_button = pygame.Rect(500, 300 - button_offset + scroll_y, 50, 50)
        min_spawn_delay_plus_button = pygame.Rect(560, 300 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, min_spawn_delay_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=min_spawn_delay_plus_button.center))
        pygame.draw.rect(screen, RED, min_spawn_delay_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=min_spawn_delay_minus_button.center))
        if min_spawn_delay_plus_button.collidepoint(mouse_pos) and mouse_click:
            min_spawn_delay_setting += 100
            if min_spawn_delay_setting > 5000 or min_spawn_delay_setting > max_spawn_delay_setting:
                min_spawn_delay_setting -= 100
            pygame.time.delay(50)
        if min_spawn_delay_minus_button.collidepoint(mouse_pos) and mouse_click:
            min_spawn_delay_setting -= 100
            if min_spawn_delay_setting < 100:
                min_spawn_delay_setting = 100
            pygame.time.delay(50)


        


        spawn_delay_change_label = font.render("Spawn Delay Change: " + str(spawn_delay_change_setting), True, WHITE)
        screen.blit(spawn_delay_change_label, (50, 360 + scroll_y))
        spawn_delay_change_minus_button = pygame.Rect(500, 360 - button_offset + scroll_y, 50, 50)
        spawn_delay_change_plus_button = pygame.Rect(560, 360 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, spawn_delay_change_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=spawn_delay_change_plus_button.center))
        pygame.draw.rect(screen, RED, spawn_delay_change_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=spawn_delay_change_minus_button.center))
        if spawn_delay_change_plus_button.collidepoint(mouse_pos) and mouse_click:
            spawn_delay_change_setting += 2
            if spawn_delay_change_setting > 100:
                spawn_delay_change_setting = 100
            pygame.time.delay(50)
        if spawn_delay_change_minus_button.collidepoint(mouse_pos) and mouse_click:
            spawn_delay_change_setting -= 2
            if spawn_delay_change_setting < 2:
                spawn_delay_change_setting = 2
            pygame.time.delay(50)


        player_health_label = font.render("Player 1 Health: " + str(player_health_setting), True, WHITE)
        screen.blit(player_health_label, (50, 420 + scroll_y))
        player_health_minus_button = pygame.Rect(500, 420 - button_offset + scroll_y, 50, 50)
        player_health_plus_button = pygame.Rect(560, 420 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, player_health_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=player_health_plus_button.center))
        pygame.draw.rect(screen, RED, player_health_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=player_health_minus_button.center))
        if player_health_plus_button.collidepoint(mouse_pos) and mouse_click:
            player_health_setting += 1
            if player_health_setting > 99:
                player_health_setting = 99
            pygame.time.delay(50)
        if player_health_minus_button.collidepoint(mouse_pos) and mouse_click:
            player_health_setting -= 1
            if player_health_setting < 1:
                player_health_setting = 1
            pygame.time.delay(50)


        player2_health_label = font.render("Player 2 Health: " + str(player2_health_setting), True, WHITE)
        screen.blit(player2_health_label, (50, 480 + scroll_y))
        player2_health_minus_button = pygame.Rect(500, 480 - button_offset + scroll_y, 50, 50)
        player2_health_plus_button = pygame.Rect(560, 480 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, player2_health_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=player2_health_plus_button.center))
        pygame.draw.rect(screen, RED, player2_health_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=player2_health_minus_button.center))
        if player2_health_plus_button.collidepoint(mouse_pos) and mouse_click:
            player2_health_setting += 2
            if player2_health_setting > 99:
                player2_health_setting = 99
            pygame.time.delay(50)
        if player2_health_minus_button.collidepoint(mouse_pos) and mouse_click:
            player2_health_setting -= 1
            if player2_health_setting < 1:
                player2_health_setting = 1
            pygame.time.delay(50)


        if regen_delay_setting == 6767: regen_delay_label = font.render("No Regen", True, WHITE)
        else: regen_delay_label = font.render("Regen Delay: " + str(regen_delay_setting), True, WHITE)
        screen.blit(regen_delay_label, (50, 540 + scroll_y))
        regen_delay_minus_button = pygame.Rect(500, 540 - button_offset + scroll_y, 50, 50)
        regen_delay_plus_button = pygame.Rect(560, 540 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, regen_delay_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=regen_delay_plus_button.center))
        pygame.draw.rect(screen, RED, regen_delay_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=regen_delay_minus_button.center))
        if regen_delay_plus_button.collidepoint(mouse_pos) and mouse_click:
            regen_delay_setting += 1
            if regen_delay_setting > 80:
                regen_delay_setting = 6767
            pygame.time.delay(50)
        if regen_delay_minus_button.collidepoint(mouse_pos) and mouse_click:
            if regen_delay_setting == 6767:
                regen_delay_setting = 80
            else: regen_delay_setting -= 1
            if regen_delay_setting < 1:
                regen_delay_setting = 1
            pygame.time.delay(50)


        player_speed_label = font.render("Player Speed: " + str(player_speed_setting), True, WHITE)
        screen.blit(player_speed_label, (50, 600 + scroll_y))
        player_speed_minus_button = pygame.Rect(500, 600 - button_offset + scroll_y, 50, 50)
        player_speed_plus_button = pygame.Rect(560, 600 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, player_speed_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=player_speed_plus_button.center))
        pygame.draw.rect(screen, RED, player_speed_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=player_speed_minus_button.center))
        if player_speed_plus_button.collidepoint(mouse_pos) and mouse_click:
            player_speed_setting += 1
            if player_speed_setting > 20:
                player_speed_setting = 20
            pygame.time.delay(50)
        if player_speed_minus_button.collidepoint(mouse_pos) and mouse_click:
            player_speed_setting -= 1
            if player_speed_setting < 1:
                player_speed_setting = 1
            pygame.time.delay(50)


        player_size_label = font.render("Player Size: " + str(player_size_setting), True, WHITE)
        screen.blit(player_size_label, (50, 660 + scroll_y))
        player_size_minus_button = pygame.Rect(500, 660 - button_offset + scroll_y, 50, 50)
        player_size_plus_button = pygame.Rect(560, 660 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, player_size_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=player_size_plus_button.center))
        pygame.draw.rect(screen, RED, player_size_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=player_size_minus_button.center))
        if player_size_plus_button.collidepoint(mouse_pos) and mouse_click:
            player_size_setting += 5
            if player_size_setting > 250:
                player_size_setting = 250
            pygame.time.delay(50)
        if player_size_minus_button.collidepoint(mouse_pos) and mouse_click:
            player_size_setting -= 5
            if player_size_setting < 10:
                player_size_setting = 10
            pygame.time.delay(50)



        enemy_speed_label = font.render("Enemy Speed: " + str(enemy_speed_setting), True, WHITE)
        screen.blit(enemy_speed_label, (50, 720 + scroll_y))
        enemy_speed_minus_button = pygame.Rect(500, 720 - button_offset + scroll_y, 50, 50)
        enemy_speed_plus_button = pygame.Rect(560, 720 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, enemy_speed_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=enemy_speed_plus_button.center))
        pygame.draw.rect(screen, RED, enemy_speed_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=enemy_speed_minus_button.center))
        if enemy_speed_plus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_speed_setting += 1
            if enemy_speed_setting > 20:
                enemy_speed_setting = 20
            pygame.time.delay(50)
        if enemy_speed_minus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_speed_setting -= 1
            if enemy_speed_setting < 1:
                enemy_speed_setting = 1
            pygame.time.delay(50)




        enemy_size_label = font.render("Enemy Size: " + str(enemy_size_setting), True, WHITE)
        screen.blit(enemy_size_label, (50, 780 + scroll_y))
        enemy_size_minus_button = pygame.Rect(500, 780 - button_offset + scroll_y, 50, 50)
        enemy_size_plus_button = pygame.Rect(560, 780 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, enemy_size_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=enemy_size_plus_button.center))
        pygame.draw.rect(screen, RED, enemy_size_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=enemy_size_minus_button.center))
        if enemy_size_plus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_size_setting += 5
            if enemy_size_setting > 250:
                enemy_size_setting = 250
            pygame.time.delay(50)
        if enemy_size_minus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_size_setting -= 5
            if enemy_size_setting < 10:
                enemy_size_setting = 10
            pygame.time.delay(50)



        projectile_speed_label = font.render("Projectile Speed: " + str(projectile_speed_setting), True, WHITE)
        screen.blit(projectile_speed_label, (50, 840 + scroll_y))
        projectile_speed_minus_button = pygame.Rect(500, 840 - button_offset + scroll_y, 50, 50)
        projectile_speed_plus_button = pygame.Rect(560, 840 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, projectile_speed_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=projectile_speed_plus_button.center))
        pygame.draw.rect(screen, RED, projectile_speed_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=projectile_speed_minus_button.center))
        if projectile_speed_plus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_speed_setting += 1
            if projectile_speed_setting > 25:
                projectile_speed_setting = 25
            pygame.time.delay(50)
        if projectile_speed_minus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_speed_setting -= 1
            if projectile_speed_setting < 1:
                projectile_speed_setting = 1
            pygame.time.delay(50)

        

        projectile_size_label = font.render("Projectile Size: " + str(projectile_size_setting), True, WHITE)
        screen.blit(projectile_size_label, (50, 900 + scroll_y))
        projectile_size_minus_button = pygame.Rect(500, 900 - button_offset + scroll_y, 50, 50)
        projectile_size_plus_button = pygame.Rect(560, 900 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, projectile_size_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=projectile_size_plus_button.center))
        pygame.draw.rect(screen, RED, projectile_size_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=projectile_size_minus_button.center))
        if projectile_size_plus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_size_setting += 2
            if projectile_size_setting > 50:
                projectile_size_setting = 50
            pygame.time.delay(50)
        if projectile_size_minus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_size_setting -= 2
            if projectile_size_setting < 2:
                projectile_size_setting = 2
            pygame.time.delay(50)



        all_starter_text = font.render("All Starter", True, WHITE)
        all_starter_button = pygame.Rect(50, 960 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, GREEN, all_starter_button, border_radius=10)
        screen.blit(all_starter_text, all_starter_text.get_rect(center=all_starter_button.center))
        if all_starter_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = 0
            pygame.time.delay(200)
        all_locked_text = font.render("All Locked", True, WHITE)
        all_locked_button = pygame.Rect(300, 960 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, SULFUR, all_locked_button, border_radius=10)
        screen.blit(all_locked_text, all_locked_text.get_rect(center=all_locked_button.center))
        if all_locked_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = 1
            pygame.time.delay(200)
        all_banned_text = font.render("All Banned", True, WHITE)
        all_banned_button = pygame.Rect(550, 960 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, RED, all_banned_button, border_radius=10)
        screen.blit(all_banned_text, all_banned_text.get_rect(center=all_banned_button.center))
        if all_banned_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = 2
            pygame.time.delay(200)
        all_random_text = font.render("All Random", True, WHITE)
        all_random_button = pygame.Rect(800, 960 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, PURPLE, all_random_button, border_radius=10)
        screen.blit(all_random_text, all_random_text.get_rect(center=all_random_button.center))
        if all_random_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = random.randrange(3)
            pygame.time.delay(200)



        basic_hp_label = font.render("Basic Enemy - HP: " + str(basic_hp_setting), True, GRAY)
        screen.blit(basic_hp_label, (50, 1020 + scroll_y))
        basic_hp_minus_button = pygame.Rect(500, 1020 - button_offset + scroll_y, 50, 50)
        basic_hp_plus_button = pygame.Rect(560, 1020 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, basic_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=basic_hp_plus_button.center))
        pygame.draw.rect(screen, RED, basic_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=basic_hp_minus_button.center))
        if basic_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            basic_hp_setting += 1
            if basic_hp_setting > 99:
                basic_hp_setting = 99
            pygame.time.delay(50)
        if basic_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            basic_hp_setting -= 1
            if basic_hp_setting < 1:
                basic_hp_setting = 1
            pygame.time.delay(50)
        basic_locks_text = font.render(enemy_locking_labels[enemy_locks[0]], True, WHITE)
        basic_locks_button = pygame.Rect(650, 1020 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, GRAY, basic_locks_button, border_radius=10)
        screen.blit(basic_locks_text, basic_locks_text.get_rect(center=basic_locks_button.center))
        if basic_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[0] > 1: enemy_locks[0] = 0
            else: enemy_locks[0] = enemy_locks[0] + 1
            pygame.time.delay(200)



        homing_hp_label = font.render("Homing Enemy - HP: " + str(homing_hp_setting), True, MAROON)
        screen.blit(homing_hp_label, (50, 1080 + scroll_y))
        homing_hp_minus_button = pygame.Rect(500, 1080 - button_offset + scroll_y, 50, 50)
        homing_hp_plus_button = pygame.Rect(560, 1080 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, homing_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=homing_hp_plus_button.center))
        pygame.draw.rect(screen, RED, homing_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=homing_hp_minus_button.center))
        if homing_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            homing_hp_setting += 1
            if homing_hp_setting > 99:
                homing_hp_setting = 99
            pygame.time.delay(50)
        if homing_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            homing_hp_setting -= 1
            if homing_hp_setting < 1:
                homing_hp_setting = 1
            pygame.time.delay(50)
        homing_locks_text = font.render(enemy_locking_labels[enemy_locks[1]], True, WHITE)
        homing_locks_button = pygame.Rect(650, 1080 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, MAROON, homing_locks_button, border_radius=10)
        screen.blit(homing_locks_text, homing_locks_text.get_rect(center=homing_locks_button.center))
        if homing_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[1] > 1: enemy_locks[1] = 0
            else: enemy_locks[1] = enemy_locks[1] + 1
            pygame.time.delay(200)


        fatal_hp_label = font.render("Fatal Enemy - HP: " + str(fatal_hp_setting), True, RED)
        screen.blit(fatal_hp_label, (50, 1140 + scroll_y))
        fatal_hp_minus_button = pygame.Rect(500, 1140 - button_offset + scroll_y, 50, 50)
        fatal_hp_plus_button = pygame.Rect(560, 1140 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, fatal_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=fatal_hp_plus_button.center))
        pygame.draw.rect(screen, RED, fatal_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=fatal_hp_minus_button.center))
        if fatal_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            fatal_hp_setting += 1
            if fatal_hp_setting > 99:
                fatal_hp_setting = 99
            pygame.time.delay(50)
        if fatal_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            fatal_hp_setting -= 1
            if fatal_hp_setting < 1:
                fatal_hp_setting = 1
            pygame.time.delay(50)
        fatal_locks_text = font.render(enemy_locking_labels[enemy_locks[2]], True, WHITE)
        fatal_locks_button = pygame.Rect(650, 1140 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, RED, fatal_locks_button, border_radius=10)
        screen.blit(fatal_locks_text, fatal_locks_text.get_rect(center=fatal_locks_button.center))
        if fatal_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[2] > 1: enemy_locks[2] = 0
            else: enemy_locks[2] = enemy_locks[2] + 1
            pygame.time.delay(200)



        flow_hp_label = font.render("Flow Enemy - HP: " + str(flow_hp_setting), True, TEAL)
        screen.blit(flow_hp_label, (50, 1200 + scroll_y))
        flow_hp_minus_button = pygame.Rect(500, 1200 - button_offset + scroll_y, 50, 50)
        flow_hp_plus_button = pygame.Rect(560, 1200 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, flow_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=flow_hp_plus_button.center))
        pygame.draw.rect(screen, RED, flow_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=flow_hp_minus_button.center))
        if flow_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            flow_hp_setting += 1
            if flow_hp_setting > 99:
                flow_hp_setting = 99
            pygame.time.delay(50)
        if flow_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            flow_hp_setting -= 1
            if flow_hp_setting < 1:
                flow_hp_setting = 1
            pygame.time.delay(50)
        flow_locks_text = font.render(enemy_locking_labels[enemy_locks[3]], True, WHITE)
        flow_locks_button = pygame.Rect(650, 1200 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, TEAL, flow_locks_button, border_radius=10)
        screen.blit(flow_locks_text, flow_locks_text.get_rect(center=flow_locks_button.center))
        if flow_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[3] > 1: enemy_locks[3] = 0
            else: enemy_locks[3] = enemy_locks[3] + 1
            pygame.time.delay(200)



        sticky_hp_label = font.render("Sticky Enemy - HP: " + str(sticky_hp_setting), True, GREEN)
        screen.blit(sticky_hp_label, (50, 1260 + scroll_y))
        sticky_hp_minus_button = pygame.Rect(500, 1260 - button_offset + scroll_y, 50, 50)
        sticky_hp_plus_button = pygame.Rect(560, 1260 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, sticky_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=sticky_hp_plus_button.center))
        pygame.draw.rect(screen, RED, sticky_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=sticky_hp_minus_button.center))
        if sticky_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            sticky_hp_setting += 1
            if sticky_hp_setting > 99:
                sticky_hp_setting = 99
            pygame.time.delay(50)
        if sticky_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            sticky_hp_setting -= 1
            if sticky_hp_setting < 1:
                sticky_hp_setting = 1
            pygame.time.delay(50)
        sticky_locks_text = font.render(enemy_locking_labels[enemy_locks[4]], True, WHITE)
        sticky_locks_button = pygame.Rect(650, 1260 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, GREEN, sticky_locks_button, border_radius=10)
        screen.blit(sticky_locks_text, sticky_locks_text.get_rect(center=sticky_locks_button.center))
        if sticky_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[4] > 1: enemy_locks[4] = 0
            else: enemy_locks[4] = enemy_locks[4] + 1
            pygame.time.delay(200)



        gloomy_hp_label = font.render("Gloomy Enemy - HP: " + str(gloomy_hp_setting), True, PURPLE)
        screen.blit(gloomy_hp_label, (50, 1320 + scroll_y))
        gloomy_hp_minus_button = pygame.Rect(500, 1320 - button_offset + scroll_y, 50, 50)
        gloomy_hp_plus_button = pygame.Rect(560, 1320 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, gloomy_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=gloomy_hp_plus_button.center))
        pygame.draw.rect(screen, RED, gloomy_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=gloomy_hp_minus_button.center))
        if gloomy_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            gloomy_hp_setting += 1
            if gloomy_hp_setting > 99:
                gloomy_hp_setting = 99
            pygame.time.delay(50)
        if gloomy_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            gloomy_hp_setting -= 1
            if gloomy_hp_setting < 1:
                gloomy_hp_setting = 1
            pygame.time.delay(50)
        gloomy_locks_text = font.render(enemy_locking_labels[enemy_locks[5]], True, WHITE)
        gloomy_locks_button = pygame.Rect(650, 1320 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, PURPLE, gloomy_locks_button, border_radius=10)
        screen.blit(gloomy_locks_text, gloomy_locks_text.get_rect(center=gloomy_locks_button.center))
        if gloomy_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[5] > 1: enemy_locks[5] = 0
            else: enemy_locks[5] = enemy_locks[5] + 1
            pygame.time.delay(200)



        trail_hp_label = font.render("Trail Enemy - HP: " + str(trail_hp_setting), True, LAVA)
        screen.blit(trail_hp_label, (50, 1380 + scroll_y))
        trail_hp_minus_button = pygame.Rect(500, 1380 - button_offset + scroll_y, 50, 50)
        trail_hp_plus_button = pygame.Rect(560, 1380 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, trail_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=trail_hp_plus_button.center))
        pygame.draw.rect(screen, RED, trail_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=trail_hp_minus_button.center))
        if trail_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            trail_hp_setting += 1
            if trail_hp_setting > 99:
                trail_hp_setting = 99
            pygame.time.delay(50)
        if trail_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            trail_hp_setting -= 1
            if trail_hp_setting < 1:
                trail_hp_setting = 1
            pygame.time.delay(50)
        trail_locks_text = font.render(enemy_locking_labels[enemy_locks[6]], True, WHITE)
        trail_locks_button = pygame.Rect(650, 1380 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, LAVA, trail_locks_button, border_radius=10)
        screen.blit(trail_locks_text, trail_locks_text.get_rect(center=trail_locks_button.center))
        if trail_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[6] > 1: enemy_locks[6] = 0
            else: enemy_locks[6] = enemy_locks[6] + 1
            pygame.time.delay(200)



        impostor_hp_label = font.render("Impostor Enemy - HP: " + str(impostor_hp_setting), True, WHITE)
        screen.blit(impostor_hp_label, (50, 1440 + scroll_y))
        impostor_hp_minus_button = pygame.Rect(500, 1440 - button_offset + scroll_y, 50, 50)
        impostor_hp_plus_button = pygame.Rect(560, 1440 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, impostor_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=impostor_hp_plus_button.center))
        pygame.draw.rect(screen, RED, impostor_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=impostor_hp_minus_button.center))
        if impostor_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            impostor_hp_setting += 1
            if impostor_hp_setting > 99:
                impostor_hp_setting = 99
            pygame.time.delay(50)
        if impostor_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            impostor_hp_setting -= 1
            if impostor_hp_setting < 1:
                impostor_hp_setting = 1
            pygame.time.delay(50)
        impostor_locks_text = font.render(enemy_locking_labels[enemy_locks[7]], True, BLACK)
        impostor_locks_button = pygame.Rect(650, 1440 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, WHITE, impostor_locks_button, border_radius=10)
        screen.blit(impostor_locks_text, impostor_locks_text.get_rect(center=impostor_locks_button.center))
        if impostor_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[7] > 1: enemy_locks[7] = 0
            else: enemy_locks[7] = enemy_locks[7] + 1
            pygame.time.delay(200)



        splitter_hp_label = font.render("Splitter Enemy - HP: " + str(splitter_hp_setting), True, LIME)
        screen.blit(splitter_hp_label, (50, 1500 + scroll_y))
        splitter_hp_minus_button = pygame.Rect(500, 1500 - button_offset + scroll_y, 50, 50)
        splitter_hp_plus_button = pygame.Rect(560, 1500 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, splitter_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=splitter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, splitter_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=splitter_hp_minus_button.center))
        if splitter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            splitter_hp_setting += 1
            if splitter_hp_setting > 99:
                splitter_hp_setting = 99
            pygame.time.delay(50)
        if splitter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            splitter_hp_setting -= 1
            if splitter_hp_setting < 1:
                splitter_hp_setting = 1
            pygame.time.delay(50)
        splitter_locks_text = font.render(enemy_locking_labels[enemy_locks[8]], True, WHITE)
        splitter_locks_button = pygame.Rect(650, 1500 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, LIME, splitter_locks_button, border_radius=10)
        screen.blit(splitter_locks_text, splitter_locks_text.get_rect(center=splitter_locks_button.center))
        if splitter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[8] > 1: enemy_locks[8] = 0
            else: enemy_locks[8] = enemy_locks[8] + 1
            pygame.time.delay(200)



        bomb_hp_label = font.render("Bomb Enemy - HP: " + str(bomb_hp_setting), True, HOT_PINK)
        screen.blit(bomb_hp_label, (50, 1560 + scroll_y))
        bomb_hp_minus_button = pygame.Rect(500, 1560 - button_offset + scroll_y, 50, 50)
        bomb_hp_plus_button = pygame.Rect(560, 1560 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, bomb_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=bomb_hp_plus_button.center))
        pygame.draw.rect(screen, RED, bomb_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=bomb_hp_minus_button.center))
        if bomb_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            bomb_hp_setting += 1
            if bomb_hp_setting > 99:
                bomb_hp_setting = 99
            pygame.time.delay(50)
        if bomb_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            bomb_hp_setting -= 1
            if bomb_hp_setting < 1:
                bomb_hp_setting = 1
            pygame.time.delay(50)
        bomb_locks_text = font.render(enemy_locking_labels[enemy_locks[9]], True, WHITE)
        bomb_locks_button = pygame.Rect(650, 1560 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, HOT_PINK, bomb_locks_button, border_radius=10)
        screen.blit(bomb_locks_text, bomb_locks_text.get_rect(center=bomb_locks_button.center))
        if bomb_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[9] > 1: enemy_locks[9] = 0
            else: enemy_locks[9] = enemy_locks[9] + 1
            pygame.time.delay(200)



        shooter_hp_label = font.render("Shooter Enemy - HP: " + str(shooter_hp_setting), True, BRONZE)
        screen.blit(shooter_hp_label, (50, 1620 + scroll_y))
        shooter_hp_minus_button = pygame.Rect(500, 1620 - button_offset + scroll_y, 50, 50)
        shooter_hp_plus_button = pygame.Rect(560, 1620 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, shooter_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=shooter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, shooter_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=shooter_hp_minus_button.center))
        if shooter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            shooter_hp_setting += 1
            if shooter_hp_setting > 99:
                shooter_hp_setting = 99
            pygame.time.delay(50)
        if shooter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            shooter_hp_setting -= 1
            if shooter_hp_setting < 1:
                shooter_hp_setting = 1
            pygame.time.delay(50)
        shooter_locks_text = font.render(enemy_locking_labels[enemy_locks[10]], True, WHITE)
        shooter_locks_button = pygame.Rect(650, 1620 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BRONZE, shooter_locks_button, border_radius=10)
        screen.blit(shooter_locks_text, shooter_locks_text.get_rect(center=shooter_locks_button.center))
        if shooter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[10] > 1: enemy_locks[10] = 0
            else: enemy_locks[10] = enemy_locks[10] + 1
            pygame.time.delay(200)



        sniper_hp_label = font.render("Sniper Enemy - HP: " + str(sniper_hp_setting), True, INDIGO)
        screen.blit(sniper_hp_label, (50, 1680 + scroll_y))
        sniper_hp_minus_button = pygame.Rect(500, 1680 - button_offset + scroll_y, 50, 50)
        sniper_hp_plus_button = pygame.Rect(560, 1680 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, sniper_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=sniper_hp_plus_button.center))
        pygame.draw.rect(screen, RED, sniper_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=sniper_hp_minus_button.center))
        if sniper_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            sniper_hp_setting += 1
            if sniper_hp_setting > 99:
                sniper_hp_setting = 99
            pygame.time.delay(50)
        if sniper_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            sniper_hp_setting -= 1
            if sniper_hp_setting < 1:
                sniper_hp_setting = 1
            pygame.time.delay(50)
        sniper_locks_text = font.render(enemy_locking_labels[enemy_locks[11]], True, WHITE)
        sniper_locks_button = pygame.Rect(650, 1680 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, INDIGO, sniper_locks_button, border_radius=10)
        screen.blit(sniper_locks_text, sniper_locks_text.get_rect(center=sniper_locks_button.center))
        if sniper_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[11] > 1: enemy_locks[11] = 0
            else: enemy_locks[11] = enemy_locks[11] + 1
            pygame.time.delay(200)


        speedy_hp_label = font.render("Speedy Enemy - HP: " + str(speedy_hp_setting), True, SKY)
        screen.blit(speedy_hp_label, (50, 1740 + scroll_y))
        speedy_hp_minus_button = pygame.Rect(500, 1740 - button_offset + scroll_y, 50, 50)
        speedy_hp_plus_button = pygame.Rect(560, 1740 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, speedy_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=speedy_hp_plus_button.center))
        pygame.draw.rect(screen, RED, speedy_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=speedy_hp_minus_button.center))
        if speedy_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            speedy_hp_setting += 1
            if speedy_hp_setting > 99:
                speedy_hp_setting = 99
            pygame.time.delay(50)
        if speedy_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            speedy_hp_setting -= 1
            if speedy_hp_setting < 1:
                speedy_hp_setting = 1
            pygame.time.delay(50)
        speedy_locks_text = font.render(enemy_locking_labels[enemy_locks[12]], True, WHITE)
        speedy_locks_button = pygame.Rect(650, 1740 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, SKY, speedy_locks_button, border_radius=10)
        screen.blit(speedy_locks_text, speedy_locks_text.get_rect(center=speedy_locks_button.center))
        if speedy_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[12] > 1: enemy_locks[12] = 0
            else: enemy_locks[12] = enemy_locks[12] + 1
            pygame.time.delay(200)


        shotgun_hp_label = font.render("Shotgun Enemy - HP: " + str(shotgun_hp_setting), True, BRICK)
        screen.blit(shotgun_hp_label, (50, 1800 + scroll_y))
        shotgun_hp_minus_button = pygame.Rect(500, 1800 - button_offset + scroll_y, 50, 50)
        shotgun_hp_plus_button = pygame.Rect(560, 1800 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, shotgun_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=shotgun_hp_plus_button.center))
        pygame.draw.rect(screen, RED, shotgun_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=shotgun_hp_minus_button.center))
        if shotgun_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            shotgun_hp_setting += 1
            if shotgun_hp_setting > 99:
                shotgun_hp_setting = 99
            pygame.time.delay(50)
        if shotgun_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            shotgun_hp_setting -= 1
            if shotgun_hp_setting < 1:
                shotgun_hp_setting = 1
            pygame.time.delay(50)
        shotgun_locks_text = font.render(enemy_locking_labels[enemy_locks[13]], True, WHITE)
        shotgun_locks_button = pygame.Rect(650, 1800 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BRICK, shotgun_locks_button, border_radius=10)
        screen.blit(shotgun_locks_text, shotgun_locks_text.get_rect(center=shotgun_locks_button.center))
        if shotgun_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[13] > 1: enemy_locks[13] = 0
            else: enemy_locks[13] = enemy_locks[13] + 1
            pygame.time.delay(200)



        voodoo_hp_label = font.render("Voodoo Enemy - HP: " + str(voodoo_hp_setting), True, MAGENTA)
        screen.blit(voodoo_hp_label, (50, 1860 + scroll_y))
        voodoo_hp_minus_button = pygame.Rect(500, 1860 - button_offset + scroll_y, 50, 50)
        voodoo_hp_plus_button = pygame.Rect(560, 1860 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, voodoo_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=voodoo_hp_plus_button.center))
        pygame.draw.rect(screen, RED, voodoo_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=voodoo_hp_minus_button.center))
        if voodoo_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            voodoo_hp_setting += 1
            if voodoo_hp_setting > 99:
                voodoo_hp_setting = 99
            pygame.time.delay(50)
        if voodoo_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            voodoo_hp_setting -= 1
            if voodoo_hp_setting < 1:
                voodoo_hp_setting = 1
            pygame.time.delay(50)
        voodoo_locks_text = font.render(enemy_locking_labels[enemy_locks[14]], True, WHITE)
        voodoo_locks_button = pygame.Rect(650, 1860 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, MAGENTA, voodoo_locks_button, border_radius=10)
        screen.blit(voodoo_locks_text, voodoo_locks_text.get_rect(center=voodoo_locks_button.center))
        if voodoo_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[14] > 1: enemy_locks[14] = 0
            else: enemy_locks[14] = enemy_locks[14] + 1
            pygame.time.delay(200)



        blind_hp_label = font.render("Blind Enemy - HP: " + str(blind_hp_setting), True, BLUE)
        screen.blit(blind_hp_label, (50, 1920 + scroll_y))
        blind_hp_minus_button = pygame.Rect(500, 1920 - button_offset + scroll_y, 50, 50)
        blind_hp_plus_button = pygame.Rect(560, 1920 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, blind_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=blind_hp_plus_button.center))
        pygame.draw.rect(screen, RED, blind_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=blind_hp_minus_button.center))
        if blind_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            blind_hp_setting += 1
            if blind_hp_setting > 99:
                blind_hp_setting = 99
            pygame.time.delay(50)
        if blind_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            blind_hp_setting -= 1
            if blind_hp_setting < 1:
                blind_hp_setting = 1
            pygame.time.delay(50)
        blind_locks_text = font.render(enemy_locking_labels[enemy_locks[15]], True, WHITE)
        blind_locks_button = pygame.Rect(650, 1920 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BLUE, blind_locks_button, border_radius=10)
        screen.blit(blind_locks_text, blind_locks_text.get_rect(center=blind_locks_button.center))
        if blind_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[15] > 1: enemy_locks[15] = 0
            else: enemy_locks[15] = enemy_locks[15] + 1
            pygame.time.delay(200)




        motion_hp_label = font.render("Motion Enemy - HP: " + str(motion_hp_setting), True, ORANGE)
        screen.blit(motion_hp_label, (50, 1980 + scroll_y))
        motion_hp_minus_button = pygame.Rect(500, 1980 - button_offset + scroll_y, 50, 50)
        motion_hp_plus_button = pygame.Rect(560, 1980 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, motion_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=motion_hp_plus_button.center))
        pygame.draw.rect(screen, RED, motion_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=motion_hp_minus_button.center))
        if motion_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            motion_hp_setting += 1
            if motion_hp_setting > 99:
                motion_hp_setting = 99
            pygame.time.delay(50)
        if motion_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            motion_hp_setting -= 1
            if motion_hp_setting < 1:
                motion_hp_setting = 1
            pygame.time.delay(50)
        motion_locks_text = font.render(enemy_locking_labels[enemy_locks[16]], True, WHITE)
        motion_locks_button = pygame.Rect(650, 1980 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, ORANGE, motion_locks_button, border_radius=10)
        screen.blit(motion_locks_text, motion_locks_text.get_rect(center=motion_locks_button.center))
        if motion_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[16] > 1: enemy_locks[16] = 0
            else: enemy_locks[16] = enemy_locks[16] + 1
            pygame.time.delay(200)


        charger_hp_label = font.render("Charger Enemy - HP: " + str(charger_hp_setting), True, YELLOW)
        screen.blit(charger_hp_label, (50, 2040 + scroll_y))
        charger_hp_minus_button = pygame.Rect(500, 2040 - button_offset + scroll_y, 50, 50)
        charger_hp_plus_button = pygame.Rect(560, 2040 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, charger_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=charger_hp_plus_button.center))
        pygame.draw.rect(screen, RED, charger_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=charger_hp_minus_button.center))
        if charger_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            charger_hp_setting += 1
            if charger_hp_setting > 99:
                charger_hp_setting = 99
            pygame.time.delay(50)
        if charger_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            charger_hp_setting -= 1
            if charger_hp_setting < 1:
                charger_hp_setting = 1
            pygame.time.delay(50)
        charger_locks_text = font.render(enemy_locking_labels[enemy_locks[17]], True, WHITE)
        charger_locks_button = pygame.Rect(650, 2040 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, YELLOW, charger_locks_button, border_radius=10)
        screen.blit(charger_locks_text, charger_locks_text.get_rect(center=charger_locks_button.center))
        if charger_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[17] > 1: enemy_locks[17] = 0
            else: enemy_locks[17] = enemy_locks[17] + 1
            pygame.time.delay(200)


        rapidshooter_hp_label = font.render("Rapidshooter Enemy - HP: " + str(rapidshooter_hp_setting), True, SILVER)
        screen.blit(rapidshooter_hp_label, (50, 2100 + scroll_y))
        rapidshooter_hp_minus_button = pygame.Rect(500, 2100 - button_offset + scroll_y, 50, 50)
        rapidshooter_hp_plus_button = pygame.Rect(560, 2100 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, rapidshooter_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=rapidshooter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, rapidshooter_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=rapidshooter_hp_minus_button.center))
        if rapidshooter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            rapidshooter_hp_setting += 1
            if rapidshooter_hp_setting > 99:
                rapidshooter_hp_setting = 99
            pygame.time.delay(50)
        if rapidshooter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            rapidshooter_hp_setting -= 1
            if rapidshooter_hp_setting < 1:
                rapidshooter_hp_setting = 1
            pygame.time.delay(50)
        rapidshooter_locks_text = font.render(enemy_locking_labels[enemy_locks[18]], True, WHITE)
        rapidshooter_locks_button = pygame.Rect(650, 2100 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, SILVER, rapidshooter_locks_button, border_radius=10)
        screen.blit(rapidshooter_locks_text, rapidshooter_locks_text.get_rect(center=rapidshooter_locks_button.center))
        if rapidshooter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[18] > 1: enemy_locks[18] = 0
            else: enemy_locks[18] = enemy_locks[18] + 1
            pygame.time.delay(200)



        frostbite_hp_label = font.render("Frostbite Enemy - HP: " + str(frostbite_hp_setting), True, CYAN)
        screen.blit(frostbite_hp_label, (50, 2160 + scroll_y))
        frostbite_hp_minus_button = pygame.Rect(500, 2160 - button_offset + scroll_y, 50, 50)
        frostbite_hp_plus_button = pygame.Rect(560, 2160 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, frostbite_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=frostbite_hp_plus_button.center))
        pygame.draw.rect(screen, RED, frostbite_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=frostbite_hp_minus_button.center))
        if frostbite_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            frostbite_hp_setting += 1
            if frostbite_hp_setting > 99:
                frostbite_hp_setting = 99
            pygame.time.delay(50)
        if frostbite_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            frostbite_hp_setting -= 1
            if frostbite_hp_setting < 1:
                frostbite_hp_setting = 1
            pygame.time.delay(50)
        frostbite_locks_text = font.render(enemy_locking_labels[enemy_locks[19]], True, WHITE)
        frostbite_locks_button = pygame.Rect(650, 2160 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, CYAN, frostbite_locks_button, border_radius=10)
        screen.blit(frostbite_locks_text, frostbite_locks_text.get_rect(center=frostbite_locks_button.center))
        if frostbite_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[19] > 1: enemy_locks[19] = 0
            else: enemy_locks[19] = enemy_locks[19] + 1
            pygame.time.delay(200)


        addictive_hp_label = font.render("Addictive Enemy - HP: " + str(addictive_hp_setting), True, PINK)
        screen.blit(addictive_hp_label, (50, 2220 + scroll_y))
        addictive_hp_minus_button = pygame.Rect(500, 2220 - button_offset + scroll_y, 50, 50)
        addictive_hp_plus_button = pygame.Rect(560, 2220 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, addictive_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=addictive_hp_plus_button.center))
        pygame.draw.rect(screen, RED, addictive_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=addictive_hp_minus_button.center))
        if addictive_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_hp_setting += 1
            if addictive_hp_setting > 99:
                addictive_hp_setting = 99
            pygame.time.delay(50)
        if addictive_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_hp_setting -= 1
            if addictive_hp_setting < 1:
                addictive_hp_setting = 1
            pygame.time.delay(50)
        addictive_locks_text = font.render(enemy_locking_labels[enemy_locks[20]], True, WHITE)
        addictive_locks_button = pygame.Rect(650, 2220 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, PINK, addictive_locks_button, border_radius=10)
        screen.blit(addictive_locks_text, addictive_locks_text.get_rect(center=addictive_locks_button.center))
        if addictive_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[20] > 1: enemy_locks[20] = 0
            else: enemy_locks[20] = enemy_locks[20] + 1
            pygame.time.delay(200)



        laser_hp_label = font.render("Laser Enemy - HP: " + str(laser_hp_setting), True, TURQUOISE)
        screen.blit(laser_hp_label, (50, 2280 + scroll_y))
        laser_hp_minus_button = pygame.Rect(500, 2280 - button_offset + scroll_y, 50, 50)
        laser_hp_plus_button = pygame.Rect(560, 2280 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, laser_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=laser_hp_plus_button.center))
        pygame.draw.rect(screen, RED, laser_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=laser_hp_minus_button.center))
        if laser_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            laser_hp_setting += 1
            if laser_hp_setting > 99:
                laser_hp_setting = 99
            pygame.time.delay(50)
        if laser_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            laser_hp_setting -= 1
            if laser_hp_setting < 1:
                laser_hp_setting = 1
            pygame.time.delay(50)
        laser_locks_text = font.render(enemy_locking_labels[enemy_locks[21]], True, WHITE)
        laser_locks_button = pygame.Rect(650, 2280 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, TURQUOISE, laser_locks_button, border_radius=10)
        screen.blit(laser_locks_text, laser_locks_text.get_rect(center=laser_locks_button.center))
        if laser_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[21] > 1: enemy_locks[21] = 0
            else: enemy_locks[21] = enemy_locks[21] + 1
            pygame.time.delay(200)



        hardened_hp_label = font.render("Hardened Enemy - HP: " + str(hardened_hp_setting), True, BROWN)
        screen.blit(hardened_hp_label, (50, 2340 + scroll_y))
        hardened_hp_minus_button = pygame.Rect(500, 2340 - button_offset + scroll_y, 50, 50)
        hardened_hp_plus_button = pygame.Rect(560, 2340 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, hardened_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=hardened_hp_plus_button.center))
        pygame.draw.rect(screen, RED, hardened_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=hardened_hp_minus_button.center))
        if hardened_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            hardened_hp_setting += 1
            if hardened_hp_setting > 99:
                hardened_hp_setting = 99
            pygame.time.delay(50)
        if hardened_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            hardened_hp_setting -= 1
            if hardened_hp_setting < 1:
                hardened_hp_setting = 1
            pygame.time.delay(50)
        hardened_locks_text = font.render(enemy_locking_labels[enemy_locks[22]], True, WHITE)
        hardened_locks_button = pygame.Rect(650, 2340 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BROWN, hardened_locks_button, border_radius=10)
        screen.blit(hardened_locks_text, hardened_locks_text.get_rect(center=hardened_locks_button.center))
        if hardened_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[22] > 1: enemy_locks[22] = 0
            else: enemy_locks[22] = enemy_locks[22] + 1
            pygame.time.delay(200)



        accelerator_hp_label = font.render("Accelerator Enemy - HP: " + str(accelerator_hp_setting), True, TAN)
        screen.blit(accelerator_hp_label, (50, 2400 + scroll_y))
        accelerator_hp_minus_button = pygame.Rect(500, 2400 - button_offset + scroll_y, 50, 50)
        accelerator_hp_plus_button = pygame.Rect(560, 2400 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, accelerator_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=accelerator_hp_plus_button.center))
        pygame.draw.rect(screen, RED, accelerator_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=accelerator_hp_minus_button.center))
        if accelerator_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            accelerator_hp_setting += 1
            if accelerator_hp_setting > 99:
                accelerator_hp_setting = 99
            pygame.time.delay(50)
        if accelerator_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            accelerator_hp_setting -= 1
            if accelerator_hp_setting < 1:
                accelerator_hp_setting = 1
            pygame.time.delay(50)
        accelerator_locks_text = font.render(enemy_locking_labels[enemy_locks[23]], True, WHITE)
        accelerator_locks_button = pygame.Rect(650, 2400 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, TAN, accelerator_locks_button, border_radius=10)
        screen.blit(accelerator_locks_text, accelerator_locks_text.get_rect(center=accelerator_locks_button.center))
        if accelerator_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[23] > 1: enemy_locks[23] = 0
            else: enemy_locks[23] = enemy_locks[23] + 1
            pygame.time.delay(200)



        cold_hp_label = font.render("Cold Enemy - HP: " + str(cold_hp_setting), True, ICE)
        screen.blit(cold_hp_label, (50, 2460 + scroll_y))
        cold_hp_minus_button = pygame.Rect(500, 2460 - button_offset + scroll_y, 50, 50)
        cold_hp_plus_button = pygame.Rect(560, 2460 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, cold_hp_plus_button, border_radius=10)
        screen.blit(plus_txt, plus_txt.get_rect(center=cold_hp_plus_button.center))
        pygame.draw.rect(screen, RED, cold_hp_minus_button, border_radius=10)
        screen.blit(minus_txt, minus_txt.get_rect(center=cold_hp_minus_button.center))
        if cold_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            cold_hp_setting += 1
            if cold_hp_setting > 99:
                cold_hp_setting = 99
            pygame.time.delay(50)
        if cold_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            cold_hp_setting -= 1
            if cold_hp_setting < 1:
                cold_hp_setting = 1
            pygame.time.delay(50)
        cold_locks_text = font.render(enemy_locking_labels[enemy_locks[24]], True, WHITE)
        cold_locks_button = pygame.Rect(650, 2460 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, ICE, cold_locks_button, border_radius=10)
        screen.blit(cold_locks_text, cold_locks_text.get_rect(center=cold_locks_button.center))
        if cold_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[24] > 1: enemy_locks[24] = 0
            else: enemy_locks[24] = enemy_locks[24] + 1
            pygame.time.delay(200)



        pygame.draw.rect(screen, GRAY, scrollbar_track, border_radius=6)
        pygame.draw.rect(screen, WHITE, scrollbar_handle, border_radius=6)

        

        for event in pygame.event.get():
            if event.type == pygame.MOUSEWHEEL:
                scroll_y += event.y * scroll_speed * 2
                scroll_y = max(min(scroll_y, 0), -max_scroll)
            if event.type == pygame.QUIT:
                pygame.quit(); exit()
            if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                if 0 in enemy_locks: running = False
            if event.type == pygame.MOUSEBUTTONDOWN:
                if scrollbar_handle.collidepoint(event.pos):
                    dragging_scrollbar = True
                    mouse_offset_y = event.pos[1] - scrollbar_handle.y

            if event.type == pygame.MOUSEBUTTONUP:
                dragging_scrollbar = False

            if event.type == pygame.MOUSEMOTION and dragging_scrollbar:
                new_y = event.pos[1] - mouse_offset_y
                new_y = max(
                    scrollbar_track.y,
                    min(new_y, scrollbar_track.bottom - handle_height)
                )

                ratio = (new_y - scrollbar_track.y) / (scrollbar_track.height - handle_height)
                scroll_y = -int(ratio * max_scroll)
        pygame.display.flip()
        clock.tick(60)

menu_font = pygame.font.Font(None, 48)
text_color = (255, 255, 255)

button_width, button_height = 200, 60
margin = 40
button_gap = 40

total_width = button_width * 2 + button_gap
start_x = (WIDTH - total_width) // 2
y_pos = HEIGHT - button_height - margin - 400


def TITLE_SCREEN():
    global players

    start_button = pygame.Rect(WIDTH//2 - 100, HEIGHT//2 - 50, 200, 60)
    settings_button = pygame.Rect(WIDTH//2 - 100, HEIGHT//2 + 150, 200, 60)
    button_1p = pygame.Rect(start_x, y_pos, button_width, button_height)
    button_2p = pygame.Rect(start_x + button_width + button_gap, y_pos, button_width, button_height)

    # Move the player buttons slightly DOWN so they sit under the Start button
    button_1p.x = WIDTH//2 - 220  # move left
    button_1p.y = HEIGHT//2 + 50

    button_2p.x = WIDTH//2 + 20   # move right
    button_2p.y = HEIGHT//2 + 50
    
    waiting = True
    while waiting:
        screen.fill((0, 0, 0))
        title_text = big_font.render("Pixels Of Evasion", True, (255, 0, 0))
        screen.blit(title_text, title_text.get_rect(center=(WIDTH//2, HEIGHT//2 - 150)))

        mouse_pos = pygame.mouse.get_pos()
        mouse_click = pygame.mouse.get_pressed()[0]

        # --- Start Game button (TOP) ---
        if players in [1, 2]:
            color = GREEN if start_button.collidepoint(mouse_pos) else FOREST
        else:
            color = LIME  # disabled look until a mode is chosen

        pygame.draw.rect(screen, color, start_button, border_radius=10)
        start_text = font.render("Start Game", True, (255, 255, 255))
        screen.blit(start_text, start_text.get_rect(center=start_button.center))

        if start_button.collidepoint(mouse_pos) and mouse_click and players in [1, 2]:
            waiting = False

        # --- Settings button (TOP) ---
        if players in [1, 2]:
            color = BLUE if settings_button.collidepoint(mouse_pos) else NAVY
        else:
            color = SKY  # disabled look until a mode is chosen

        pygame.draw.rect(screen, color, settings_button, border_radius=10)
        settings_text = font.render("Settings", True, (255, 255, 255))
        screen.blit(settings_text, settings_text.get_rect(center=settings_button.center))

        if settings_button.collidepoint(mouse_pos) and mouse_click:
            SETTINGS()
            pygame.time.delay(200)   # <-- prevents instant selection
            continue

        # --- Player buttons (BELOW Start button) ---
        for rect, label, value in [(button_1p, "1 Player", 1), (button_2p, "2 Players", 2)]:
            if players == value:
                color = RED
            elif rect.collidepoint(mouse_pos):
                color = MAROON
            else:
                color = CRISP

            pygame.draw.rect(screen, color, rect, border_radius=10)
            text = font.render(label, True, text_color)
            screen.blit(text, text.get_rect(center=rect.center))

            if rect.collidepoint(mouse_pos) and mouse_click:
                players = value

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()

        pygame.display.flip()
        clock.tick(15)


TITLE_SCREEN()
spawn_enabled = False

# --- SETTINGS SET ---
player_size = player_size_setting
player_font = pygame.font.SysFont(None, int(0.96 * player_size))
enemy_size = enemy_size_setting
enemy_font = pygame.font.SysFont(None, int(0.96 * enemy_size))
min_spawn_delay = min_spawn_delay_setting
initial_spawn_delay = max_spawn_delay_setting
projectile_size = projectile_size_setting
trail_size = projectile_size_setting
spawn_rate = spawn_delay_change_setting
player_speed = player_speed_setting
player_speed_base = player_speed_setting
player2_speed = player_speed_setting
player2_speed_base = player_speed_setting
enemy_speed = enemy_speed_setting
bomb_projectile_speed *= (projectile_speed_setting / 5)
shooter_projectile_speed *= (projectile_speed_setting / 5)
sniper_projectile_speed *= (projectile_speed_setting / 5)
shotgun_projectile_speed *= (projectile_speed_setting / 5)
rapidshooter_projectile_speed *= (projectile_speed_setting / 5)
frostbite_projectile_speed *= (projectile_speed_setting / 5)
regen_delay = regen_delay_setting
player_lives = player_health_setting
player2_lives = player2_health_setting
basic_hp = basic_hp_setting
homing_hp = homing_hp_setting
fatal_hp = fatal_hp_setting
flow_hp = flow_hp_setting
sticky_hp = sticky_hp_setting
gloomy_hp = gloomy_hp_setting
trail_hp = trail_hp_setting
impostor_hp = impostor_hp_setting
splitter_hp = splitter_hp_setting
bomb_hp = bomb_hp_setting
shooter_hp = shooter_hp_setting
sniper_hp = sniper_hp_setting
speedy_hp = speedy_hp_setting
shotgun_hp = shotgun_hp_setting
voodoo_hp = voodoo_hp_setting
blind_hp = blind_hp_setting
motion_hp = motion_hp_setting
charger_hp = charger_hp_setting
rapidshooter_hp = rapidshooter_hp_setting
frostbite_hp = frostbite_hp_setting
addictive_hp = addictive_hp_setting
laser_hp = laser_hp_setting
hardened_hp = hardened_hp_setting
accelerator_hp = accelerator_hp_setting
cold_hp = cold_hp_setting


enemy_lock_setup(0)
enemy_lock_setup(1)
enemy_lock_setup(2)
enemy_lock_setup(3)
enemy_lock_setup(4)
enemy_lock_setup(5)
enemy_lock_setup(6)
enemy_lock_setup(7)
enemy_lock_setup(8)
enemy_lock_setup(9)
enemy_lock_setup(10)
enemy_lock_setup(11)
enemy_lock_setup(12)
enemy_lock_setup(13)
enemy_lock_setup(14)
enemy_lock_setup(15)
enemy_lock_setup(16)
enemy_lock_setup(17)
enemy_lock_setup(18)
enemy_lock_setup(19)
enemy_lock_setup(20)
enemy_lock_setup(21)
enemy_lock_setup(22)
enemy_lock_setup(23)
enemy_lock_setup(24)
random.shuffle(locked_enemy_types)
unlock_scores = []
unlocks = 0
for unlocked in range(len(locked_enemy_types)):
    unlocks += ((1+unlocked)*10)
    unlock_scores.append(unlocks)
targetting_enemies = [2, 8, 11, 12, 14, 15, 19]

running = True
while running:
    clock.tick(FPS)
    current_time = pygame.time.get_ticks()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            running = False

    keys = pygame.key.get_pressed()

    # Determine movement for Player 1
    if players == 1:
        p1_dx = (keys[pygame.K_d] or keys[pygame.K_RIGHT]) - (keys[pygame.K_a] or keys[pygame.K_LEFT])
        p1_dy = (keys[pygame.K_s] or keys[pygame.K_DOWN]) - (keys[pygame.K_w] or keys[pygame.K_UP])
    else:
        p1_dx = (keys[pygame.K_d]) - (keys[pygame.K_a])
        p1_dy = (keys[pygame.K_s]) - (keys[pygame.K_w])
    if p1_dx != 0 or p1_dy != 0:
        length1 = math.hypot(p1_dx, p1_dy)
        p1_dx = (p1_dx / length1) * player_speed
        p1_dy = (p1_dy / length1) * player_speed

    keys2 = pygame.key.get_pressed()
    
    # Determine movement for Player 2 (if exists)
    p2_dx, p2_dy = 0, 0
    if players == 2:
        p2_dx = ((keys[pygame.K_l]) - (keys[pygame.K_j]))
        p2_dy = ((keys[pygame.K_k]) - (keys[pygame.K_i]))
        if p2_dx != 0 or p2_dy != 0:
            length2 = math.hypot(p2_dx, p2_dy)
            p2_dx = p2_dx / length2 * player2_speed
            p2_dy = p2_dy / length2 * player2_speed

    # Move players
    player_x += p1_dx
    player_y += p1_dy
    player_x = max(player_size / 2, min(WIDTH - player_size / 2, player_x))
    player_y = max(player_size / 2, min(HEIGHT - player_size / 2, player_y))

    if players == 2:
        player2_x += p2_dx
        player2_y += p2_dy

        # Clamp Player 2 to screen edges
        player2_x = max(player_size / 2, min(WIDTH - player_size / 2, player2_x))
        player2_y = max(player_size / 2, min(HEIGHT - player_size / 2, player2_y))
        if player_alive and player2_alive:
            if centered_rect_collision(player_x, player_y, player_size,
                               player2_x, player2_y, player_size):
                overlap_x = (player_size - abs(player_x - player2_x)) / 2
                overlap_y = (player_size - abs(player_y - player2_y)) / 2

                # Push both players apart along the smallest overlap axis
                if overlap_x < overlap_y:
                    if player_x < player2_x:
                        player_x -= overlap_x
                        player2_x += overlap_x
                    else:
                        player_x += overlap_x
                        player2_x -= overlap_x
                else:
                    if player_y < player2_y:
                        player_y -= overlap_y
                        player2_y += overlap_y
                    else:
                        player_y += overlap_y
                        player2_y -= overlap_y

    player_moving = (p1_dx != 0 or p1_dy != 0)

    if current_time > slow_until:
        player_speed = player_speed_base
        player_frozen = False
    if players == 2 and current_time > player2_slow_until:
        player2_speed = player2_speed_base
        player2_frozen = False

    # Update spawner activation
    if not spawn_enabled:
        if p1_dx != 0 or p1_dy != 0 or (players == 2 and (p2_dx != 0 or p2_dy != 0)):
            spawn_enabled = True


        
    # --- Dynamic Enemy Unlock ---
    while unlock_scores and score >= unlock_scores[0]:
        if locked_enemy_types:
            new_type = locked_enemy_types[0]
            available_enemy_types.append(new_type)
            locked_enemy_types.remove(new_type)
        unlock_scores.pop(0)

    # --- Enemy Spawning ---
    adjusted_score = score / 2  # scale back to old point rate
    spawn_delay = max(
        min_spawn_delay,
        initial_spawn_delay - int(adjusted_score * spawn_rate)
    )
    if spawn_enabled and current_time - last_spawn_time >= spawn_delay:
        enemy_type = random.choice(available_enemy_types)
        angle = random.uniform(0, 2 * math.pi)
        dx = math.cos(angle) * enemy_speed
        dy = math.sin(angle) * enemy_speed
        sussy_dx = math.cos(angle) * player_speed_base
        sussy_dy = math.sin(angle) * player_speed_base
        base_dx = dx
        base_dy = dy

        # Default values
        health = basic_hp
        shoot_delay = None  # <-- FIX: define before conditionals

        # Determine enemy attributes based on type
        if enemy_type == 1:
            dx *= 1; dy *= 1; health = basic_hp
        elif enemy_type == 2:
            dx *= 0.7; dy *= 0.7; health = homing_hp
        elif enemy_type == 3:
            dx *= 0.5; dy *= 0.5; health = fatal_hp
        elif enemy_type == 4:
            dx *= 2/3; dy *= 2/3; health = flow_hp
        elif enemy_type == 5:
            dx *= 1; dy *= 1; health = sticky_hp
        elif enemy_type == 6:
            dx *= 1; dy *= 1; health = gloomy_hp
        elif enemy_type == 7:
            dx *= 1; dy *= 1; health = trail_hp
        elif enemy_type == 8:
            health = impostor_hp
        elif enemy_type == 9:
            dx *= 1; dy *= 1; health = splitter_hp
        elif enemy_type == 10:
            dx *= 1; dy *= 1; health = bomb_hp
        elif enemy_type == 11:
            dx *= 0.9; dy *= 0.9; health = shooter_hp
            shoot_delay = shooter_delay
        elif enemy_type == 12:
            dx *= 0.3; dy *= 0.3; health = sniper_hp
            shoot_delay = sniper_delay
        elif enemy_type == 13:
            dx *= 2; dy *= 2; health = speedy_hp
        elif enemy_type == 14:
            dx *= 0.9; dy *= 0.9; health = shotgun_hp
            shoot_delay = shotgun_delay
        elif enemy_type == 15:
            dx *= 0.35; dy *= 0.35; health = voodoo_hp
        elif enemy_type == 16:
            dx *= 1.5; dy *= 1.5; health = blind_hp
        elif enemy_type == 17:
            dx *= 1.5; dy *= 1.5; health = motion_hp
        elif enemy_type == 18:
            dx *= 2; dy *= 2; health = charger_hp
        elif enemy_type == 19:
            dx *= 1.25; dy *= 1.25; health = rapidshooter_hp
            shoot_delay = rapidshooter_delay
        elif enemy_type == 20:
            dx *= 0.5; dy *= 0.5; health = frostbite_hp
        elif enemy_type == 21:
            dx *= 0.75; dy *= 0.75; health = addictive_hp
        elif enemy_type == 22:
            dx *= 0.65; dy *= 0.65; health = laser_hp
        elif enemy_type == 23:
            dx *= 0.5; dy *= 0.5; health = hardened_hp
        elif enemy_type == 24:
            base_dx = dx; base_dy = dy
            dx *= 0; dy *= 0; health = accelerator_hp
            accel = 0.0; accel_rate = 0.02
        elif enemy_type == 25:
            dx *= 0.5; dy *= 0.5; health = cold_hp

        if enemy_type in targetting_enemies:
            if players == 1:
                target = 1
            else:
                target = random.choice([1, 2])
        else: target = 0
            

        enemies.append({
            "x": spawner_pos[0]+25,
            "y": spawner_pos[1]+25,
            "target": target,
            "dx": dx,
            "dy": dy,
            "sussy_dx": sussy_dx,
            "sussy_dy": sussy_dy,
            "base_dx": base_dx,
            "base_dy": base_dy,
            "accel": accel,
            "accel_rate": accel_rate,
            "type": enemy_type,
            "angle": angle,
            "bounces": 0,
            "shrinking": False,
            "size": enemy_size,        # use the global default size initially
            "health": health,
            "ability": 1,
            "stopped": False,
            "stop_start_time": None,
            "last_trail_time": current_time,
            "last_shot_time": current_time,
            "shoot_delay": shoot_delay,
            "spawn_protected": True,
            "spawn_time": current_time
        })
        last_spawn_time = current_time
        
        for enemy in enemies:
            if players == 2:
                if not player_alive and player2_alive:
                    enemy["target"] = 2
                elif not player2_alive and player_alive:
                    enemy["target"] = 1

    # --- Enemy Movement ---
    for enemy in enemies[:]:
        enemy_died = False
        sz = enemy.get("size", enemy_size)
        if enemy["type"] == 1:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= basic_hp: enemy_died = True

        elif enemy["type"] == 2:
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                dx = tx - enemy["x"]; dy = ty - enemy["y"]
            else:
                dx, dy = 0, 0
            target_angle = math.atan2(dy, dx)
            enemy["angle"] = rotate_toward(enemy["angle"], target_angle, 0.02)
            enemy["dx"] = math.cos(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["dy"] = math.sin(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["angle"] = math.pi - enemy["angle"]; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["angle"] = -enemy["angle"]; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= homing_hp: enemy_died = True

        elif enemy["type"] == 3:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= fatal_hp: enemy_died = True

        elif enemy["type"] == 4:
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            speed_multiplier = 2.5 if closest_dist < 250 else 2/3
            enemy["x"] += enemy["dx"] * speed_multiplier
            enemy["y"] += enemy["dy"] * speed_multiplier
            bounced = False
            # X-axis bounce
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
                if enemy["x"] <= 0: enemy["x"] = 0
                elif enemy["x"] >= WIDTH - enemy_size: enemy["x"] = WIDTH - enemy_size/2
            # Y-axis bounce
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
                if enemy["y"] <= 0: enemy["y"] = 0
                elif enemy["y"] >= HEIGHT - enemy_size: enemy["y"] = HEIGHT - enemy_size/2
            # Update bounce count and health once per frame
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            # Remove enemy if health depleted
            if enemy["bounces"] >= flow_hp or enemy["health"] <= 0:
                enemy_died = True


        elif enemy["type"] == 5:
            if enemy["stopped"]:
                # after 2 seconds resume moving
                if current_time - enemy["stop_start_time"] >= 2000:
                    enemy["stopped"] = False
            else:
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                bounced = False
                if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                    enemy["dx"] *= -1
                    bounced = True
                if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                    enemy["dy"] *= -1
                    bounced = True

                if bounced:
                    enemy["health"] -= 1
                    if enemy["health"] <= 0:
                        enemy_died = True
                    else:
                        enemy["stopped"] = True
                        enemy["stop_start_time"] = current_time

            # final safety: if health already at 0, mark dead
            if enemy["health"] <= 0:
                enemy_died = True

        elif enemy["type"] == 6:  # Purple
            dist1 = distance(enemy["x"]-enemy_size/2, enemy["y"]-enemy_size/2, player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"]-enemy_size/2, enemy["y"]-enemy_size/2, player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            if closest_dist > 250:
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]
                bounced = False
                if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: 
                    enemy["dx"] *= -1; bounced = True
                if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: 
                    enemy["dy"] *= -1; bounced = True
                if bounced:
                    enemy["bounces"] += 1; enemy["health"] -= 1
                if enemy["health"] <= 0: enemy_died = True


        elif enemy["type"] == 7:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if current_time - enemy["last_trail_time"] >= trail_interval_ms:
                trail_squares.append({
                    "x": int(enemy["x"]),
                    "y": int(enemy["y"]),
                    "spawn": current_time,
                    "health": 3
                })
                enemy["last_trail_time"] = current_time
            if enemy["health"] <= 0: enemy_died = True

        elif enemy["type"] == 8:
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                if (enemy["target"] == 1 and (p1_dx or p1_dy)) or (enemy["target"] == 2 and (p2_dx or p2_dy)):
                    if player_frozen == True and enemy["target"] == 1:
                        enemy["x"] += enemy["sussy_dx"] * 0.5
                        enemy["y"] += enemy["sussy_dy"] * 0.5
                    elif player2_frozen == True and enemy["target"] == 2:
                        enemy["x"] += enemy["sussy_dx"] * 0.5
                        enemy["y"] += enemy["sussy_dy"] * 0.5
                    else:
                        enemy["x"] += enemy["sussy_dx"]
                        enemy["y"] += enemy["sussy_dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["sussy_dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["sussy_dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= impostor_hp or enemy["health"] <= 0:
                enemy_died = True

        elif enemy["type"] == 9:
            # Move normally
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            # --- Handle spawn protection ---
            if enemy.get("spawn_protected"):
                # remove protection after 0.5 seconds
                if pygame.time.get_ticks() - enemy["spawn_time"] > 500:
                    enemy.pop("spawn_protected")

            # Bounce or split
            hit_edge = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                hit_edge = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                hit_edge = True

            if hit_edge:
                if enemy.get("spawn_protected"):
                    # bounce without damage
                    if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                        enemy["dx"] *= -1
                    if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                        enemy["dy"] *= -1
                else:
                    # Kill and split into two clones if health > 1
                    if enemy["health"] > 1:
                        for i in range(2):
                            angle = random.uniform(0, 2 * math.pi)
                            dx = math.cos(angle) * enemy_speed
                            dy = math.sin(angle) * enemy_speed
                            enemies.append({
                                "x": max(1 + enemy_size/2, min(WIDTH - enemy_size/2 - 1, enemy["x"])),
                                "y": max(1 + enemy_size/2, min(HEIGHT - enemy_size/2 - 1, enemy["y"])),
                                "dx": dx + projectile_size/2,
                                "dy": dy + projectile_size/2,
                                "type": 9,
                                "angle": angle,
                                "bounces": 0,
                                "health": enemy["health"] - 1,
                                "spawn_protected": True,
                                "spawn_time": pygame.time.get_ticks()
                            })
                    else:
                        split_score += 1
                        if split_score == 4:
                            score += 1
                            split_score = 0
                            if player_alive:
                                score_p1 = score
                            if player2_alive:
                                score_p2 = score

                    enemies.remove(enemy)
                continue
            # If waiting flag: wait until enemy is off the edge before taking damage
            if enemy.get("waiting"):
                # Check if off edge now
                if 0 < enemy["x"] < WIDTH - enemy_size and 0 < enemy["y"] < HEIGHT - enemy_size:
                    enemy.pop("waiting")  # remove waiting flag

                    
        elif enemy["type"] == 10:  # Hot Pink Bomb
            # Move like basic
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["health"] -= 1

            # Proximity trigger  bomb kills itself and explodes
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            if min(dist1, dist2) < 200:
                for i in range(8):  # fire 8 projectiles in all directions
                    ang = i * (2 * math.pi / 8)
                    dxp = math.cos(ang) * bomb_projectile_speed
                    dyp = math.sin(ang) * bomb_projectile_speed
                    projectiles.append({
                        "x": enemy["x"] + projectile_size/2,
                        "y": enemy["y"] + projectile_size/2,
                        "dx": dxp,
                        "dy": dyp
                    })
                enemy["health"] = 0
            if enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 11:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced: 
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= shooter_hp or enemy["health"] <= 0:
                enemy_died = True

            # Shoot at player
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                dist = math.hypot(dxp, dyp)
                dxp = dxp / dist * shooter_projectile_speed
                dyp = dyp / dist * shooter_projectile_speed
                projectiles.append({
                    "x": enemy["x"] + projectile_size/2,
                    "y": enemy["y"] + projectile_size/2,
                    "dx": dxp,
                    "dy": dyp,
                    "color": BRONZE   # add color key
                })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 12:  # Get Sniped
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced: 
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= sniper_hp or enemy["health"] <= 0:
                enemy_died = True
            # Shoot at player
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                dist = math.hypot(dxp, dyp)
                dxp = dxp / dist * sniper_projectile_speed
                dyp = dyp / dist * sniper_projectile_speed
                projectiles.append({
                    "x": enemy["x"] + projectile_size/2,
                    "y": enemy["y"] + projectile_size/2,
                    "dx": dxp,
                    "dy": dyp,
                    "color": INDIGO
                })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 13:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= speedy_hp: enemy_died = True
        elif enemy["type"] == 14:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= shotgun_hp or enemy["health"] <= 0:
                enemy_died = True

            # --- Fire 5 bullets in a spread ---
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                base_angle = math.atan2(dyp, dxp)
                spread = math.radians(30)  # total spread angle
                for i in range(5):
                    angle_offset = spread * (i - 2) / 4  # center + 2 on each side
                    ang = base_angle + angle_offset
                    projectiles.append({
                        "x": enemy["x"] + projectile_size/2,
                        "y": enemy["y"] + projectile_size/2,
                        "dx": math.cos(ang) * shotgun_projectile_speed,
                        "dy": math.sin(ang) * shotgun_projectile_speed,
                        "color": BRICK
                    })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 15:  # Magenta Voodoo
            if enemy.get("shrinking"):
                enemy["size"] = enemy.get("size", "enemy_size") * 0.85 if isinstance(enemy.get("size", None), (int, float)) else sz * 0.85
                # update local size variable for subsequent checks/drawing
                sz = enemy["size"]
                if enemy["size"] < 2:
                    # remove immediately once tiny
                    if enemy in enemies:
                        enemies.remove(enemy)
                    continue
            # movement using current size (sz)
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= sz/2 or enemy["x"] >= WIDTH - sz/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= sz/2 or enemy["y"] >= HEIGHT - sz/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
                # when it loses all HP from bounces, player takes 1 damage
                if enemy["health"] <= 0:
                    if current_time >= invincible_until:
                        if enemy["target"] == 1:
                            player_lives -= 1
                            p1_regen_block_until = score + regen_delay
                        if enemy["target"] == 2:
                            player2_lives -= 1
                            p2_regen_block_until = score + regen_delay
                        damage_flash_time = current_time
                        invincible_until = current_time + invincibility_duration
                        if player_lives <= 0:
                            player_alive = False
                        if player2_lives <= 0:
                            player2_alive = False
                    enemy_died = True
        elif enemy["type"] == 16:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= blind_hp or enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 17:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= motion_hp or enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 18:
            if enemy["stopped"]:
                # after 2 seconds resume moving
                if current_time - enemy["stop_start_time"] >= 8000:
                    enemy["stopped"] = False
            else:
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                bounced = False
                if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                    enemy["dx"] *= -1
                    bounced = True
                if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                    enemy["dy"] *= -1
                    bounced = True

                if bounced:
                    enemy["health"] -= 1
                    if enemy["health"] <= 0:
                        enemy_died = True
                    else:
                        enemy["stopped"] = True
                        enemy["stop_start_time"] = current_time

            # final safety: if health already at 0, mark dead
            if enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 19:  # Rapid Shooter
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced: 
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= shooter_hp or enemy["health"] <= 0:
                enemy_died = True

            # Shoot at player
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                dist = math.hypot(dxp, dyp)
                dxp = dxp / dist * rapidshooter_projectile_speed
                dyp = dyp / dist * rapidshooter_projectile_speed
                projectiles.append({
                    "x": enemy["x"] + projectile_size/2,
                    "y": enemy["y"] + projectile_size/2,
                    "dx": dxp,
                    "dy": dyp,
                    "color": SILVER   # add color key
                })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 20:  # Frostbite
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["health"] -= 1

            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            if min(dist1, dist2) < 200 and enemy["ability"] == 1:
                for i in range(32):  # fire 16 projectiles in all directions
                    ang = i * (2 * math.pi / 32)
                    dxp = math.cos(ang) * frostbite_projectile_speed
                    dyp = math.sin(ang) * frostbite_projectile_speed
                    projectiles.append({
                        "x": enemy["x"] + projectile_size/2,
                        "y": enemy["y"] + projectile_size/2,
                        "dx": dxp,
                        "dy": dyp,
                        "color": CYAN
                    })
                enemy["ability"] = 0
            if enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 21:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            # Bounce off walls
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["health"] -= 1
                if enemy["health"] <= 0:
                    enemy_died = True

            # --- Pull players toward it ---
            pull_radius = 600   # much wider area
            base_pull_strength = 5  # stronger base pull
            if player_alive:
                dxp = enemy["x"] - player_x
                dyp = enemy["y"] - player_y
                dist = math.hypot(dxp, dyp)
                if dist < pull_radius and dist > 1:
                    pull_strength = base_pull_strength * (1 - dist / pull_radius)
                    player_x += (dxp / dist) * pull_strength
                    player_y += (dyp / dist) * pull_strength
            if players == 2 and player2_alive:
                dxp = enemy["x"] - player2_x
                dyp = enemy["y"] - player2_y
                dist = math.hypot(dxp, dyp)
                if dist < pull_radius and dist > 1:
                    pull_strength = base_pull_strength * (1 - dist / pull_radius)
                    player2_x += (dxp / dist) * pull_strength
                    player2_y += (dyp / dist) * pull_strength
        elif enemy["type"] == 22:
            if not enemy.get("laser_mode", False):
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                hit_left = enemy["x"] <= enemy_size/2
                hit_right = enemy["x"] >= WIDTH - enemy_size/2
                hit_top = enemy["y"] <= enemy_size/2
                hit_bottom = enemy["y"] >= HEIGHT - enemy_size/2
                if hit_left or hit_right or hit_top or hit_bottom:
                    enemy["health"] -= 1

                    if enemy["health"] <= 0:
                        score += 1
                        if player_alive: score_p1 = score
                        if players == 2 and player2_alive: score_p2 = score
                        enemy["laser_mode"] = True
                        enemy["laser_start"] = pygame.time.get_ticks()
                        enemy["damaged_p1"] = False
                        enemy["damaged_p2"] = False
                        if hit_left or hit_right:
                            enemy["laser_orientation"] = "horizontal"
                            enemy["laser_y"] = enemy["y"]
                        if hit_top or hit_bottom:
                            enemy["laser_orientation"] = "vertical"
                            enemy["laser_x"] = enemy["x"]
                    else:
                        if hit_left or hit_right:
                            enemy["dx"] *= -1
                        if hit_top or hit_bottom:
                            enemy["dy"] *= -1
            else:
                if current_time - enemy["laser_start"] >= 1000:
                    enemies.remove(enemy)
                    continue
                laser_width = enemy_size
                if enemy["laser_orientation"] == "vertical":
                    lx = enemy["laser_x"]
                    if player_alive and not enemy["damaged_p1"]:
                        if abs(player_x - lx) < (player_size/2 + laser_width/2):
                            if current_time >= invincible_until:
                                player_lives -= 1
                                p1_regen_block_until = score + regen_delay
                                damage_flash_time = current_time
                                invincible_until = current_time + invincibility_duration
                                enemy["damaged_p1"] = True
                                if player_lives <= 0: player_alive = False

                    if players == 2 and player2_alive and not enemy["damaged_p2"]:
                        if player2_x + player_size > lx and player2_x < lx + laser_width:
                            if current_time >= player2_invincible_until:
                                player2_lives -= 1
                                p2_regen_block_until = score + regen_delay
                                player2_damage_flash_time = current_time
                                player2_invincible_until = current_time + invincibility_duration
                                enemy["damaged_p2"] = True
                                if player2_lives <= 0: player2_alive = False
                elif enemy["laser_orientation"] == "horizontal":
                    ly = enemy["laser_y"]
                    if player_alive and not enemy["damaged_p1"]:
                        if abs(player_y - ly) < (player_size/2 + laser_width/2):
                            if current_time >= invincible_until:
                                player_lives -= 1
                                p1_regen_block_until = score + regen_delay
                                damage_flash_time = current_time
                                invincible_until = current_time + invincibility_duration
                                enemy["damaged_p1"] = True
                                if player_lives <= 0: player_alive = False

                    if players == 2 and player2_alive and not enemy["damaged_p2"]:
                        if player2_y + player_size > ly and player2_y < ly + laser_width:
                            if current_time >= player2_invincible_until:
                                player2_lives -= 1
                                p2_regen_block_until = score + regen_delay
                                player2_damage_flash_time = current_time
                                player2_invincible_until = current_time + invincibility_duration
                                enemy["damaged_p2"] = True
                                if player2_lives <= 0: player2_alive = False
                continue
        elif enemy["type"] == 23:  # Hardened enemy (brown)
            # Moves slowly
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            # Bounces like normal
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True

            if bounced:
                enemy["health"] -= 1

            # --- PROXIMITY DAMAGE ---
            # Damage per second (tweakable)
            hardened_dps = 0.1 * (60 / FPS)  # consistent over framerate

            # Distance checks
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999

            # If within 200 pixels  lose HP
            if dist1 < 200:
                enemy["health"] -= hardened_dps
            if dist2 < 200:
                enemy["health"] -= hardened_dps  # stackable
            if enemy["health"] < 1:
                    enemy_died = True
        elif enemy["type"] == 24:
            enemy["accel"] += enemy.get("accel_rate", 0.02)
            vx = enemy.get("base_dx", enemy["dx"]) * enemy["accel"]
            vy = enemy.get("base_dy", enemy["dy"]) * enemy["accel"]

            speed_cap = enemy_speed * 1.5  # from your game settings
            speed = math.hypot(vx, vy)
            if speed > speed_cap:
                scale = speed_cap / speed
                vx *= scale
                vy *= scale

            enemy["dx"] = vx
            enemy["dy"] = vy
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["base_dx"] *= -1
                bounced = True
                if enemy["x"] <= enemy_size: enemy["x"] = enemy_size/2 + enemy["base_dx"]
                elif enemy["x"] >= WIDTH - enemy_size: enemy["x"] = WIDTH - enemy_size/2 + enemy["base_dx"]
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["base_dy"] *= -1
                bounced = True
                if enemy["y"] <= enemy_size: enemy["y"] = enemy_size/2 + enemy["base_dy"]
                elif enemy["y"] >= HEIGHT - enemy_size: enemy["y"] = HEIGHT - enemy_size/2 + enemy["base_dy"]

            if bounced:
                enemy["accel"] = 0.0
                enemy["dx"] = 0
                enemy["dy"] = 0
                enemy["bounces"] += 1
                enemy["health"] -= 1

            if enemy["bounces"] >= accelerator_hp or enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 25:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= cold_hp: enemy_died = True

        


















        if player_alive and centered_rect_collision(player_x, player_y, player_size,
                                            enemy["x"], enemy["y"], enemy_size):
            if enemy["type"] == 17:
                if not player_moving:  # Only damages if player is still
                    if current_time >= invincible_until:
                        player_lives -= 1
                        p1_regen_block_until = score + regen_delay
                        damage_flash_time = current_time
                        invincible_until = current_time + invincibility_duration
                        enemies.remove(enemy)
                        if player_lives <= 0:
                            player_alive = False
                continue
            elif enemy["type"] == 16:
                if player_moving:  # Only damages if player is moving
                    if current_time >= invincible_until:
                        player_lives -= 1
                        p1_regen_block_until = score + regen_delay
                        damage_flash_time = current_time
                        invincible_until = current_time + invincibility_duration
                        enemies.remove(enemy)
                        if player_lives <= 0:
                            player_alive = False
                continue
            elif enemy["type"] == 15:
            # only reward and trigger shrinking once
                if not enemy.get("shrinking", False):
                    score += 1
                    if player_alive:
                        score_p1 = score
                    if player2_alive:
                        score_p2 = score
                    enemy["shrinking"] = True
                continue
            elif enemy["type"] == 21:
                # behaves like voodoo, dies instantly when touched
                score += 1
                if player_alive:
                    score_p1 = score
                if player2_alive:
                    score_p2 = score
                enemies.remove(enemy)
                continue
            elif enemy["type"] == 22:
                if current_time >= invincible_until:
                    player_lives -= 1
                    p1_regen_block_until = score + regen_delay
                    damage_flash_time = current_time
                    invincible_until = current_time + invincibility_duration
                    if player_lives <= 0:
                        player_alive = False
                    if enemy.get("laser_mode", True): enemies.remove(enemy)
                continue
            elif enemy["type"] == 25:
                slow_until = current_time + 10000
                player_speed = player_speed_base / 2
                player_frozen = True
            elif enemy["type"] == 3:
                player_lives = 0
                player_alive = False
            else:
                if current_time >= invincible_until:
                    player_lives -= 1
                    p1_regen_block_until = score + regen_delay
                    damage_flash_time = current_time
                    invincible_until = current_time + invincibility_duration
                    enemies.remove(enemy)
                    if player_lives <= 0:
                        player_alive = False
                continue
        if players == 2 and player2_alive and centered_rect_collision(player2_x, player2_y, player_size,
                                                                      enemy["x"], enemy["y"], enemy_size):
            if enemy["type"] == 17:
                if p2_dx == 0 and p2_dy == 0:  # not moving
                    if current_time >= player2_invincible_until:
                        player2_lives -= 1
                        p2_regen_block_until = score + regen_delay
                        player2_damage_flash_time = current_time
                        player2_invincible_until = current_time + invincibility_duration
                        enemies.remove(enemy)
                        if player2_lives <= 0:
                            player2_alive = False
                continue
            elif enemy["type"] == 16:
                if (p2_dx != 0 or p2_dy != 0):  # moving?
                    if current_time >= player2_invincible_until:
                        player2_lives -= 1
                        p2_regen_block_until = score + regen_delay
                        player2_damage_flash_time = current_time
                        player2_invincible_until = current_time + invincibility_duration
                        enemies.remove(enemy)
                        if player2_lives <= 0:
                            player2_alive = False
                continue
            elif enemy["type"] == 15:
                if not enemy.get("shrinking", False):
                    score += 1
                    if player_alive:
                        score_p1 = score
                    if player2_alive:
                        score_p2 = score
                    enemy["shrinking"] = True
                continue
            elif enemy["type"] == 21:
                score += 1
                if player_alive:
                    score_p1 = score
                if player2_alive:
                    score_p2 = score
                enemies.remove(enemy)
                continue
            elif enemy["type"] == 22:
                if current_time >= player2_invincible_until:
                    player2_lives -= 1
                    p2_regen_block_until = score + regen_delay
                    player2_damage_flash_time = current_time
                    player2_invincible_until = current_time + invincibility_duration
                    if player2_lives <= 0:
                        player2_alive = False
                    if enemy.get("laser_mode", True): enemies.remove(enemy)
                continue
            elif enemy["type"] == 25:
                player2_slow_until = current_time + 10000
                player2_speed = player2_speed_base / 2
                player2_frozen = True
            elif enemy["type"] == 3:
                player2_lives = 0
                player2_alive = False
            else:
                if current_time >= player2_invincible_until:
                    player2_lives -= 1
                    p2_regen_block_until = score + regen_delay
                    player2_damage_flash_time = current_time
                    player2_invincible_until = current_time + invincibility_duration
                    enemies.remove(enemy)
                    if player2_lives <= 0:
                        player2_alive = False
            continue
        if not player_alive and (players == 1 or not player2_alive):
            GAME_OVER(score, score_p1, score_p2)
            running = False
            break



        if enemy_died:
            if enemy in enemies:
                enemies.remove(enemy)
            score += 1
            if player_alive:
                score_p1 = score
            if player2_alive:
                score_p2 = score

            # Only regenerate if player is alive
            if player_alive and score >= p1_regen_block_until and player_lives < player_health_setting and regen_delay != 6767:
                player_lives += 1
                p1_regen_block_until = score + regen_delay
                heal_indicators.append({
                    "x": player_x,
                    "y": player_y,
                    "spawn_time": pygame.time.get_ticks()
                })

            if players == 2 and player2_alive and score >= p2_regen_block_until and player2_lives < player2_health_setting and regen_delay != 6767:
                player2_lives += 1
                p2_regen_block_until = score + regen_delay
                heal_indicators.append({
                    "x": player2_x,
                    "y": player2_y,
                    "spawn_time": pygame.time.get_ticks()
                })


    # --- Trail squares update ---
    new_trails = []
    for sq in trail_squares:
        if current_time - sq["spawn"] > trail_lifetime_ms:
            continue
        if player_alive and centered_rect_collision(player_x, player_y, player_size,
                                                    sq["x"], sq["y"], trail_size):
            if current_time >= invincible_until:
                player_lives -= 1
                p1_regen_block_until = score + regen_delay
                damage_flash_time = current_time
                invincible_until = current_time + invincibility_duration
                if player_lives <= 0:
                    player_alive = False
                    break
            sq["health"] -= 1
            if sq["health"] > 0:
                new_trails.append(sq)
            continue
        if players == 2 and player2_alive and centered_rect_collision(player2_x, player2_y, player_size,
                                                              sq["x"], sq["y"], trail_size):
            if current_time >= player2_invincible_until:
                player2_lives -= 1
                p2_regen_block_until = score + regen_delay
                player2_damage_flash_time = current_time
                player2_invincible_until = current_time + invincibility_duration
                if player2_lives <= 0:
                    player2_alive = False
                    break
            sq["health"] -= 1
            if sq["health"] > 0:
                new_trails.append(sq)
            continue
        new_trails.append(sq)
    trail_squares = new_trails

    # --- Projectiles movement ---
    new_projectiles = []
    for p in projectiles:
        # move (p stores center coordinates)
        p["x"] += p["dx"]
        p["y"] += p["dy"]

        # center-to-center collision test (more reliable with mixed coordinate conventions)
        player_cx = player_x + player_size / 2
        player_cy = player_y + player_size / 2
        proj_cx = p["x"]
        proj_cy = p["y"]

        # collision if distance < sum of radii
        if player_alive and centered_rect_collision(player_x, player_y, player_size,
                                                    p["x"] - projectile_size/2, p["y"] - projectile_size/2, projectile_size):
            if p.get("color") == CYAN:
                slow_until = current_time + 10000  # 10 seconds
                player_speed = player_speed_base / 2
                player_frozen = True
            else:
                if current_time >= invincible_until:
                    player_lives -= 1
                    p1_regen_block_until = score + regen_delay
                    damage_flash_time = current_time
                    invincible_until = current_time + invincibility_duration
                    if player_lives <= 0:
                        player_alive = False
                        break
                continue
        if players == 2:
            player2_cx = player2_x + player_size / 2
            player2_cy = player2_y + player_size / 2
            if player2_alive and distance(player2_cx, player2_cy, proj_cx, proj_cy) < (player_size / 2 + projectile_size / 2):
                if p.get("color") == CYAN:
                    player2_slow_until = current_time + 10000
                    player2_speed = player2_speed_base / 2
                    player2_frozen = True
                else:
                    if current_time >= player2_invincible_until:
                        player2_lives -= 1
                        p2_regen_block_until = score + regen_delay
                        player2_damage_flash_time = current_time
                        player2_invincible_until = current_time + invincibility_duration
                        if player2_lives <= 0:
                            player2_alive = False
                            break
                    continue

        # Keep projectile on screen (using center coords)
        if 0 - projectile_size < p["x"] < WIDTH + projectile_size and 0 - projectile_size < p["y"] < HEIGHT + projectile_size:
            new_projectiles.append(p)

    projectiles = new_projectiles

    # --- Drawing ---
    screen.fill(BLACK)

    # draw spawner
    pygame.draw.rect(screen, BLACK, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE))
    pygame.draw.rect(screen, CRISP, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE), 3)


        # --- FULL SPAWNER INDICATOR --
    center = (spawner_pos[0] + SPAWNER_SIZE // 2,
        spawner_pos[1] + SPAWNER_SIZE // 2)

    if spawn_enabled:
        # Normal pulse + rotation once spawning starts
        indicator_ratio = min(1.0, (current_time - last_spawn_time) / spawn_delay)

        def lerp_color(c1, c2, t):
            return tuple(int(c1[i] + (c2[i] - c1[i]) * t) for i in range(3))

        pulse_color = lerp_color(CRISP, RED, indicator_ratio)

        # Glow
        glow_size = SPAWNER_SIZE * 4
        glow_surface = pygame.Surface((glow_size, glow_size), pygame.SRCALPHA).convert_alpha()
        alpha = int(40 + 180 * indicator_ratio)
        start_glow_radius = SPAWNER_SIZE * 2
        end_glow_radius = SPAWNER_SIZE // 2
        glow_radius = int(start_glow_radius * (1 - indicator_ratio) + end_glow_radius * indicator_ratio)
        pygame.draw.circle(glow_surface, (*pulse_color, alpha),
                           (glow_size // 2, glow_size // 2), glow_radius)
        screen.blit(glow_surface, (center[0] - glow_size // 2, center[1] - glow_size // 2))

        # Rotating arcs
        angle_progress = current_time / 500.0
        arc_radius = glow_radius + 5
        for i in range(3):
            start_angle = angle_progress + i * (2 * math.pi / 3)
            end_angle = start_angle + math.pi / 4
            pygame.draw.arc(screen, pulse_color,
                            (center[0] - arc_radius, center[1] - arc_radius,
                             arc_radius * 2, arc_radius * 2),
                            start_angle, end_angle, 5)
    else:
        # Dormant look before player moves
        pulse_color = CRISP
        pygame.draw.rect(screen, pulse_color, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE), 3)
        pygame.draw.circle(screen, pulse_color, center, SPAWNER_SIZE // 2, 2)

    # --- spawner core ---
    pygame.draw.rect(screen, BLACK, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE))
    pygame.draw.rect(screen, CRISP, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE), 3)

    # draw trail squares
    for sq in trail_squares:
        pygame.draw.rect(screen, LAVA, (sq["x"] - trail_size // 2, sq["y"] - trail_size // 2, trail_size, trail_size))

    # draw projectiles
    for p in projectiles:
        color = p.get("color", HOT_PINK)
        draw_x = int(p["x"] - projectile_size / 2)
        draw_y = int(p["y"] - projectile_size / 2)
        pygame.draw.rect(screen, color, (draw_x - projectile_size//2, draw_y - projectile_size//2, projectile_size, projectile_size))

    # draw enemies
    for enemy in enemies:
        if enemy["type"] == 1: color = GRAY
        elif enemy["type"] == 2: color = MAROON
        elif enemy["type"] == 3: color = RED
        elif enemy["type"] == 4: color = TEAL
        elif enemy["type"] == 5: color = GREEN
        elif enemy["type"] == 6: color = PURPLE
        elif enemy["type"] == 7: color = LAVA
        elif enemy["type"] == 8:
            if player_frozen == True and enemy["target"] == 1: color = ICE
            elif player2_frozen == True and enemy["target"] == 2: color = ICE
            else: color = WHITE
        elif enemy["type"] == 9: color = LIME
        elif enemy["type"] == 10: color = HOT_PINK
        elif enemy["type"] == 11: color = BRONZE
        elif enemy["type"] == 12: color = INDIGO
        elif enemy["type"] == 13: color = SKY
        elif enemy["type"] == 14: color = BRICK
        elif enemy["type"] == 15: color = MAGENTA
        elif enemy["type"] == 16: color = BLUE
        elif enemy["type"] == 17: color = ORANGE
        elif enemy["type"] == 18: color = YELLOW
        elif enemy["type"] == 19: color = SILVER
        elif enemy["type"] == 20: color = CYAN
        elif enemy["type"] == 21: color = PINK
        elif enemy["type"] == 22: color = TURQUOISE
        elif enemy["type"] == 23: color = BROWN
        elif enemy["type"] == 24: color = TAN
        elif enemy["type"] == 25: color = ICE

        
        if enemy["type"] == 22 and enemy.get("laser_mode", False):
            if enemy["laser_orientation"] == "vertical":
                pygame.draw.rect(screen, TURQUOISE, (enemy["laser_x"]-enemy_size/2, 0, enemy_size, HEIGHT))

            elif enemy["laser_orientation"] == "horizontal":
                pygame.draw.rect(screen, TURQUOISE, (0, enemy["laser_y"]-enemy_size/2, WIDTH, enemy_size))
            continue


        sz = int(enemy.get("size", enemy_size))
        pygame.draw.rect(
            screen,
            color,
            (enemy["x"] - sz // 2,
             enemy["y"] - sz // 2,
             sz,
             sz)
        )

        if players == 1: enemy_text_color = BLACK
        elif players == 2:
            if enemy["type"] in targetting_enemies:
                if enemy["target"] == 1: enemy_text_color = RED
                elif enemy["target"] == 2: enemy_text_color = BLUE
            else: enemy_text_color = BLACK
        
        if enemy["type"] == 8:
            if enemy["target"] == 1: text_surface = enemy_font.render(str(player_lives), True, enemy_text_color)
            elif enemy["target"] == 2: text_surface = enemy_font.render(str(player2_lives), True, enemy_text_color)
        else:
            text_surface = enemy_font.render(str(max(int(enemy.get("health", 0)), 0)), True, enemy_text_color)

        text_rect = text_surface.get_rect(center=(enemy["x"], enemy["y"]))
        screen.blit(text_surface, text_rect)

    # draw player (flash red if hit)
    if player_alive:
        if current_time - damage_flash_time < 100:
            pygame.draw.rect(screen, RED, (player_x - player_size/2, player_y - player_size/2, player_size, player_size))
        elif player_frozen == True:
            pygame.draw.rect(screen, ICE, (player_x - player_size/2, player_y - player_size/2, player_size, player_size))
        else:
            pygame.draw.rect(screen, WHITE, (player_x - player_size/2, player_y - player_size/2, player_size, player_size))
        
    if players == 2 and player2_alive:
        if current_time - player2_damage_flash_time < 100:
            pygame.draw.rect(screen, RED, (player2_x - player_size/2, player2_y - player_size/2, player_size, player_size))
        elif player2_frozen == True:
            pygame.draw.rect(screen, ICE, (player2_x - player_size/2, player2_y - player_size/2, player_size, player_size))
        else:
            pygame.draw.rect(screen, WHITE, (player2_x - player_size/2, player2_y - player_size/2, player_size, player_size))

    new_heal_indicators = []
    for ind in heal_indicators:
        if current_time - ind["spawn_time"] < heal_duration:
            alpha = 255 * (1 - (current_time - ind["spawn_time"]) / heal_duration)  # optional fade
            s = pygame.Surface((player_size, player_size), pygame.SRCALPHA).convert_alpha()
            s.fill((0, 255, 0, int(alpha)))
            screen.blit(s, (ind["x"] - player_size/2, ind["y"] - player_size/2))
            new_heal_indicators.append(ind)
    heal_indicators = new_heal_indicators


    # draw player lives in center
    if players == 1: player_life_text = player_font.render(str(player_lives), True, BLACK)
    else: player_life_text = player_font.render(str(player_lives), True, RED)
    player_life_rect = player_life_text.get_rect(center=(player_x, player_y))
    screen.blit(player_life_text, player_life_rect)

    if players == 2:
        player2_life_text = player_font.render(str(player2_lives), True, BLUE)
        player2_life_rect = player2_life_text.get_rect(center=(player2_x, player2_y))
        screen.blit(player2_life_text, player2_life_rect)

    # draw HUD
    if players == 1:
        p1_text = font.render(f"Score: {score_p1}", True, WHITE)
        screen.blit(p1_text, (20, 20))
    elif players == 2:
        p1_text = font.render(f"P1 Score: {score_p1}", True, WHITE)
        screen.blit(p1_text, (20, 20))
        p2_text = font.render(f"P2 Score: {score_p2}", True, WHITE)
        screen.blit(p2_text, (WIDTH - 200, 20))
        
    pygame.display.flip()

pygame.quit()
