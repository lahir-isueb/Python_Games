import pygame
import random
import math
import pyperclip

pygame.init()
screen = pygame.display.set_mode((1920, 1080)) #(1920, 1080)
WIDTH, HEIGHT = screen.get_size()
pygame.display.set_caption("Pixels Of Evasion")

# --- GAME OVER SCREEN ---
def GAME_OVER(final_score, p1, p2): 
    screen.fill(BLACK)
    over_text = big_font.render("GAME OVER", True, RED)
    if players == 1: score_text = font.render(f"Final Score: {final_score}", True, WHITE)
    elif p1 > p2: score_text = font.render(f"Player 1 wins by {p1}-{p2}.", True, WHITE)
    elif p1 < p2: score_text = font.render(f"Player 2 wins by {p2}-{p1}.", True, WHITE)
    elif p1 == p2: score_text = font.render(f"Both players tied with a score of {final_score}", True, WHITE)
    instr_text = font.render("Press space to return", True, GRAY)

    screen.blit(over_text, over_text.get_rect(center=(WIDTH//2, HEIGHT//2 - 50)))
    screen.blit(score_text, score_text.get_rect(center=(WIDTH//2, HEIGHT//2)))
    screen.blit(instr_text, instr_text.get_rect(center=(WIDTH//2, HEIGHT//2 + 50)))

    pygame.display.flip()

    waiting = True
    while waiting:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                waiting = False
            if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                print(f"Final score: {final_score}")
                if players == 2:
                    print(f"Player 1 score: {p1}")
                    print(f"Player 2 score: {p2}")
                return "TITLE"
        clock.tick(15)

# --- Colors ---
WHITE = (255, 255, 255)
SILVER = (175, 175, 175)
GRAY = (100, 100, 100)
SHADOW = (50, 50, 50) #not used?
BLACK = (0, 0, 0) #not used?
BROWN = (108, 65, 0)
CRISP = (50, 0, 0) #not used?
MAROON = (120, 0, 0)
BRONZE = (140, 45, 0)
BRICK = (140, 65, 65)
RED = (255, 0, 0)
LAVA = (200, 60, 0)
SALMON = (255, 125, 125)
TAN = (155, 125, 95)
ORANGE = (255, 120, 0)
GOLD = (255, 195, 0)
SULFUR = (190, 190, 0)
OLIVE = (100, 100, 0)
YELLOW = (255, 255, 0)
CREAM = (255, 255, 180) #NOT USED
VOLT = (185, 255, 0)
LIME = (0, 255, 0)
GREEN = (0, 125, 0)
FOREST = (0, 60, 0) #NOT USED
TEAL = (0, 130, 130)
AQUA = (0, 190, 160)
TURQUOISE = (0, 255, 180)
ICE = (175, 255, 255)
CYAN = (0, 255, 255)
SKY = (125, 170, 225)
AZURE = (0, 140, 255)
BLUE = (0, 0, 255)
NAVY = (0, 0, 100)
INDIGO = (110, 0, 200)
MAUVE = (145, 95, 140)
LAVENDER = (210, 130, 255)
PURPLE = (162, 0, 255)
VIOLET = (130, 0, 130)
MAGENTA = (255, 0, 255)
PINK = (255, 140, 255)
HOT_PINK = (255, 0, 106)
CRIMSON = (190, 0, 60) #NOT USED

# --- Player Skins ---
p1_skin_color = 0
p2_skin_color = 0
player_skins = [WHITE, RED, BLUE,
                GRAY, WHITE, RED,
                BROWN, TAN, GREEN,
                RED, ORANGE, CYAN,
                LAVA, ORANGE, CRISP,
                ORANGE, YELLOW, RED,
                TAN, BROWN, ORANGE,
                YELLOW, TAN, SKY,
                LIME, GREEN, YELLOW,
                GREEN, LIME, BROWN,
                TEAL, BLUE, YELLOW,
                TURQUOISE, BLUE, GREEN,
                CYAN, TEAL, LAVENDER,
                SKY, WHITE, BLUE,
                BLUE, SKY, TURQUOISE,
                PURPLE, LAVENDER, HOT_PINK,
                MAUVE, LAVENDER, CYAN,
                LAVENDER, PURPLE, BLUE,
                PINK, HOT_PINK, PURPLE,
                HOT_PINK, PINK, VIOLET,
                SHADOW, PINK, CYAN]

# --- Spawner Size ---
SPAWNER_SIZE = 50

# --- Player ---
players = 1
player_size = 50
player_speed = 8
player_lives = 3 # ORIGINAL VALUE 3
player2_lives = 3 # ORIGINAL VALUE 3
player_alive = True
player2_alive = True
player_frozen = False
player2_frozen = False
slow_until = 0
player_speed_base = player_speed
player2_slow_until = 0
player2_speed_base = player_speed
player_speed = player_speed_base
player2_speed = player2_speed_base
freeze_duration = 10000

# --- Enemy ---
enemy_size = 50 # ORIGINAL VALUE 50
enemies = []
available_enemy_types = []
locked_enemy_types = []
targetting_enemies = [2, 8, 11, 12, 14, 15, 19, 26, 27, 29, 32, 33]

# --- Spawner ---
spawner_pos = (WIDTH // 2 - SPAWNER_SIZE // 2, HEIGHT // 2 - SPAWNER_SIZE // 2)
initial_spawn_delay = 2000 # ORIGINAL VALUE 2000
last_spawn_time = pygame.time.get_ticks()
enemy_speed = 5
min_spawn_delay = 500  # ORIGINAL VALUE 500
spawn_rate = 10

player_x = player_size // 2
player_y = spawner_pos[1] + SPAWNER_SIZE // 2

player2_x = WIDTH - player_size // 2
player2_y = spawner_pos[1] + SPAWNER_SIZE // 2

# --- Enemy Health ---
basic_hp = 5 # 1
homing_hp = 2 # 2
fatal_hp = 3 # 3
flow_hp = 3 # 4
sticky_hp = 7 # 5
gloomy_hp = 9 # 6
trail_hp = 3 # 7
impostor_hp = 5 # 8
splitter_hp = 3 # 9
bomb_hp = 8 # 10
shooter_hp = 4 # 11
sniper_hp = 1 # 12
speedy_hp = 5 # 13
shotgun_hp = 4 # 14
voodoo_hp = 5 # 15
blind_hp = 6 # 16
motion_hp = 7 # 17
charger_hp = 3 # 18
rapidshooter_hp = 1 # 19
frostbite_hp = 4 # 20
addictive_hp = 7 # 21
laser_hp = 3 # 22
hardened_hp = 30 # 23
accelerator_hp = 5 # 24
cold_hp = 6 # 25
tracer_hp = 1 # 26
savage_hp = 2 # 27
teleporter_hp = 6 # 28
haunter_hp = 3 # 29
stream_hp = 4 # 30
sensitive_hp = 10 # 31
burstshooter_hp = 3 # 32
stickyshooter_hp = 2 # 33
sparker_hp = 1 # 34
annihilator_hp = 3 # 35
frostbeam_hp = 1 # 36

# --- Enemy Damage ---
enemy_damage = 1

# --- Scoring System & Text Size ---
score = 0
truescore = 0
score_p1 = truescore
score_p2 = truescore
font = pygame.font.SysFont(None, 40)
big_font = pygame.font.SysFont(None, 120)
enemy_font = pygame.font.SysFont(None, int(0.96 * enemy_size))
player_font = pygame.font.SysFont(None, int(0.96 * player_size))
regen_delay = 50
p1_regen_block_until = 0
p2_regen_block_until = 0
unlock_scores = []


# --- Clock ---
clock = pygame.time.Clock()
FPS = 60

# --- Trail ---
trail_squares = []
trail_lifetime_ms = 3000 # this is the length of the trail
trail_interval_ms = 450 # this is the distance between trail particles
trail_size = 10


# --- Projectiles ---
projectiles = []
projectile_damage = 1
bomb_projectile_speed = 2.5
shooter_projectile_speed = 5
sniper_projectile_speed = 10
shotgun_projectile_speed = 5
rapidshooter_projectile_speed = 5
burstshooter_projectile_speed = 5
frostbite_projectile_speed = 5
sparker_projectile_speed = 5
annihilator_projectile_speed = 10
projectile_size = 10
shooter_delay = 3000
sniper_delay = 5500
shotgun_delay = 7500
rapidshooter_delay = 200
burstshooter_delay = 3000
stickyshooter_delay = 600
sparker_delay = 100
projectile_fire_rate = 10
burst = 10
bomb_projectile_amount = 8
frostbite_projectile_amount = 32
annihilator_projectile_amount = 32
extra_sniper_damage = 1

# --- Split Amount ---
split_amount = 2

# --- Acceleration ---
accel = 0.0
accel_rate = 0.02

# --- Harden ---
harden_break = 10

# --- Turn Speed ---
chase_turn = 5

# --- Stickiness ---
stickiness = 2000

# --- Addiction ---
addictive_pull_radius = 300
addictive_pull_strength = 10

# --- Laser ---
laser_damage = 1
laser_duration = 2000

# --- Player damage & heal flash ---
damage_flash_time = 0
player2_damage_flash_time = 0
heal_flash_time = 0
player2_heal_flash_time = 0
invincible_until = 0
player2_invincible_until = 0
invincibility_duration = 1000
player2_last_regen = 0
player2_regen_cooldown = 3000


def centered_rect_collision(x1, y1, s1, x2, y2, s2):
    half1 = s1 / 2
    half2 = s2 / 2
    return (
        abs(x1 - x2) < half1 + half2 and
        abs(y1 - y2) < half1 + half2
    )

def rotate_toward(current_angle, target_angle, turn_speed):
    difference = (target_angle - current_angle + math.pi) % (2 * math.pi) - math.pi
    if abs(difference) < turn_speed:
        return target_angle
    return current_angle + turn_speed * (1 if difference > 0 else -1)

def distance(x1, y1, x2, y2):
    return math.hypot(x2 - x1, y2 - y1)

def get_target_position(enemy):
    if enemy["target"] == 1:
        return player_x, player_y
    elif enemy["target"] == 2:
        return player2_x, player2_y
    else:
        return None

def reset_game_state():
    global player_x, player_y, player2_x, player2_y
    global player_lives, player2_lives
    global player_alive, player2_alive
    global enemies, projectiles, trail_squares
    global score, truescore, score_p1, score_p2
    global last_spawn_time, invincible_until, player2_invincible_until
    global spawn_enabled, p1_ready, p2_ready
    global damage_flash_time, player2_damage_flash_time
    global heal_flash_time, player2_heal_flash_time
    global player_frozen, player2_frozen, slow_until, player2_slow_until
    global player_speed, player2_speed
    player_x = player_size // 2
    player_y = spawner_pos[1] + SPAWNER_SIZE // 2
    player2_x = WIDTH - player_size // 2
    player2_y = spawner_pos[1] + SPAWNER_SIZE // 2
    player_lives = player_health_setting
    player2_lives = player_health_setting
    player_alive = True
    player2_alive = True
    enemies.clear()
    projectiles.clear()
    trail_squares.clear()
    score = 0
    truescore = 0
    score_p1 = 0
    score_p2 = 0
    last_spawn_time = pygame.time.get_ticks()
    damage_flash_time = 0
    player2_damage_flash_time = 0
    heal_flash_time = 0
    player2_heal_flash_time = 0
    player_frozen = False
    player2_frozen = False
    slow_until = 0
    player2_slow_until = 0
    player_speed = player_speed_base
    player2_speed = player2_speed_base
    invincible_until = 0
    player2_invincible_until = 0
    spawn_enabled = False
    p1_ready = False
    p2_ready = False

player_size_setting = 50
enemy_size_setting = 50
projectile_size_setting = 10
min_spawn_delay_setting = 500
max_spawn_delay_setting = 2000
spawn_delay_change_setting = 10
player_speed_setting = 8
enemy_speed_setting = 5
projectile_speed_setting = 5
regen_delay_setting = 50
player_health_setting = 3
trail_duration_setting = 3000
trail_distance_setting = 450
freeze_duration_setting = 10000
invincibility_duration_setting = 1000
chaser_turn_amount_setting = 5
enemy_stick_setting = 2000
projectile_fire_rate_setting = 10
enemy_damage_setting = 1
burst_setting = 10
enemy_unlock_setting = 100
projectile_damage_setting = 1
enemy_locks = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
               1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
               1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
               1, 1, 1, 1, 1, 1]

basic_hp_setting = 5
homing_hp_setting = 2
fatal_hp_setting = 3
flow_hp_setting = 3
sticky_hp_setting = 7
gloomy_hp_setting = 9
trail_hp_setting = 3
impostor_hp_setting = 5
splitter_hp_setting = 3
split_amount_setting = 2
bomb_hp_setting = 8
bomb_projectile_amount_setting = 8
shooter_hp_setting = 4
sniper_hp_setting = 1
extra_sniper_damage_setting = 1
speedy_hp_setting = 5
shotgun_hp_setting = 4
shotgun_bullets_setting = 5
voodoo_hp_setting = 5
blind_hp_setting = 6
motion_hp_setting = 7
charger_hp_setting = 3
rapidshooter_hp_setting = 1
frostbite_hp_setting = 4
frostbite_projectile_amount_setting = 32
addictive_hp_setting = 7
addictive_pull_strength_setting = 10
addictive_pull_radius_setting = 300
laser_hp_setting = 3
laser_damage_setting = 1
laser_duration_setting = 2000
hardened_hp_setting = 30
harden_break_setting = 10
accelerator_hp_setting = 5
cold_hp_setting = 6
tracer_hp_setting = 1
savage_hp_setting = 2
teleporter_hp_setting = 6
haunter_hp_setting = 3
stream_hp_setting = 4
sensitive_hp_setting = 10
burstshooter_hp_setting = 3
stickyshooter_hp_setting = 2
sparker_hp_setting = 1
annihilator_hp_setting = 3
annihilator_projectile_amount_setting = 32
frostbeam_hp_setting = 1

modifiers = [0]

def enemy_lock_setup(elock, enumber):
    global available_enemy_types
    global locked_enemy_types
    if elock == 0: available_enemy_types.append(enumber + 1)
    elif elock == 1: locked_enemy_types.append(enumber + 1)

def SETTINGS():
    global player_size_setting
    global enemy_size_setting
    global projectile_size_setting
    global min_spawn_delay_setting
    global max_spawn_delay_setting
    global spawn_delay_change_setting
    global player_speed_setting
    global enemy_speed_setting
    global projectile_speed_setting
    global regen_delay_setting
    global player_health_setting
    global trail_duration_setting
    global trail_distance_setting
    global freeze_duration_setting
    global invincibility_duration_setting
    global chaser_turn_amount_setting
    global enemy_stick_setting
    global projectile_fire_rate_setting
    global enemy_damage_setting
    global burst_setting
    global enemy_unlock_setting
    global projectile_damage_setting
    global enemy_locks
    
    global basic_hp_setting
    global homing_hp_setting
    global fatal_hp_setting
    global flow_hp_setting
    global sticky_hp_setting
    global gloomy_hp_setting
    global trail_hp_setting
    global impostor_hp_setting
    global splitter_hp_setting
    global split_amount_setting
    global bomb_hp_setting
    global bomb_projectile_amount_setting
    global shooter_hp_setting
    global sniper_hp_setting
    global extra_sniper_damage_setting
    global speedy_hp_setting
    global shotgun_hp_setting
    global shotgun_bullets_setting
    global voodoo_hp_setting
    global blind_hp_setting
    global motion_hp_setting
    global charger_hp_setting
    global rapidshooter_hp_setting
    global frostbite_hp_setting
    global frostbite_projectile_amount_setting
    global addictive_hp_setting
    global addictive_pull_strength_setting
    global addictive_pull_radius_setting
    global laser_hp_setting
    global laser_damage_setting
    global laser_duration_setting
    global hardened_hp_setting
    global harden_break_setting
    global accelerator_hp_setting
    global cold_hp_setting
    global tracer_hp_setting
    global savage_hp_setting
    global teleporter_hp_setting
    global haunter_hp_setting
    global stream_hp_setting
    global sensitive_hp_setting
    global burstshooter_hp_setting
    global stickyshooter_hp_setting
    global sparker_hp_setting
    global annihilator_hp_setting
    global annihilator_projectile_amount_setting
    global frostbeam_hp_setting
    global modifiers

    SLIST = ["presets", "modes",
             "starting sd", "ending sd", "sd change", "enemy unlock",
             "hp", "regen", "invincibility",
             "player speed", "player size",
             "enemy speed", "enemy size", "enemy damage",
             "projectile speed", "projectile fire rate",
             "trail duration", "trail distance",
             "proj/trail damage", "proj/trail size", 
             "wallstick", "unhardening rate", "chaser turnspeed", 
             "laser damage", "laser duration",
             "freeze status",
             "set locks",
             
             "basic", "speedy", "sticky", "charger", "gloomy", "flow",
             "blind", "motion", "cold", "accelerator", "teleporter",
             "hardened", "homing", "splitter", "splitter splits",
             "trail", "shooter", "burstshooter", "burst", "rapidshooter",
             "sniper", "xtra sniper damage", "shotgun", "shotgun bullets",
             "bomb", "bomb bullets",
             "frostbite", "frostbite bullets", "sparker",
             "laser", "fatal",
             "addictive", "addictive strength", "addictive radius",
             "voodoo", "impostor",
             
             "stream", "sensitive", "savage", "haunter", "tracer",
             "stickyshooter", "frostbeam", "annihilator", "annihilator bullets",
             
             "all one color"
             ]

    running = True
    button_offset = 10
    scroll_y = 0
    scroll_speed = 25
    max_scroll = 180+len(SLIST)*60 - HEIGHT
    enemy_locking_labels = ["Starter", "Locked", "Banned"]
    scrollbar_width = 20
    scrollbar_margin = 50
    scrollbar_track = pygame.Rect(
        WIDTH - scrollbar_width - scrollbar_margin,
        50,
        scrollbar_width,
        HEIGHT - 100
    )

    dragging_scrollbar = False

    player_size_plus_button = pygame.Rect(WIDTH//2 + 120, HEIGHT//2 - 20, 60, 60)
    player_size_minus_button = pygame.Rect(WIDTH//2 - 180, HEIGHT//2 - 20, 60, 60)
    
    while running:
        screen.fill(BLACK)
        text = big_font.render("Settings", True, WHITE)
        screen.blit(text, (50, 50 + scroll_y))
        info = font.render("Press Escape to return", True, SILVER)
        screen.blit(info, (500, 80 + scroll_y))
        mouse_pos = pygame.mouse.get_pos()
        mouse_click = pygame.mouse.get_pressed()[0]
        plus_txt = font.render("+", True, BLACK)
        minus_txt = font.render("-", True, BLACK)


        content_height = max_scroll + HEIGHT
        view_height = HEIGHT

        handle_height = max(
            40,
            int(scrollbar_track.height * (view_height / content_height))
        )

        scroll_ratio = -scroll_y / max_scroll if max_scroll > 0 else 0

        handle_y = scrollbar_track.y + int(
            scroll_ratio * (scrollbar_track.height - handle_height)
        )

        scrollbar_handle = pygame.Rect(
            scrollbar_track.x,
            handle_y,
            scrollbar_width,
            handle_height
        )


        default_set_text = font.render("Set To Default", True, WHITE)
        default_set_button = pygame.Rect(50, 180+SLIST.index("presets")*60 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, GRAY, default_set_button, border_radius=0)
        screen.blit(default_set_text, default_set_text.get_rect(center=default_set_button.center))
        if default_set_button.collidepoint(mouse_pos) and mouse_click:
            player_size_setting = 50
            enemy_size_setting = 50
            projectile_size_setting = 10
            min_spawn_delay_setting = 500
            max_spawn_delay_setting = 2000
            spawn_delay_change_setting = 10
            player_speed_setting = 8
            enemy_speed_setting = 5
            projectile_speed_setting = 5
            regen_delay_setting = 50
            player_health_setting = 3
            trail_duration_setting = 3000
            trail_distance_setting = 450
            freeze_duration_setting = 10000
            invincibility_duration_setting = 1000
            chaser_turn_amount_setting = 5
            enemy_stick_setting = 2000
            projectile_fire_rate_setting = 10
            enemy_damage_setting = 1
            burst_setting = 10
            enemy_unlock_setting = 100
            projectile_damage_setting = 1
            enemy_locks = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                           1, 1, 1, 1, 1, 1]

            basic_hp_setting = 5
            homing_hp_setting = 2
            fatal_hp_setting = 3
            flow_hp_setting = 3
            sticky_hp_setting = 7
            gloomy_hp_setting = 9
            trail_hp_setting = 3
            impostor_hp_setting = 5
            splitter_hp_setting = 3
            split_amount_setting = 2
            bomb_hp_setting = 8
            bomb_projectile_amount_setting = 8
            shooter_hp_setting = 4
            sniper_hp_setting = 1
            extra_sniper_damage_setting = 1
            speedy_hp_setting = 5
            shotgun_hp_setting = 4
            shotgun_bullets_setting = 5
            voodoo_hp_setting = 5
            blind_hp_setting = 6
            motion_hp_setting = 7
            charger_hp_setting = 3
            rapidshooter_hp_setting = 1
            frostbite_hp_setting = 4
            frostbite_projectile_amount_setting = 32
            addictive_hp_setting = 7
            addictive_pull_strength_setting = 10
            addictive_pull_radius_setting = 300
            laser_hp_setting = 3
            laser_damage_setting = 1
            laser_duration_setting = 2000
            hardened_hp_setting = 40
            harden_break_setting = 10
            accelerator_hp_setting = 5
            cold_hp_setting = 6
            tracer_hp_setting = 1
            savage_hp_setting = 2
            teleporter_hp_setting = 6
            haunter_hp_setting = 3
            stream_hp_setting = 4
            sensitive_hp_setting = 10
            burstshooter_hp_setting = 3
            stickyshooter_hp_setting = 2
            sparker_hp_setting = 1
            annihilator_hp_setting = 3
            annihilator_projectile_amount_setting = 32
            frostbeam_hp_setting = 1
            modifiers = [0]
            pygame.time.delay(200)


        copy_seed_text = font.render("Copy Settings", True, WHITE)
        copy_seed_button = pygame.Rect(300, 180+SLIST.index("presets")*60 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, SILVER, copy_seed_button, border_radius=0)
        screen.blit(copy_seed_text, copy_seed_text.get_rect(center=copy_seed_button.center))
        if copy_seed_button.collidepoint(mouse_pos) and mouse_click:
            copied = ""
            
            copy_setting_list = [player_size_setting, enemy_size_setting, projectile_size_setting,
                                 min_spawn_delay_setting, max_spawn_delay_setting, spawn_delay_change_setting,
                                 player_speed_setting, enemy_speed_setting, projectile_speed_setting,
                                 regen_delay_setting, trail_duration_setting, trail_distance_setting,
                                 freeze_duration_setting, invincibility_duration_setting,
                                 chaser_turn_amount_setting, enemy_stick_setting,
                                 projectile_fire_rate_setting, enemy_damage_setting, burst_setting,
                                 enemy_unlock_setting, projectile_damage_setting,
                                 enemy_locks[0], enemy_locks[1], enemy_locks[2], enemy_locks[3],
                                 enemy_locks[4], enemy_locks[5], enemy_locks[6], enemy_locks[7],
                                 enemy_locks[8], enemy_locks[9], enemy_locks[10], enemy_locks[11],
                                 enemy_locks[12], enemy_locks[13], enemy_locks[14], enemy_locks[15],
                                 enemy_locks[16], enemy_locks[17], enemy_locks[18], enemy_locks[19],
                                 enemy_locks[20], enemy_locks[21], enemy_locks[22], enemy_locks[23],
                                 enemy_locks[24], enemy_locks[25], enemy_locks[26], enemy_locks[27],
                                 enemy_locks[28], enemy_locks[29], enemy_locks[30], enemy_locks[31],
                                 enemy_locks[32], enemy_locks[33], enemy_locks[34], enemy_locks[35],
                                 basic_hp_setting, homing_hp_setting, fatal_hp_setting,
                                 flow_hp_setting, sticky_hp_setting, gloomy_hp_setting,
                                 trail_hp_setting, impostor_hp_setting, splitter_hp_setting,
                                 split_amount_setting, bomb_hp_setting, bomb_projectile_amount_setting,
                                 shooter_hp_setting, sniper_hp_setting, extra_sniper_damage_setting,
                                 speedy_hp_setting, shotgun_hp_setting, shotgun_bullets_setting,
                                 voodoo_hp_setting, blind_hp_setting, motion_hp_setting, charger_hp_setting,
                                 rapidshooter_hp_setting, frostbite_hp_setting,
                                 frostbite_projectile_amount_setting, addictive_hp_setting,
                                 addictive_pull_strength_setting, addictive_pull_radius_setting,
                                 laser_hp_setting, laser_damage_setting, laser_duration_setting,
                                 hardened_hp_setting, harden_break_setting, accelerator_hp_setting,
                                 cold_hp_setting, tracer_hp_setting, savage_hp_setting,
                                 teleporter_hp_setting, haunter_hp_setting, stream_hp_setting,
                                 sensitive_hp_setting, burstshooter_hp_setting, stickyshooter_hp_setting,
                                 sparker_hp_setting, annihilator_hp_setting,
                                 annihilator_projectile_amount_setting, frostbeam_hp_setting, modifiers[0],
                                 player_health_setting]

            
            for x in copy_setting_list: copied += f"{x}."
            pyperclip.copy(copied)
            pygame.time.delay(200)

        paste_seed_text = font.render("Paste Settings", True, WHITE)
        paste_seed_button = pygame.Rect(550, 180+SLIST.index("presets")*60 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, SILVER, paste_seed_button, border_radius=0)
        screen.blit(paste_seed_text, paste_seed_text.get_rect(center=paste_seed_button.center))
        if paste_seed_button.collidepoint(mouse_pos) and mouse_click:
            pasted = pyperclip.paste()
            scount = 0
            chara = ""
            for c in pasted:
                if c == ".":
                    match scount:
                        case 0: player_size_setting = int(chara)
                        case 1: enemy_size_setting = int(chara)
                        case 2: projectile_size_setting = int(chara)
                        case 3: min_spawn_delay_setting = int(chara)
                        case 4: max_spawn_delay_setting = int(chara)
                        case 5: spawn_delay_change_setting = int(chara)
                        case 6: player_speed_setting = int(chara)
                        case 7: enemy_speed_setting = int(chara)
                        case 8: projectile_speed_setting = int(chara)
                        case 9: regen_delay_setting = int(chara)
                        case 10: trail_duration_setting = int(chara)
                        case 11: trail_distance_setting = int(chara)
                        case 12: freeze_duration_setting = int(chara)
                        case 13: invincibility_duration_setting = int(chara)
                        case 14: chaser_turn_amount_setting = int(chara)
                        case 15: enemy_stick_setting = int(chara)
                        case 16: projectile_fire_rate_setting = int(chara)
                        case 17: enemy_damage_setting = int(chara)
                        case 18: burst_setting = int(chara)
                        case 19: enemy_unlock_setting = int(chara)
                        case 20: projectile_damage_setting = int(chara)
                        case 21: enemy_locks[0] = int(chara)
                        case 22: enemy_locks[1] = int(chara)
                        case 23: enemy_locks[2] = int(chara)
                        case 24: enemy_locks[3] = int(chara)
                        case 25: enemy_locks[4] = int(chara)
                        case 26: enemy_locks[5] = int(chara)
                        case 27: enemy_locks[6] = int(chara)
                        case 28: enemy_locks[7] = int(chara)
                        case 29: enemy_locks[8] = int(chara)
                        case 30: enemy_locks[9] = int(chara)
                        case 31: enemy_locks[10] = int(chara)
                        case 32: enemy_locks[11] = int(chara)
                        case 33: enemy_locks[12] = int(chara)
                        case 34: enemy_locks[13] = int(chara)
                        case 35: enemy_locks[14] = int(chara)
                        case 36: enemy_locks[15] = int(chara)
                        case 37: enemy_locks[16] = int(chara)
                        case 38: enemy_locks[17] = int(chara)
                        case 39: enemy_locks[18] = int(chara)
                        case 40: enemy_locks[19] = int(chara)
                        case 41: enemy_locks[20] = int(chara)
                        case 42: enemy_locks[21] = int(chara)
                        case 43: enemy_locks[22] = int(chara)
                        case 44: enemy_locks[23] = int(chara)
                        case 45: enemy_locks[24] = int(chara)
                        case 46: enemy_locks[25] = int(chara)
                        case 47: enemy_locks[26] = int(chara)
                        case 48: enemy_locks[27] = int(chara)
                        case 49: enemy_locks[28] = int(chara)
                        case 50: enemy_locks[29] = int(chara)
                        case 51: enemy_locks[30] = int(chara)
                        case 52: enemy_locks[31] = int(chara)
                        case 53: enemy_locks[32] = int(chara)
                        case 54: enemy_locks[33] = int(chara)
                        case 55: enemy_locks[34] = int(chara)
                        case 56: enemy_locks[35] = int(chara)
                        case 57: basic_hp_setting = int(chara)
                        case 58: homing_hp_setting = int(chara)
                        case 59: fatal_hp_setting = int(chara)
                        case 60: flow_hp_setting = int(chara)
                        case 61: sticky_hp_setting = int(chara)
                        case 62: gloomy_hp_setting = int(chara)
                        case 63: trail_hp_setting = int(chara)
                        case 64: impostor_hp_setting = int(chara)
                        case 65: splitter_hp_setting = int(chara)
                        case 66: split_amount_setting = int(chara)
                        case 67: bomb_hp_setting = int(chara)
                        case 68: bomb_projectile_amount_setting = int(chara)
                        case 69: shooter_hp_setting = int(chara)
                        case 70: sniper_hp_setting = int(chara)
                        case 71: extra_sniper_damage_setting = int(chara)
                        case 72: speedy_hp_setting = int(chara)
                        case 73: shotgun_hp_setting = int(chara)
                        case 74: shotgun_bullets_setting = int(chara)
                        case 75: voodoo_hp_setting = int(chara)
                        case 76: blind_hp_setting = int(chara)
                        case 77: motion_hp_setting = int(chara)
                        case 78: charger_hp_setting = int(chara)
                        case 79: rapidshooter_hp_setting = int(chara)
                        case 80: frostbite_hp_setting = int(chara)
                        case 81: frostbite_projectile_amount_setting = int(chara)
                        case 82: addictive_hp_setting = int(chara)
                        case 83: addictive_pull_strength_setting = int(chara)
                        case 84: addictive_pull_radius_setting = int(chara)
                        case 85: laser_hp_setting = int(chara)
                        case 86: laser_damage_setting = int(chara)
                        case 87: laser_duration_setting = int(chara)
                        case 88: hardened_hp_setting = int(chara)
                        case 89: harden_break_setting = int(chara)
                        case 90: accelerator_hp_setting = int(chara)
                        case 91: cold_hp_setting = int(chara)
                        case 92: tracer_hp_setting = int(chara)
                        case 93: savage_hp_setting = int(chara)
                        case 94: teleporter_hp_setting = int(chara)
                        case 95: haunter_hp_setting = int(chara)
                        case 96: stream_hp_setting = int(chara)
                        case 97: sensitive_hp_setting = int(chara)
                        case 98: burstshooter_hp_setting = int(chara)
                        case 99: stickyshooter_hp_setting = int(chara)
                        case 100: sparker_hp_setting = int(chara)
                        case 101: annihilator_hp_setting = int(chara)
                        case 102: annihilator_projectile_amount_setting = int(chara)
                        case 103: frostbeam_hp_setting = int(chara)
                        case 104: modifiers[0] = int(chara)
                        case 105: player_health_setting = int(chara)
                    scount += 1
                    chara = ""
                else: chara += c
            pygame.time.delay(200)        

        shooter_set_text = font.render("Bullet Survival", True, WHITE)
        shooter_set_button = pygame.Rect(50, 180+SLIST.index("modes")*60 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, MAROON, shooter_set_button, border_radius=0)
        screen.blit(shooter_set_text, shooter_set_text.get_rect(center=shooter_set_button.center))
        if shooter_set_button.collidepoint(mouse_pos) and mouse_click:
            regen_delay_setting = 10
            player_health_setting = 99
            trail_distance_setting = 50
            invincibility_duration_setting = 0
            projectile_damage_setting = 1
            enemy_stick_setting = 5000
            extra_sniper_damage_setting = 5
            projectile_fire_rate_setting = 40
            enemy_damage_setting = 10
            burst_setting = 10
            enemy_locks = [2, 2, 2, 2, 2, 2, 0, 2, 2, 0,
                           0, 0, 2, 0, 2, 2, 2, 2, 0, 2,
                           2, 1, 2, 2, 2, 1, 2, 2, 2, 2,
                           2, 0, 0, 0, 1, 1]
            bomb_projectile_amount_setting = 64
            shotgun_bullets_setting = 21
            laser_damage_setting = 1
            annihilator_projectile_amount_setting = 128
            pygame.time.delay(200)


        frostgame_set_text = font.render("Frostbite Frenzy", True, TEAL)
        frostgame_set_button = pygame.Rect(300, 180+SLIST.index("modes")*60 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, CYAN, frostgame_set_button, border_radius=0)
        screen.blit(frostgame_set_text, frostgame_set_text.get_rect(center=frostgame_set_button.center))
        if frostgame_set_button.collidepoint(mouse_pos) and mouse_click:
            projectile_size_setting = 50
            projectile_speed_setting = 1
            freeze_duration_setting = 0
            enemy_unlock_setting = 200
            projectile_damage_setting = 1
            enemy_locks = [2, 2, 2, 0, 2, 2, 2, 1, 2, 2,
                           2, 2, 2, 2, 2, 2, 2, 2, 2, 0,
                           2, 2, 2, 0, 2, 2, 2, 2, 1, 2,
                           2, 2, 2, 2, 2, 1]

            flow_hp_setting = 3
            impostor_hp_setting = 5
            frostbite_hp_setting = 4
            frostbite_projectile_amount_setting = 128
            accelerator_hp_setting = 5
            haunter_hp_setting = 2
            frostbeam_hp_setting = 1
            modifiers = [0]
            pygame.time.delay(200)

        max_spawn_delay_label = font.render("Starting Spawn Delay: " + str(max_spawn_delay_setting), True, MAROON)
        screen.blit(max_spawn_delay_label, (50, 180+SLIST.index("starting sd")*60 + scroll_y))
        max_spawn_delay_minus_button = pygame.Rect(500, 180+SLIST.index("starting sd")*60 - button_offset + scroll_y, 50, 50)
        max_spawn_delay_plus_button = pygame.Rect(560, 180+SLIST.index("starting sd")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, max_spawn_delay_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=max_spawn_delay_plus_button.center))
        pygame.draw.rect(screen, RED, max_spawn_delay_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=max_spawn_delay_minus_button.center))
        if max_spawn_delay_plus_button.collidepoint(mouse_pos) and mouse_click:
            max_spawn_delay_setting += 100
            if max_spawn_delay_setting > 5000:
                max_spawn_delay_setting = 5000
            pygame.time.delay(50)
        if max_spawn_delay_minus_button.collidepoint(mouse_pos) and mouse_click:
            max_spawn_delay_setting -= 100
            if max_spawn_delay_setting < 100 or max_spawn_delay_setting < min_spawn_delay_setting:
                max_spawn_delay_setting += 100
            pygame.time.delay(50)

            

        min_spawn_delay_label = font.render("Ending Spawn Delay: " + str(min_spawn_delay_setting), True, MAROON)
        screen.blit(min_spawn_delay_label, (50, 180+SLIST.index("ending sd")*60 + scroll_y))
        min_spawn_delay_minus_button = pygame.Rect(500, 180+SLIST.index("ending sd")*60 - button_offset + scroll_y, 50, 50)
        min_spawn_delay_plus_button = pygame.Rect(560, 180+SLIST.index("ending sd")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, min_spawn_delay_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=min_spawn_delay_plus_button.center))
        pygame.draw.rect(screen, RED, min_spawn_delay_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=min_spawn_delay_minus_button.center))
        if min_spawn_delay_plus_button.collidepoint(mouse_pos) and mouse_click:
            min_spawn_delay_setting += 100
            if min_spawn_delay_setting > 5000 or min_spawn_delay_setting > max_spawn_delay_setting:
                min_spawn_delay_setting -= 100
            pygame.time.delay(50)
        if min_spawn_delay_minus_button.collidepoint(mouse_pos) and mouse_click:
            min_spawn_delay_setting -= 100
            if min_spawn_delay_setting < 100:
                min_spawn_delay_setting = 100
            pygame.time.delay(50)


        


        spawn_delay_change_label = font.render("Spawn Delay Change: " + str(spawn_delay_change_setting), True, MAROON)
        screen.blit(spawn_delay_change_label, (50, 180+SLIST.index("sd change")*60 + scroll_y))
        spawn_delay_change_minus_button = pygame.Rect(500, 180+SLIST.index("sd change")*60 - button_offset + scroll_y, 50, 50)
        spawn_delay_change_plus_button = pygame.Rect(560, 180+SLIST.index("sd change")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, spawn_delay_change_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=spawn_delay_change_plus_button.center))
        pygame.draw.rect(screen, RED, spawn_delay_change_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=spawn_delay_change_minus_button.center))
        if spawn_delay_change_plus_button.collidepoint(mouse_pos) and mouse_click:
            spawn_delay_change_setting += 2
            if spawn_delay_change_setting > 100:
                spawn_delay_change_setting = 100
            pygame.time.delay(50)
        if spawn_delay_change_minus_button.collidepoint(mouse_pos) and mouse_click:
            spawn_delay_change_setting -= 2
            if spawn_delay_change_setting < 2:
                spawn_delay_change_setting = 2
            pygame.time.delay(50)


        player_health_label = font.render("Player Health: " + str(player_health_setting), True, LIME)
        screen.blit(player_health_label, (50, 180+SLIST.index("hp")*60 + scroll_y))
        player_health_minus_button = pygame.Rect(500, 180+SLIST.index("hp")*60 - button_offset + scroll_y, 50, 50)
        player_health_plus_button = pygame.Rect(560, 180+SLIST.index("hp")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, player_health_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=player_health_plus_button.center))
        pygame.draw.rect(screen, RED, player_health_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=player_health_minus_button.center))
        if player_health_plus_button.collidepoint(mouse_pos) and mouse_click:
            player_health_setting += 1
            if player_health_setting > 99:
                player_health_setting = 99
            pygame.time.delay(50)
        if player_health_minus_button.collidepoint(mouse_pos) and mouse_click:
            player_health_setting -= 1
            if player_health_setting < 1:
                player_health_setting = 1
            pygame.time.delay(50)



        if regen_delay_setting == 6969: regen_delay_label = font.render("No Regen", True, LIME)
        else: regen_delay_label = font.render("Regen Delay: " + str(regen_delay_setting), True, LIME)
        screen.blit(regen_delay_label, (50, 180+SLIST.index("regen")*60 + scroll_y))
        regen_delay_minus_button = pygame.Rect(500, 180+SLIST.index("regen")*60 - button_offset + scroll_y, 50, 50)
        regen_delay_plus_button = pygame.Rect(560, 180+SLIST.index("regen")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, regen_delay_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=regen_delay_plus_button.center))
        pygame.draw.rect(screen, RED, regen_delay_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=regen_delay_minus_button.center))
        if regen_delay_plus_button.collidepoint(mouse_pos) and mouse_click:
            regen_delay_setting += 5
            if regen_delay_setting > 150:
                regen_delay_setting = 6969
            pygame.time.delay(50)
        if regen_delay_minus_button.collidepoint(mouse_pos) and mouse_click:
            if regen_delay_setting == 6969:
                regen_delay_setting = 150
            else: regen_delay_setting -= 5
            if regen_delay_setting < 5:
                regen_delay_setting = 5
            pygame.time.delay(50)



        invincibility_duration_label = font.render("Invincibility Duration: " + str(invincibility_duration_setting), True, LIME)
        screen.blit(invincibility_duration_label, (50, 180+SLIST.index("invincibility")*60 + scroll_y))
        invincibility_duration_minus_button = pygame.Rect(500, 180+SLIST.index("invincibility")*60 - button_offset + scroll_y, 50, 50)
        invincibility_duration_plus_button = pygame.Rect(560, 180+SLIST.index("invincibility")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, invincibility_duration_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=invincibility_duration_plus_button.center))
        pygame.draw.rect(screen, RED, invincibility_duration_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=invincibility_duration_minus_button.center))
        if invincibility_duration_plus_button.collidepoint(mouse_pos) and mouse_click:
            invincibility_duration_setting += 100
            if invincibility_duration_setting > 5000:
                invincibility_duration_setting = 5000
            pygame.time.delay(50)
        if invincibility_duration_minus_button.collidepoint(mouse_pos) and mouse_click:
            invincibility_duration_setting -= 100
            if invincibility_duration_setting < 0:
                invincibility_duration_setting = 0
            pygame.time.delay(50)



        freeze_duration_label = font.render("Freeze Duration: " + str(freeze_duration_setting), True, PURPLE)
        screen.blit(freeze_duration_label, (50, 180+SLIST.index("freeze status")*60 + scroll_y))
        freeze_duration_minus_button = pygame.Rect(500, 180+SLIST.index("freeze status")*60 - button_offset + scroll_y, 50, 50)
        freeze_duration_plus_button = pygame.Rect(560, 180+SLIST.index("freeze status")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, freeze_duration_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=freeze_duration_plus_button.center))
        pygame.draw.rect(screen, RED, freeze_duration_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=freeze_duration_minus_button.center))
        if freeze_duration_plus_button.collidepoint(mouse_pos) and mouse_click:
            freeze_duration_setting += 500
            if freeze_duration_setting > 20000:
                freeze_duration_setting = 20000
            pygame.time.delay(50)
        if freeze_duration_minus_button.collidepoint(mouse_pos) and mouse_click:
            freeze_duration_setting -= 500
            if freeze_duration_setting < 0:
                freeze_duration_setting = 0
            pygame.time.delay(50)


        player_speed_label = font.render("Player Speed: " + str(player_speed_setting), True, SKY)
        screen.blit(player_speed_label, (50, 180+SLIST.index("player speed")*60 + scroll_y))
        player_speed_minus_button = pygame.Rect(500, 180+SLIST.index("player speed")*60 - button_offset + scroll_y, 50, 50)
        player_speed_plus_button = pygame.Rect(560, 180+SLIST.index("player speed")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, player_speed_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=player_speed_plus_button.center))
        pygame.draw.rect(screen, RED, player_speed_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=player_speed_minus_button.center))
        if player_speed_plus_button.collidepoint(mouse_pos) and mouse_click:
            player_speed_setting += 1
            if player_speed_setting > 20:
                player_speed_setting = 20
            pygame.time.delay(50)
        if player_speed_minus_button.collidepoint(mouse_pos) and mouse_click:
            player_speed_setting -= 1
            if player_speed_setting < 1:
                player_speed_setting = 1
            pygame.time.delay(50)


        player_size_label = font.render("Player Size: " + str(player_size_setting), True, SKY)
        screen.blit(player_size_label, (50, 180+SLIST.index("player size")*60 + scroll_y))
        player_size_minus_button = pygame.Rect(500, 180+SLIST.index("player size")*60 - button_offset + scroll_y, 50, 50)
        player_size_plus_button = pygame.Rect(560, 180+SLIST.index("player size")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, player_size_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=player_size_plus_button.center))
        pygame.draw.rect(screen, RED, player_size_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=player_size_minus_button.center))
        if player_size_plus_button.collidepoint(mouse_pos) and mouse_click:
            player_size_setting += 5
            if player_size_setting > 150:
                player_size_setting = 150
            pygame.time.delay(50)
        if player_size_minus_button.collidepoint(mouse_pos) and mouse_click:
            player_size_setting -= 5
            if player_size_setting < 10:
                player_size_setting = 10
            pygame.time.delay(50)



        enemy_speed_label = font.render("Enemy Speed: " + str(enemy_speed_setting), True, RED)
        screen.blit(enemy_speed_label, (50, 180+SLIST.index("enemy speed")*60 + scroll_y))
        enemy_speed_minus_button = pygame.Rect(500, 180+SLIST.index("enemy speed")*60 - button_offset + scroll_y, 50, 50)
        enemy_speed_plus_button = pygame.Rect(560, 180+SLIST.index("enemy speed")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, enemy_speed_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=enemy_speed_plus_button.center))
        pygame.draw.rect(screen, RED, enemy_speed_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=enemy_speed_minus_button.center))
        if enemy_speed_plus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_speed_setting += 1
            if enemy_speed_setting > 20:
                enemy_speed_setting = 20
            pygame.time.delay(50)
        if enemy_speed_minus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_speed_setting -= 1
            if enemy_speed_setting < 1:
                enemy_speed_setting = 1
            pygame.time.delay(50)




        enemy_size_label = font.render("Enemy Size: " + str(enemy_size_setting), True, RED)
        screen.blit(enemy_size_label, (50, 180+SLIST.index("enemy size")*60 + scroll_y))
        enemy_size_minus_button = pygame.Rect(500, 180+SLIST.index("enemy size")*60 - button_offset + scroll_y, 50, 50)
        enemy_size_plus_button = pygame.Rect(560, 180+SLIST.index("enemy size")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, enemy_size_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=enemy_size_plus_button.center))
        pygame.draw.rect(screen, RED, enemy_size_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=enemy_size_minus_button.center))
        if enemy_size_plus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_size_setting += 5
            if enemy_size_setting > 150:
                enemy_size_setting = 150
            pygame.time.delay(50)
        if enemy_size_minus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_size_setting -= 5
            if enemy_size_setting < 10:
                enemy_size_setting = 10
            pygame.time.delay(50)



        projectile_speed_label = font.render("Projectile Speed: " + str(projectile_speed_setting), True, ORANGE)
        screen.blit(projectile_speed_label, (50, 180+SLIST.index("projectile speed")*60 + scroll_y))
        projectile_speed_minus_button = pygame.Rect(500, 180+SLIST.index("projectile speed")*60 - button_offset + scroll_y, 50, 50)
        projectile_speed_plus_button = pygame.Rect(560, 180+SLIST.index("projectile speed")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, projectile_speed_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=projectile_speed_plus_button.center))
        pygame.draw.rect(screen, RED, projectile_speed_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=projectile_speed_minus_button.center))
        if projectile_speed_plus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_speed_setting += 1
            if projectile_speed_setting > 25:
                projectile_speed_setting = 25
            pygame.time.delay(50)
        if projectile_speed_minus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_speed_setting -= 1
            if projectile_speed_setting < 1:
                projectile_speed_setting = 1
            pygame.time.delay(50)



        projectile_fire_rate_label = font.render("Projectile Fire Rate: " + str(projectile_fire_rate_setting), True, ORANGE)
        screen.blit(projectile_fire_rate_label, (50, 180+SLIST.index("projectile fire rate")*60 + scroll_y))
        projectile_fire_rate_minus_button = pygame.Rect(500, 180+SLIST.index("projectile fire rate")*60 - button_offset + scroll_y, 50, 50)
        projectile_fire_rate_plus_button = pygame.Rect(560, 180+SLIST.index("projectile fire rate")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, projectile_fire_rate_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=projectile_fire_rate_plus_button.center))
        pygame.draw.rect(screen, RED, projectile_fire_rate_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=projectile_fire_rate_minus_button.center))
        if projectile_fire_rate_plus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_fire_rate_setting += 1
            if projectile_fire_rate_setting > 40:
                projectile_fire_rate_setting = 40
            pygame.time.delay(50)
        if projectile_fire_rate_minus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_fire_rate_setting -= 1
            if projectile_fire_rate_setting < 1:
                projectile_fire_rate_setting = 1
            pygame.time.delay(50)

        

        projectile_size_label = font.render("Projectile/Trail Size: " + str(projectile_size_setting), True, ORANGE)
        screen.blit(projectile_size_label, (50, 180+SLIST.index("proj/trail size")*60 + scroll_y))
        projectile_size_minus_button = pygame.Rect(500, 180+SLIST.index("proj/trail size")*60 - button_offset + scroll_y, 50, 50)
        projectile_size_plus_button = pygame.Rect(560, 180+SLIST.index("proj/trail size")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, projectile_size_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=projectile_size_plus_button.center))
        pygame.draw.rect(screen, RED, projectile_size_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=projectile_size_minus_button.center))
        if projectile_size_plus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_size_setting += 2
            if projectile_size_setting > 50:
                projectile_size_setting = 50
            pygame.time.delay(50)
        if projectile_size_minus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_size_setting -= 2
            if projectile_size_setting < 2:
                projectile_size_setting = 2
            pygame.time.delay(50)


        projectile_damage_label = font.render("Projectile/Trail Damage: " + str(projectile_damage_setting), True, ORANGE)
        screen.blit(projectile_damage_label, (50, 180+SLIST.index("proj/trail damage")*60 + scroll_y))
        projectile_damage_minus_button = pygame.Rect(500, 180+SLIST.index("proj/trail damage")*60 - button_offset + scroll_y, 50, 50)
        projectile_damage_plus_button = pygame.Rect(560, 180+SLIST.index("proj/trail damage")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, projectile_damage_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=projectile_damage_plus_button.center))
        pygame.draw.rect(screen, RED, projectile_damage_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=projectile_damage_minus_button.center))
        if projectile_damage_plus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_damage_setting += 1
            if projectile_damage_setting > 99:
                projectile_damage_setting = 99
            pygame.time.delay(50)
        if projectile_damage_minus_button.collidepoint(mouse_pos) and mouse_click:
            projectile_damage_setting -= 1
            if projectile_damage_setting < 1:
                projectile_damage_setting = 1
            pygame.time.delay(50)



        trail_duration_label = font.render("Trail Duration: " + str(trail_duration_setting), True, ORANGE)
        screen.blit(trail_duration_label, (50, 180+SLIST.index("trail duration")*60 + scroll_y))
        trail_duration_minus_button = pygame.Rect(500, 180+SLIST.index("trail duration")*60 - button_offset + scroll_y, 50, 50)
        trail_duration_plus_button = pygame.Rect(560, 180+SLIST.index("trail duration")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, trail_duration_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=trail_duration_plus_button.center))
        pygame.draw.rect(screen, RED, trail_duration_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=trail_duration_minus_button.center))
        if trail_duration_plus_button.collidepoint(mouse_pos) and mouse_click:
            trail_duration_setting += 500
            if trail_duration_setting > 16000:
                trail_duration_setting = 16000
            pygame.time.delay(50)
        if trail_duration_minus_button.collidepoint(mouse_pos) and mouse_click:
            trail_duration_setting -= 500
            if trail_duration_setting < 500:
                trail_duration_setting = 500
            pygame.time.delay(50)


        trail_distance_label = font.render("Trail Distance: " + str(trail_distance_setting), True, ORANGE)
        screen.blit(trail_distance_label, (50, 180+SLIST.index("trail distance")*60 + scroll_y))
        trail_distance_minus_button = pygame.Rect(500, 180+SLIST.index("trail distance")*60 - button_offset + scroll_y, 50, 50)
        trail_distance_plus_button = pygame.Rect(560, 180+SLIST.index("trail distance")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, trail_distance_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=trail_distance_plus_button.center))
        pygame.draw.rect(screen, RED, trail_distance_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=trail_distance_minus_button.center))
        if trail_distance_plus_button.collidepoint(mouse_pos) and mouse_click:
            trail_distance_setting += 100
            if trail_distance_setting > 950:
                trail_distance_setting = 950
            pygame.time.delay(50)
        if trail_distance_minus_button.collidepoint(mouse_pos) and mouse_click:
            trail_distance_setting -= 100
            if trail_distance_setting < 50:
                trail_distance_setting = 50
            pygame.time.delay(50)



        chaser_turn_amount_label = font.render("Chaser Turn Speed: " + str(chaser_turn_amount_setting), True, SALMON)
        screen.blit(chaser_turn_amount_label, (50, 180+SLIST.index("chaser turnspeed")*60 + scroll_y))
        chaser_turn_amount_minus_button = pygame.Rect(500, 180+SLIST.index("chaser turnspeed")*60 - button_offset + scroll_y, 50, 50)
        chaser_turn_amount_plus_button = pygame.Rect(560, 180+SLIST.index("chaser turnspeed")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, chaser_turn_amount_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=chaser_turn_amount_plus_button.center))
        pygame.draw.rect(screen, RED, chaser_turn_amount_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=chaser_turn_amount_minus_button.center))
        if chaser_turn_amount_plus_button.collidepoint(mouse_pos) and mouse_click:
            chaser_turn_amount_setting += 1
            if chaser_turn_amount_setting > 15:
                chaser_turn_amount_setting = 15
            pygame.time.delay(50)
        if chaser_turn_amount_minus_button.collidepoint(mouse_pos) and mouse_click:
            chaser_turn_amount_setting -= 1
            if chaser_turn_amount_setting < 1:
                chaser_turn_amount_setting = 1
            pygame.time.delay(50)



        enemy_stick_label = font.render("Wall Stick Duration: " + str(enemy_stick_setting), True, GREEN)
        screen.blit(enemy_stick_label, (50, 180+SLIST.index("wallstick")*60 + scroll_y))
        enemy_stick_minus_button = pygame.Rect(500, 180+SLIST.index("wallstick")*60 - button_offset + scroll_y, 50, 50)
        enemy_stick_plus_button = pygame.Rect(560, 180+SLIST.index("wallstick")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, enemy_stick_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=enemy_stick_plus_button.center))
        pygame.draw.rect(screen, RED, enemy_stick_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=enemy_stick_minus_button.center))
        if enemy_stick_plus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_stick_setting += 500
            if enemy_stick_setting > 5000:
                enemy_stick_setting = 5000
            pygame.time.delay(50)
        if enemy_stick_minus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_stick_setting -= 500
            if enemy_stick_setting < 500:
                enemy_stick_setting = 500
            pygame.time.delay(50)



        enemy_unlock_label = font.render("Enemy Unlock: " + str(enemy_unlock_setting), True, MAROON)
        screen.blit(enemy_unlock_label, (50, 180+SLIST.index("enemy unlock")*60 + scroll_y))
        enemy_unlock_minus_button = pygame.Rect(500, 180+SLIST.index("enemy unlock")*60 - button_offset + scroll_y, 50, 50)
        enemy_unlock_plus_button = pygame.Rect(560, 180+SLIST.index("enemy unlock")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, enemy_unlock_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=enemy_unlock_plus_button.center))
        pygame.draw.rect(screen, RED, enemy_unlock_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=enemy_unlock_minus_button.center))
        if enemy_unlock_plus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_unlock_setting += 10
            if enemy_unlock_setting > 300:
                enemy_unlock_setting = 300
            pygame.time.delay(50)
        if enemy_unlock_minus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_unlock_setting -= 10
            if enemy_unlock_setting < 10:
                enemy_unlock_setting = 10
            pygame.time.delay(50)



        all_starter_text = font.render("All Starter", True, WHITE)
        all_starter_button = pygame.Rect(50, 180+SLIST.index("set locks")*60 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, GREEN, all_starter_button, border_radius=0)
        screen.blit(all_starter_text, all_starter_text.get_rect(center=all_starter_button.center))
        if all_starter_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = 0
            pygame.time.delay(200)
        all_locked_text = font.render("All Locked", True, WHITE)
        all_locked_button = pygame.Rect(300, 180+SLIST.index("set locks")*60 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, SULFUR, all_locked_button, border_radius=0)
        screen.blit(all_locked_text, all_locked_text.get_rect(center=all_locked_button.center))
        if all_locked_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = 1
            pygame.time.delay(200)
        all_banned_text = font.render("All Banned", True, WHITE)
        all_banned_button = pygame.Rect(550, 180+SLIST.index("set locks")*60 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, RED, all_banned_button, border_radius=0)
        screen.blit(all_banned_text, all_banned_text.get_rect(center=all_banned_button.center))
        if all_banned_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = 2
            pygame.time.delay(200)
        all_random_text = font.render("All Random", True, WHITE)
        all_random_button = pygame.Rect(800, 180+SLIST.index("set locks")*60 - button_offset + scroll_y, 225, 50)
        pygame.draw.rect(screen, PURPLE, all_random_button, border_radius=0)
        screen.blit(all_random_text, all_random_text.get_rect(center=all_random_button.center))
        if all_random_button.collidepoint(mouse_pos) and mouse_click:
            for en in range(0, len(enemy_locks)):
                enemy_locks[en] = random.randrange(3)
            pygame.time.delay(200)



        basic_hp_label = font.render("Basic Enemy - HP: " + str(basic_hp_setting), True, GRAY)
        screen.blit(basic_hp_label, (50, 180+SLIST.index("basic")*60 + scroll_y))
        basic_hp_minus_button = pygame.Rect(500, 180+SLIST.index("basic")*60 - button_offset + scroll_y, 50, 50)
        basic_hp_plus_button = pygame.Rect(560, 180+SLIST.index("basic")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, basic_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=basic_hp_plus_button.center))
        pygame.draw.rect(screen, RED, basic_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=basic_hp_minus_button.center))
        if basic_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            basic_hp_setting += 1
            if basic_hp_setting > 99:
                basic_hp_setting = 99
            pygame.time.delay(50)
        if basic_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            basic_hp_setting -= 1
            if basic_hp_setting < 1:
                basic_hp_setting = 1
            pygame.time.delay(50)
        basic_locks_text = font.render(enemy_locking_labels[enemy_locks[0]], True, BLACK)
        basic_locks_button = pygame.Rect(650, 180+SLIST.index("basic")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, GRAY, basic_locks_button, border_radius=0)
        screen.blit(basic_locks_text, basic_locks_text.get_rect(center=basic_locks_button.center))
        if basic_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[0] > 1: enemy_locks[0] = 0
            else: enemy_locks[0] = enemy_locks[0] + 1
            pygame.time.delay(200)



        homing_hp_label = font.render("Homing Enemy - HP: " + str(homing_hp_setting), True, SALMON)
        screen.blit(homing_hp_label, (50, 180+SLIST.index("homing")*60 + scroll_y))
        homing_hp_minus_button = pygame.Rect(500, 180+SLIST.index("homing")*60 - button_offset + scroll_y, 50, 50)
        homing_hp_plus_button = pygame.Rect(560, 180+SLIST.index("homing")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, homing_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=homing_hp_plus_button.center))
        pygame.draw.rect(screen, RED, homing_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=homing_hp_minus_button.center))
        if homing_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            homing_hp_setting += 1
            if homing_hp_setting > 99:
                homing_hp_setting = 99
            pygame.time.delay(50)
        if homing_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            homing_hp_setting -= 1
            if homing_hp_setting < 1:
                homing_hp_setting = 1
            pygame.time.delay(50)
        homing_locks_text = font.render(enemy_locking_labels[enemy_locks[1]], True, BLACK)
        homing_locks_button = pygame.Rect(650, 180+SLIST.index("homing")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, SALMON, homing_locks_button, border_radius=0)
        screen.blit(homing_locks_text, homing_locks_text.get_rect(center=homing_locks_button.center))
        if homing_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[1] > 1: enemy_locks[1] = 0
            else: enemy_locks[1] = enemy_locks[1] + 1
            pygame.time.delay(200)


        fatal_hp_label = font.render("Fatal Enemy - HP: " + str(fatal_hp_setting), True, RED)
        screen.blit(fatal_hp_label, (50, 180+SLIST.index("fatal")*60 + scroll_y))
        fatal_hp_minus_button = pygame.Rect(500, 180+SLIST.index("fatal")*60 - button_offset + scroll_y, 50, 50)
        fatal_hp_plus_button = pygame.Rect(560, 180+SLIST.index("fatal")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, fatal_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=fatal_hp_plus_button.center))
        pygame.draw.rect(screen, RED, fatal_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=fatal_hp_minus_button.center))
        if fatal_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            fatal_hp_setting += 1
            if fatal_hp_setting > 99:
                fatal_hp_setting = 99
            pygame.time.delay(50)
        if fatal_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            fatal_hp_setting -= 1
            if fatal_hp_setting < 1:
                fatal_hp_setting = 1
            pygame.time.delay(50)
        fatal_locks_text = font.render(enemy_locking_labels[enemy_locks[2]], True, BLACK)
        fatal_locks_button = pygame.Rect(650, 180+SLIST.index("fatal")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, RED, fatal_locks_button, border_radius=0)
        screen.blit(fatal_locks_text, fatal_locks_text.get_rect(center=fatal_locks_button.center))
        if fatal_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[2] > 1: enemy_locks[2] = 0
            else: enemy_locks[2] = enemy_locks[2] + 1
            pygame.time.delay(200)



        flow_hp_label = font.render("Flow Enemy - HP: " + str(flow_hp_setting), True, AZURE)
        screen.blit(flow_hp_label, (50, 180+SLIST.index("flow")*60 + scroll_y))
        flow_hp_minus_button = pygame.Rect(500, 180+SLIST.index("flow")*60 - button_offset + scroll_y, 50, 50)
        flow_hp_plus_button = pygame.Rect(560, 180+SLIST.index("flow")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, flow_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=flow_hp_plus_button.center))
        pygame.draw.rect(screen, RED, flow_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=flow_hp_minus_button.center))
        if flow_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            flow_hp_setting += 1
            if flow_hp_setting > 99:
                flow_hp_setting = 99
            pygame.time.delay(50)
        if flow_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            flow_hp_setting -= 1
            if flow_hp_setting < 1:
                flow_hp_setting = 1
            pygame.time.delay(50)
        flow_locks_text = font.render(enemy_locking_labels[enemy_locks[3]], True, BLACK)
        flow_locks_button = pygame.Rect(650, 180+SLIST.index("flow")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, AZURE, flow_locks_button, border_radius=0)
        screen.blit(flow_locks_text, flow_locks_text.get_rect(center=flow_locks_button.center))
        if flow_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[3] > 1: enemy_locks[3] = 0
            else: enemy_locks[3] = enemy_locks[3] + 1
            pygame.time.delay(200)



        sticky_hp_label = font.render("Sticky Enemy - HP: " + str(sticky_hp_setting), True, GREEN)
        screen.blit(sticky_hp_label, (50, 180+SLIST.index("sticky")*60 + scroll_y))
        sticky_hp_minus_button = pygame.Rect(500, 180+SLIST.index("sticky")*60 - button_offset + scroll_y, 50, 50)
        sticky_hp_plus_button = pygame.Rect(560, 180+SLIST.index("sticky")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, sticky_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=sticky_hp_plus_button.center))
        pygame.draw.rect(screen, RED, sticky_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=sticky_hp_minus_button.center))
        if sticky_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            sticky_hp_setting += 1
            if sticky_hp_setting > 99:
                sticky_hp_setting = 99
            pygame.time.delay(50)
        if sticky_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            sticky_hp_setting -= 1
            if sticky_hp_setting < 1:
                sticky_hp_setting = 1
            pygame.time.delay(50)
        sticky_locks_text = font.render(enemy_locking_labels[enemy_locks[4]], True, BLACK)
        sticky_locks_button = pygame.Rect(650, 180+SLIST.index("sticky")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, GREEN, sticky_locks_button, border_radius=0)
        screen.blit(sticky_locks_text, sticky_locks_text.get_rect(center=sticky_locks_button.center))
        if sticky_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[4] > 1: enemy_locks[4] = 0
            else: enemy_locks[4] = enemy_locks[4] + 1
            pygame.time.delay(200)



        gloomy_hp_label = font.render("Gloomy Enemy - HP: " + str(gloomy_hp_setting), True, VIOLET)
        screen.blit(gloomy_hp_label, (50, 180+SLIST.index("gloomy")*60 + scroll_y))
        gloomy_hp_minus_button = pygame.Rect(500, 180+SLIST.index("gloomy")*60 - button_offset + scroll_y, 50, 50)
        gloomy_hp_plus_button = pygame.Rect(560, 180+SLIST.index("gloomy")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, gloomy_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=gloomy_hp_plus_button.center))
        pygame.draw.rect(screen, RED, gloomy_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=gloomy_hp_minus_button.center))
        if gloomy_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            gloomy_hp_setting += 1
            if gloomy_hp_setting > 99:
                gloomy_hp_setting = 99
            pygame.time.delay(50)
        if gloomy_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            gloomy_hp_setting -= 1
            if gloomy_hp_setting < 1:
                gloomy_hp_setting = 1
            pygame.time.delay(50)
        gloomy_locks_text = font.render(enemy_locking_labels[enemy_locks[5]], True, BLACK)
        gloomy_locks_button = pygame.Rect(650, 180+SLIST.index("gloomy")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, VIOLET, gloomy_locks_button, border_radius=0)
        screen.blit(gloomy_locks_text, gloomy_locks_text.get_rect(center=gloomy_locks_button.center))
        if gloomy_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[5] > 1: enemy_locks[5] = 0
            else: enemy_locks[5] = enemy_locks[5] + 1
            pygame.time.delay(200)



        trail_hp_label = font.render("Trail Enemy - HP: " + str(trail_hp_setting), True, LAVA)
        screen.blit(trail_hp_label, (50, 180+SLIST.index("trail")*60 + scroll_y))
        trail_hp_minus_button = pygame.Rect(500, 180+SLIST.index("trail")*60 - button_offset + scroll_y, 50, 50)
        trail_hp_plus_button = pygame.Rect(560, 180+SLIST.index("trail")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, trail_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=trail_hp_plus_button.center))
        pygame.draw.rect(screen, RED, trail_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=trail_hp_minus_button.center))
        if trail_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            trail_hp_setting += 1
            if trail_hp_setting > 99:
                trail_hp_setting = 99
            pygame.time.delay(50)
        if trail_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            trail_hp_setting -= 1
            if trail_hp_setting < 1:
                trail_hp_setting = 1
            pygame.time.delay(50)
        trail_locks_text = font.render(enemy_locking_labels[enemy_locks[6]], True, BLACK)
        trail_locks_button = pygame.Rect(650, 180+SLIST.index("trail")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, LAVA, trail_locks_button, border_radius=0)
        screen.blit(trail_locks_text, trail_locks_text.get_rect(center=trail_locks_button.center))
        if trail_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[6] > 1: enemy_locks[6] = 0
            else: enemy_locks[6] = enemy_locks[6] + 1
            pygame.time.delay(200)



        impostor_hp_label = font.render("Impostor Enemy - HP: " + str(impostor_hp_setting), True, WHITE)
        screen.blit(impostor_hp_label, (50, 180+SLIST.index("impostor")*60 + scroll_y))
        impostor_hp_minus_button = pygame.Rect(500, 180+SLIST.index("impostor")*60 - button_offset + scroll_y, 50, 50)
        impostor_hp_plus_button = pygame.Rect(560, 180+SLIST.index("impostor")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, impostor_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=impostor_hp_plus_button.center))
        pygame.draw.rect(screen, RED, impostor_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=impostor_hp_minus_button.center))
        if impostor_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            impostor_hp_setting += 1
            if impostor_hp_setting > 99:
                impostor_hp_setting = 99
            pygame.time.delay(50)
        if impostor_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            impostor_hp_setting -= 1
            if impostor_hp_setting < 1:
                impostor_hp_setting = 1
            pygame.time.delay(50)
        impostor_locks_text = font.render(enemy_locking_labels[enemy_locks[7]], True, RED)
        impostor_locks_button = pygame.Rect(650, 180+SLIST.index("impostor")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, WHITE, impostor_locks_button, border_radius=0)
        screen.blit(impostor_locks_text, impostor_locks_text.get_rect(center=impostor_locks_button.center))
        if impostor_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[7] > 1: enemy_locks[7] = 0
            else: enemy_locks[7] = enemy_locks[7] + 1
            pygame.time.delay(200)



        splitter_hp_label = font.render("Splitter Enemy - HP: " + str(splitter_hp_setting), True, LIME)
        screen.blit(splitter_hp_label, (50, 180+SLIST.index("splitter")*60 + scroll_y))
        splitter_hp_minus_button = pygame.Rect(500, 180+SLIST.index("splitter")*60 - button_offset + scroll_y, 50, 50)
        splitter_hp_plus_button = pygame.Rect(560, 180+SLIST.index("splitter")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, splitter_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=splitter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, splitter_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=splitter_hp_minus_button.center))
        if splitter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            splitter_hp_setting += 1
            if splitter_hp_setting > 99:
                splitter_hp_setting = 99
            pygame.time.delay(50)
        if splitter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            splitter_hp_setting -= 1
            if splitter_hp_setting < 1:
                splitter_hp_setting = 1
            pygame.time.delay(50)
        splitter_locks_text = font.render(enemy_locking_labels[enemy_locks[8]], True, BLACK)
        splitter_locks_button = pygame.Rect(650, 180+SLIST.index("splitter")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, LIME, splitter_locks_button, border_radius=0)
        screen.blit(splitter_locks_text, splitter_locks_text.get_rect(center=splitter_locks_button.center))
        if splitter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[8] > 1: enemy_locks[8] = 0
            else: enemy_locks[8] = enemy_locks[8] + 1
            pygame.time.delay(200)



        split_amount_label = font.render("Splits: " + str(split_amount_setting), True, LIME)
        screen.blit(split_amount_label, (276, 180+SLIST.index("splitter splits")*60 + scroll_y))
        split_amount_minus_button = pygame.Rect(500, 180+SLIST.index("splitter splits")*60 - button_offset + scroll_y, 50, 50)
        split_amount_plus_button = pygame.Rect(560, 180+SLIST.index("splitter splits")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, split_amount_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=split_amount_plus_button.center))
        pygame.draw.rect(screen, RED, split_amount_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=split_amount_minus_button.center))
        if split_amount_plus_button.collidepoint(mouse_pos) and mouse_click:
            split_amount_setting += 1
            if split_amount_setting > 20:
                split_amount_setting = 20
            pygame.time.delay(50)
        if split_amount_minus_button.collidepoint(mouse_pos) and mouse_click:
            split_amount_setting -= 1
            if split_amount_setting < 1:
                split_amount_setting += 1
            pygame.time.delay(50)



        bomb_hp_label = font.render("Bomb Enemy - HP: " + str(bomb_hp_setting), True, MAUVE)
        screen.blit(bomb_hp_label, (50, 180+SLIST.index("bomb")*60 + scroll_y))
        bomb_hp_minus_button = pygame.Rect(500, 180+SLIST.index("bomb")*60 - button_offset + scroll_y, 50, 50)
        bomb_hp_plus_button = pygame.Rect(560, 180+SLIST.index("bomb")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, bomb_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=bomb_hp_plus_button.center))
        pygame.draw.rect(screen, RED, bomb_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=bomb_hp_minus_button.center))
        if bomb_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            bomb_hp_setting += 1
            if bomb_hp_setting > 99:
                bomb_hp_setting = 99
            pygame.time.delay(50)
        if bomb_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            bomb_hp_setting -= 1
            if bomb_hp_setting < 1:
                bomb_hp_setting = 1
            pygame.time.delay(50)
        bomb_locks_text = font.render(enemy_locking_labels[enemy_locks[9]], True, BLACK)
        bomb_locks_button = pygame.Rect(650, 180+SLIST.index("bomb")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, MAUVE, bomb_locks_button, border_radius=0)
        screen.blit(bomb_locks_text, bomb_locks_text.get_rect(center=bomb_locks_button.center))
        if bomb_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[9] > 1: enemy_locks[9] = 0
            else: enemy_locks[9] = enemy_locks[9] + 1
            pygame.time.delay(200)



        bomb_projectile_amount_label = font.render("Bullets: " + str(bomb_projectile_amount_setting), True, MAUVE)
        screen.blit(bomb_projectile_amount_label, (251, 180+SLIST.index("bomb bullets")*60 + scroll_y))
        bomb_projectile_amount_minus_button = pygame.Rect(500, 180+SLIST.index("bomb bullets")*60 - button_offset + scroll_y, 50, 50)
        bomb_projectile_amount_plus_button = pygame.Rect(560, 180+SLIST.index("bomb bullets")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, bomb_projectile_amount_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=bomb_projectile_amount_plus_button.center))
        pygame.draw.rect(screen, RED, bomb_projectile_amount_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=bomb_projectile_amount_minus_button.center))
        if bomb_projectile_amount_plus_button.collidepoint(mouse_pos) and mouse_click:
            bomb_projectile_amount_setting += 4
            if bomb_projectile_amount_setting > 64:
                bomb_projectile_amount_setting = 64
            pygame.time.delay(50)
        if bomb_projectile_amount_minus_button.collidepoint(mouse_pos) and mouse_click:
            bomb_projectile_amount_setting -= 4
            if bomb_projectile_amount_setting < 4:
                bomb_projectile_amount_setting = 4
            pygame.time.delay(50)



        shooter_hp_label = font.render("Shooter Enemy - HP: " + str(shooter_hp_setting), True, BRONZE)
        screen.blit(shooter_hp_label, (50, 180+SLIST.index("shooter")*60 + scroll_y))
        shooter_hp_minus_button = pygame.Rect(500, 180+SLIST.index("shooter")*60 - button_offset + scroll_y, 50, 50)
        shooter_hp_plus_button = pygame.Rect(560, 180+SLIST.index("shooter")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, shooter_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=shooter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, shooter_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=shooter_hp_minus_button.center))
        if shooter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            shooter_hp_setting += 1
            if shooter_hp_setting > 99:
                shooter_hp_setting = 99
            pygame.time.delay(50)
        if shooter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            shooter_hp_setting -= 1
            if shooter_hp_setting < 1:
                shooter_hp_setting = 1
            pygame.time.delay(50)
        shooter_locks_text = font.render(enemy_locking_labels[enemy_locks[10]], True, BLACK)
        shooter_locks_button = pygame.Rect(650, 180+SLIST.index("shooter")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BRONZE, shooter_locks_button, border_radius=0)
        screen.blit(shooter_locks_text, shooter_locks_text.get_rect(center=shooter_locks_button.center))
        if shooter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[10] > 1: enemy_locks[10] = 0
            else: enemy_locks[10] = enemy_locks[10] + 1
            pygame.time.delay(200)



        sniper_hp_label = font.render("Sniper Enemy - HP: " + str(sniper_hp_setting), True, INDIGO)
        screen.blit(sniper_hp_label, (50, 180+SLIST.index("sniper")*60 + scroll_y))
        sniper_hp_minus_button = pygame.Rect(500, 180+SLIST.index("sniper")*60 - button_offset + scroll_y, 50, 50)
        sniper_hp_plus_button = pygame.Rect(560, 180+SLIST.index("sniper")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, sniper_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=sniper_hp_plus_button.center))
        pygame.draw.rect(screen, RED, sniper_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=sniper_hp_minus_button.center))
        if sniper_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            sniper_hp_setting += 1
            if sniper_hp_setting > 99:
                sniper_hp_setting = 99
            pygame.time.delay(50)
        if sniper_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            sniper_hp_setting -= 1
            if sniper_hp_setting < 1:
                sniper_hp_setting = 1
            pygame.time.delay(50)
        sniper_locks_text = font.render(enemy_locking_labels[enemy_locks[11]], True, BLACK)
        sniper_locks_button = pygame.Rect(650, 180+SLIST.index("sniper")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, INDIGO, sniper_locks_button, border_radius=0)
        screen.blit(sniper_locks_text, sniper_locks_text.get_rect(center=sniper_locks_button.center))
        if sniper_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[11] > 1: enemy_locks[11] = 0
            else: enemy_locks[11] = enemy_locks[11] + 1
            pygame.time.delay(200)



        extra_sniper_damage_label = font.render("Extra Damage: " + str(extra_sniper_damage_setting), True, INDIGO)
        screen.blit(extra_sniper_damage_label, (264, 180+SLIST.index("xtra sniper damage")*60 + scroll_y))
        extra_sniper_damage_minus_button = pygame.Rect(500, 180+SLIST.index("xtra sniper damage")*60 - button_offset + scroll_y, 50, 50)
        extra_sniper_damage_plus_button = pygame.Rect(560, 180+SLIST.index("xtra sniper damage")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, extra_sniper_damage_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=extra_sniper_damage_plus_button.center))
        pygame.draw.rect(screen, RED, extra_sniper_damage_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=extra_sniper_damage_minus_button.center))
        if extra_sniper_damage_plus_button.collidepoint(mouse_pos) and mouse_click:
            extra_sniper_damage_setting += 1
            if extra_sniper_damage_setting > 98:
                extra_sniper_damage_setting = 98
            pygame.time.delay(50)
        if extra_sniper_damage_minus_button.collidepoint(mouse_pos) and mouse_click:
            extra_sniper_damage_setting -= 1
            if extra_sniper_damage_setting < 0:
                extra_sniper_damage_setting = 0
            pygame.time.delay(50)



        speedy_hp_label = font.render("Speedy Enemy - HP: " + str(speedy_hp_setting), True, SKY)
        screen.blit(speedy_hp_label, (50, 180+SLIST.index("speedy")*60 + scroll_y))
        speedy_hp_minus_button = pygame.Rect(500, 180+SLIST.index("speedy")*60 - button_offset + scroll_y, 50, 50)
        speedy_hp_plus_button = pygame.Rect(560, 180+SLIST.index("speedy")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, speedy_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=speedy_hp_plus_button.center))
        pygame.draw.rect(screen, RED, speedy_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=speedy_hp_minus_button.center))
        if speedy_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            speedy_hp_setting += 1
            if speedy_hp_setting > 99:
                speedy_hp_setting = 99
            pygame.time.delay(50)
        if speedy_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            speedy_hp_setting -= 1
            if speedy_hp_setting < 1:
                speedy_hp_setting = 1
            pygame.time.delay(50)
        speedy_locks_text = font.render(enemy_locking_labels[enemy_locks[12]], True, BLACK)
        speedy_locks_button = pygame.Rect(650, 180+SLIST.index("speedy")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, SKY, speedy_locks_button, border_radius=0)
        screen.blit(speedy_locks_text, speedy_locks_text.get_rect(center=speedy_locks_button.center))
        if speedy_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[12] > 1: enemy_locks[12] = 0
            else: enemy_locks[12] = enemy_locks[12] + 1
            pygame.time.delay(200)


        shotgun_hp_label = font.render("Shotgun Enemy - HP: " + str(shotgun_hp_setting), True, BRICK)
        screen.blit(shotgun_hp_label, (50, 180+SLIST.index("shotgun")*60 + scroll_y))
        shotgun_hp_minus_button = pygame.Rect(500, 180+SLIST.index("shotgun")*60 - button_offset + scroll_y, 50, 50)
        shotgun_hp_plus_button = pygame.Rect(560, 180+SLIST.index("shotgun")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, shotgun_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=shotgun_hp_plus_button.center))
        pygame.draw.rect(screen, RED, shotgun_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=shotgun_hp_minus_button.center))
        if shotgun_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            shotgun_hp_setting += 1
            if shotgun_hp_setting > 99:
                shotgun_hp_setting = 99
            pygame.time.delay(50)
        if shotgun_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            shotgun_hp_setting -= 1
            if shotgun_hp_setting < 1:
                shotgun_hp_setting = 1
            pygame.time.delay(50)
        shotgun_locks_text = font.render(enemy_locking_labels[enemy_locks[13]], True, BLACK)
        shotgun_locks_button = pygame.Rect(650, 180+SLIST.index("shotgun")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BRICK, shotgun_locks_button, border_radius=0)
        screen.blit(shotgun_locks_text, shotgun_locks_text.get_rect(center=shotgun_locks_button.center))
        if shotgun_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[13] > 1: enemy_locks[13] = 0
            else: enemy_locks[13] = enemy_locks[13] + 1
            pygame.time.delay(200)



        shotgun_bullets_label = font.render("Bullets: " + str(shotgun_bullets_setting), True, BRICK)
        screen.blit(shotgun_bullets_label, (287, 180+SLIST.index("shotgun bullets")*60 + scroll_y))
        shotgun_bullets_minus_button = pygame.Rect(500, 180+SLIST.index("shotgun bullets")*60 - button_offset + scroll_y, 50, 50)
        shotgun_bullets_plus_button = pygame.Rect(560, 180+SLIST.index("shotgun bullets")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, shotgun_bullets_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=shotgun_bullets_plus_button.center))
        pygame.draw.rect(screen, RED, shotgun_bullets_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=shotgun_bullets_minus_button.center))
        if shotgun_bullets_plus_button.collidepoint(mouse_pos) and mouse_click:
            shotgun_bullets_setting += 1
            if shotgun_bullets_setting > 21:
                shotgun_bullets_setting = 21
            pygame.time.delay(50)
        if shotgun_bullets_minus_button.collidepoint(mouse_pos) and mouse_click:
            shotgun_bullets_setting -= 1
            if shotgun_bullets_setting < 1:
                shotgun_bullets_setting += 1
            pygame.time.delay(50)



        voodoo_hp_label = font.render("Voodoo Enemy - HP: " + str(voodoo_hp_setting), True, MAGENTA)
        screen.blit(voodoo_hp_label, (50, 180+SLIST.index("voodoo")*60 + scroll_y))
        voodoo_hp_minus_button = pygame.Rect(500, 180+SLIST.index("voodoo")*60 - button_offset + scroll_y, 50, 50)
        voodoo_hp_plus_button = pygame.Rect(560, 180+SLIST.index("voodoo")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, voodoo_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=voodoo_hp_plus_button.center))
        pygame.draw.rect(screen, RED, voodoo_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=voodoo_hp_minus_button.center))
        if voodoo_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            voodoo_hp_setting += 1
            if voodoo_hp_setting > 99:
                voodoo_hp_setting = 99
            pygame.time.delay(50)
        if voodoo_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            voodoo_hp_setting -= 1
            if voodoo_hp_setting < 1:
                voodoo_hp_setting = 1
            pygame.time.delay(50)
        voodoo_locks_text = font.render(enemy_locking_labels[enemy_locks[14]], True, BLACK)
        voodoo_locks_button = pygame.Rect(650, 180+SLIST.index("voodoo")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, MAGENTA, voodoo_locks_button, border_radius=0)
        screen.blit(voodoo_locks_text, voodoo_locks_text.get_rect(center=voodoo_locks_button.center))
        if voodoo_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[14] > 1: enemy_locks[14] = 0
            else: enemy_locks[14] = enemy_locks[14] + 1
            pygame.time.delay(200)



        blind_hp_label = font.render("Blind Enemy - HP: " + str(blind_hp_setting), True, BLUE)
        screen.blit(blind_hp_label, (50, 180+SLIST.index("blind")*60 + scroll_y))
        blind_hp_minus_button = pygame.Rect(500, 180+SLIST.index("blind")*60 - button_offset + scroll_y, 50, 50)
        blind_hp_plus_button = pygame.Rect(560, 180+SLIST.index("blind")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, blind_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=blind_hp_plus_button.center))
        pygame.draw.rect(screen, RED, blind_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=blind_hp_minus_button.center))
        if blind_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            blind_hp_setting += 1
            if blind_hp_setting > 99:
                blind_hp_setting = 99
            pygame.time.delay(50)
        if blind_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            blind_hp_setting -= 1
            if blind_hp_setting < 1:
                blind_hp_setting = 1
            pygame.time.delay(50)
        blind_locks_text = font.render(enemy_locking_labels[enemy_locks[15]], True, BLACK)
        blind_locks_button = pygame.Rect(650, 180+SLIST.index("blind")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BLUE, blind_locks_button, border_radius=0)
        screen.blit(blind_locks_text, blind_locks_text.get_rect(center=blind_locks_button.center))
        if blind_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[15] > 1: enemy_locks[15] = 0
            else: enemy_locks[15] = enemy_locks[15] + 1
            pygame.time.delay(200)




        motion_hp_label = font.render("Motion Enemy - HP: " + str(motion_hp_setting), True, ORANGE)
        screen.blit(motion_hp_label, (50, 180+SLIST.index("motion")*60 + scroll_y))
        motion_hp_minus_button = pygame.Rect(500, 180+SLIST.index("motion")*60 - button_offset + scroll_y, 50, 50)
        motion_hp_plus_button = pygame.Rect(560, 180+SLIST.index("motion")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, motion_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=motion_hp_plus_button.center))
        pygame.draw.rect(screen, RED, motion_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=motion_hp_minus_button.center))
        if motion_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            motion_hp_setting += 1
            if motion_hp_setting > 99:
                motion_hp_setting = 99
            pygame.time.delay(50)
        if motion_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            motion_hp_setting -= 1
            if motion_hp_setting < 1:
                motion_hp_setting = 1
            pygame.time.delay(50)
        motion_locks_text = font.render(enemy_locking_labels[enemy_locks[16]], True, BLACK)
        motion_locks_button = pygame.Rect(650, 180+SLIST.index("motion")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, ORANGE, motion_locks_button, border_radius=0)
        screen.blit(motion_locks_text, motion_locks_text.get_rect(center=motion_locks_button.center))
        if motion_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[16] > 1: enemy_locks[16] = 0
            else: enemy_locks[16] = enemy_locks[16] + 1
            pygame.time.delay(200)


        charger_hp_label = font.render("Charger Enemy - HP: " + str(charger_hp_setting), True, YELLOW)
        screen.blit(charger_hp_label, (50, 180+SLIST.index("charger")*60 + scroll_y))
        charger_hp_minus_button = pygame.Rect(500, 180+SLIST.index("charger")*60 - button_offset + scroll_y, 50, 50)
        charger_hp_plus_button = pygame.Rect(560, 180+SLIST.index("charger")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, charger_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=charger_hp_plus_button.center))
        pygame.draw.rect(screen, RED, charger_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=charger_hp_minus_button.center))
        if charger_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            charger_hp_setting += 1
            if charger_hp_setting > 99:
                charger_hp_setting = 99
            pygame.time.delay(50)
        if charger_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            charger_hp_setting -= 1
            if charger_hp_setting < 1:
                charger_hp_setting = 1
            pygame.time.delay(50)
        charger_locks_text = font.render(enemy_locking_labels[enemy_locks[17]], True, BLACK)
        charger_locks_button = pygame.Rect(650, 180+SLIST.index("charger")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, YELLOW, charger_locks_button, border_radius=0)
        screen.blit(charger_locks_text, charger_locks_text.get_rect(center=charger_locks_button.center))
        if charger_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[17] > 1: enemy_locks[17] = 0
            else: enemy_locks[17] = enemy_locks[17] + 1
            pygame.time.delay(200)


        rapidshooter_hp_label = font.render("Rapidshooter Enemy - HP: " + str(rapidshooter_hp_setting), True, GOLD)
        screen.blit(rapidshooter_hp_label, (50, 180+SLIST.index("rapidshooter")*60 + scroll_y))
        rapidshooter_hp_minus_button = pygame.Rect(500, 180+SLIST.index("rapidshooter")*60 - button_offset + scroll_y, 50, 50)
        rapidshooter_hp_plus_button = pygame.Rect(560, 180+SLIST.index("rapidshooter")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, rapidshooter_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=rapidshooter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, rapidshooter_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=rapidshooter_hp_minus_button.center))
        if rapidshooter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            rapidshooter_hp_setting += 1
            if rapidshooter_hp_setting > 99:
                rapidshooter_hp_setting = 99
            pygame.time.delay(50)
        if rapidshooter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            rapidshooter_hp_setting -= 1
            if rapidshooter_hp_setting < 1:
                rapidshooter_hp_setting = 1
            pygame.time.delay(50)
        rapidshooter_locks_text = font.render(enemy_locking_labels[enemy_locks[18]], True, BLACK)
        rapidshooter_locks_button = pygame.Rect(650, 180+SLIST.index("rapidshooter")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, GOLD, rapidshooter_locks_button, border_radius=0)
        screen.blit(rapidshooter_locks_text, rapidshooter_locks_text.get_rect(center=rapidshooter_locks_button.center))
        if rapidshooter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[18] > 1: enemy_locks[18] = 0
            else: enemy_locks[18] = enemy_locks[18] + 1
            pygame.time.delay(200)


        burstshooter_hp_label = font.render("Burstshooter Enemy - HP: " + str(burstshooter_hp_setting), True, SILVER)
        screen.blit(burstshooter_hp_label, (50, 180+SLIST.index("burstshooter")*60 + scroll_y))
        burstshooter_hp_minus_button = pygame.Rect(500, 180+SLIST.index("burstshooter")*60 - button_offset + scroll_y, 50, 50)
        burstshooter_hp_plus_button = pygame.Rect(560, 180+SLIST.index("burstshooter")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, burstshooter_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=burstshooter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, burstshooter_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=burstshooter_hp_minus_button.center))
        if burstshooter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            burstshooter_hp_setting += 1
            if burstshooter_hp_setting > 99:
                burstshooter_hp_setting = 99
            pygame.time.delay(50)
        if burstshooter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            burstshooter_hp_setting -= 1
            if burstshooter_hp_setting < 1:
                burstshooter_hp_setting = 1
            pygame.time.delay(50)
        burstshooter_locks_text = font.render(enemy_locking_labels[enemy_locks[31]], True, BLACK)
        burstshooter_locks_button = pygame.Rect(650, 180+SLIST.index("burstshooter")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, SILVER, burstshooter_locks_button, border_radius=0)
        screen.blit(burstshooter_locks_text, burstshooter_locks_text.get_rect(center=burstshooter_locks_button.center))
        if burstshooter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[31] > 1: enemy_locks[31] = 0
            else: enemy_locks[31] = enemy_locks[31] + 1
            pygame.time.delay(200)



        burst_label = font.render("Burst: " + str(burst_setting), True, SILVER)
        screen.blit(burst_label, (350, 180+SLIST.index("burst")*60 + scroll_y))
        burst_minus_button = pygame.Rect(500, 180+SLIST.index("burst")*60 - button_offset + scroll_y, 50, 50)
        burst_plus_button = pygame.Rect(560, 180+SLIST.index("burst")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, burst_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=burst_plus_button.center))
        pygame.draw.rect(screen, RED, burst_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=burst_minus_button.center))
        if burst_plus_button.collidepoint(mouse_pos) and mouse_click:
            burst_setting += 1
            if burst_setting > 100:
                burst_setting = 100
            pygame.time.delay(50)
        if burst_minus_button.collidepoint(mouse_pos) and mouse_click:
            burst_setting -= 1
            if burst_setting < 1:
                burst_setting = 1
            pygame.time.delay(50)



        frostbite_hp_label = font.render("Frostbite Enemy - HP: " + str(frostbite_hp_setting), True, CYAN)
        screen.blit(frostbite_hp_label, (50, 180+SLIST.index("frostbite")*60 + scroll_y))
        frostbite_hp_minus_button = pygame.Rect(500, 180+SLIST.index("frostbite")*60 - button_offset + scroll_y, 50, 50)
        frostbite_hp_plus_button = pygame.Rect(560, 180+SLIST.index("frostbite")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, frostbite_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=frostbite_hp_plus_button.center))
        pygame.draw.rect(screen, RED, frostbite_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=frostbite_hp_minus_button.center))
        if frostbite_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            frostbite_hp_setting += 1
            if frostbite_hp_setting > 99:
                frostbite_hp_setting = 99
            pygame.time.delay(50)
        if frostbite_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            frostbite_hp_setting -= 1
            if frostbite_hp_setting < 1:
                frostbite_hp_setting = 1
            pygame.time.delay(50)
        frostbite_locks_text = font.render(enemy_locking_labels[enemy_locks[19]], True, BLACK)
        frostbite_locks_button = pygame.Rect(650, 180+SLIST.index("frostbite")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, CYAN, frostbite_locks_button, border_radius=0)
        screen.blit(frostbite_locks_text, frostbite_locks_text.get_rect(center=frostbite_locks_button.center))
        if frostbite_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[19] > 1: enemy_locks[19] = 0
            else: enemy_locks[19] = enemy_locks[19] + 1
            pygame.time.delay(200)



        frostbite_projectile_amount_label = font.render("Bullets: " + str(frostbite_projectile_amount_setting), True, CYAN)
        screen.blit(frostbite_projectile_amount_label, (296, 180+SLIST.index("frostbite bullets")*60 + scroll_y))
        frostbite_projectile_amount_minus_button = pygame.Rect(500, 180+SLIST.index("frostbite bullets")*60 - button_offset + scroll_y, 50, 50)
        frostbite_projectile_amount_plus_button = pygame.Rect(560, 180+SLIST.index("frostbite bullets")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, frostbite_projectile_amount_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=frostbite_projectile_amount_plus_button.center))
        pygame.draw.rect(screen, RED, frostbite_projectile_amount_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=frostbite_projectile_amount_minus_button.center))
        if frostbite_projectile_amount_plus_button.collidepoint(mouse_pos) and mouse_click:
            frostbite_projectile_amount_setting += 4
            if frostbite_projectile_amount_setting > 128:
                frostbite_projectile_amount_setting = 128
            pygame.time.delay(50)
        if frostbite_projectile_amount_minus_button.collidepoint(mouse_pos) and mouse_click:
            frostbite_projectile_amount_setting -= 4
            if frostbite_projectile_amount_setting < 4:
                frostbite_projectile_amount_setting = 4
            pygame.time.delay(50)


        addictive_hp_label = font.render("Addictive Enemy - HP: " + str(addictive_hp_setting), True, PINK)
        screen.blit(addictive_hp_label, (50, 180+SLIST.index("addictive")*60 + scroll_y))
        addictive_hp_minus_button = pygame.Rect(500, 180+SLIST.index("addictive")*60 - button_offset + scroll_y, 50, 50)
        addictive_hp_plus_button = pygame.Rect(560, 180+SLIST.index("addictive")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, addictive_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=addictive_hp_plus_button.center))
        pygame.draw.rect(screen, RED, addictive_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=addictive_hp_minus_button.center))
        if addictive_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_hp_setting += 1
            if addictive_hp_setting > 99:
                addictive_hp_setting = 99
            pygame.time.delay(50)
        if addictive_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_hp_setting -= 1
            if addictive_hp_setting < 1:
                addictive_hp_setting = 1
            pygame.time.delay(50)
        addictive_locks_text = font.render(enemy_locking_labels[enemy_locks[20]], True, BLACK)
        addictive_locks_button = pygame.Rect(650, 180+SLIST.index("addictive")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, PINK, addictive_locks_button, border_radius=0)
        screen.blit(addictive_locks_text, addictive_locks_text.get_rect(center=addictive_locks_button.center))
        if addictive_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[20] > 1: enemy_locks[20] = 0
            else: enemy_locks[20] = enemy_locks[20] + 1
            pygame.time.delay(200)


        addictive_pull_strength_label = font.render("Strength: " + str(addictive_pull_strength_setting), True, PINK)
        screen.blit(addictive_pull_strength_label, (305, 180+SLIST.index("addictive strength")*60 + scroll_y))
        addictive_pull_strength_minus_button = pygame.Rect(500, 180+SLIST.index("addictive strength")*60 - button_offset + scroll_y, 50, 50)
        addictive_pull_strength_plus_button = pygame.Rect(560, 180+SLIST.index("addictive strength")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, addictive_pull_strength_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=addictive_pull_strength_plus_button.center))
        pygame.draw.rect(screen, RED, addictive_pull_strength_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=addictive_pull_strength_minus_button.center))
        if addictive_pull_strength_plus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_pull_strength_setting += 1
            if addictive_pull_strength_setting > 40:
                addictive_pull_strength_setting = 40
            pygame.time.delay(50)
        if addictive_pull_strength_minus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_pull_strength_setting -= 1
            if addictive_pull_strength_setting < 1:
                addictive_pull_strength_setting = 1
            pygame.time.delay(50)



        addictive_pull_radius_label = font.render("Radius: " + str(addictive_pull_radius_setting), True, PINK)
        screen.blit(addictive_pull_radius_label, (305, 180+SLIST.index("addictive radius")*60 + scroll_y))
        addictive_pull_radius_minus_button = pygame.Rect(500, 180+SLIST.index("addictive radius")*60 - button_offset + scroll_y, 50, 50)
        addictive_pull_radius_plus_button = pygame.Rect(560, 180+SLIST.index("addictive radius")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, addictive_pull_radius_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=addictive_pull_radius_plus_button.center))
        pygame.draw.rect(screen, RED, addictive_pull_radius_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=addictive_pull_radius_minus_button.center))
        if addictive_pull_radius_plus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_pull_radius_setting += 50
            if addictive_pull_radius_setting > 1000:
                addictive_pull_radius_setting = 1000
            pygame.time.delay(50)
        if addictive_pull_radius_minus_button.collidepoint(mouse_pos) and mouse_click:
            addictive_pull_radius_setting -= 50
            if addictive_pull_radius_setting < 100:
                addictive_pull_radius_setting = 100
            pygame.time.delay(50)



        laser_hp_label = font.render("Laser Enemy - HP: " + str(laser_hp_setting), True, TURQUOISE)
        screen.blit(laser_hp_label, (50, 180+SLIST.index("laser")*60 + scroll_y))
        laser_hp_minus_button = pygame.Rect(500, 180+SLIST.index("laser")*60 - button_offset + scroll_y, 50, 50)
        laser_hp_plus_button = pygame.Rect(560, 180+SLIST.index("laser")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, laser_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=laser_hp_plus_button.center))
        pygame.draw.rect(screen, RED, laser_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=laser_hp_minus_button.center))
        if laser_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            laser_hp_setting += 1
            if laser_hp_setting > 99:
                laser_hp_setting = 99
            pygame.time.delay(50)
        if laser_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            laser_hp_setting -= 1
            if laser_hp_setting < 1:
                laser_hp_setting = 1
            pygame.time.delay(50)
        laser_locks_text = font.render(enemy_locking_labels[enemy_locks[21]], True, BLACK)
        laser_locks_button = pygame.Rect(650, 180+SLIST.index("laser")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, TURQUOISE, laser_locks_button, border_radius=0)
        screen.blit(laser_locks_text, laser_locks_text.get_rect(center=laser_locks_button.center))
        if laser_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[21] > 1: enemy_locks[21] = 0
            else: enemy_locks[21] = enemy_locks[21] + 1
            pygame.time.delay(200)



        laser_damage_label = font.render("Laser Damage: " + str(laser_damage_setting), True, TURQUOISE)
        screen.blit(laser_damage_label, (50, 180+SLIST.index("laser damage")*60 + scroll_y))
        laser_damage_minus_button = pygame.Rect(500, 180+SLIST.index("laser damage")*60 - button_offset + scroll_y, 50, 50)
        laser_damage_plus_button = pygame.Rect(560, 180+SLIST.index("laser damage")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, laser_damage_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=laser_damage_plus_button.center))
        pygame.draw.rect(screen, RED, laser_damage_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=laser_damage_minus_button.center))
        if laser_damage_plus_button.collidepoint(mouse_pos) and mouse_click:
            laser_damage_setting += 1
            if laser_damage_setting > 99:
                laser_damage_setting = 99
            pygame.time.delay(50)
        if laser_damage_minus_button.collidepoint(mouse_pos) and mouse_click:
            laser_damage_setting -= 1
            if laser_damage_setting < 1:
                laser_damage_setting = 1
            pygame.time.delay(50)



        laser_duration_label = font.render("Laser Duration: " + str(laser_duration_setting), True, TURQUOISE)
        screen.blit(laser_duration_label, (50, 180+SLIST.index("laser duration")*60 + scroll_y))
        laser_duration_minus_button = pygame.Rect(500, 180+SLIST.index("laser duration")*60 - button_offset + scroll_y, 50, 50)
        laser_duration_plus_button = pygame.Rect(560, 180+SLIST.index("laser duration")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, laser_duration_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=laser_duration_plus_button.center))
        pygame.draw.rect(screen, RED, laser_duration_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=laser_duration_minus_button.center))
        if laser_duration_plus_button.collidepoint(mouse_pos) and mouse_click:
            laser_duration_setting += 100
            if laser_duration_setting > 5000:
                laser_duration_setting = 5000
            pygame.time.delay(50)
        if laser_duration_minus_button.collidepoint(mouse_pos) and mouse_click:
            laser_duration_setting -= 100
            if laser_duration_setting < 1500:
                laser_duration_setting = 1500
            pygame.time.delay(50)



        hardened_hp_label = font.render("Hardened Enemy - HP: " + str(hardened_hp_setting), True, BROWN)
        screen.blit(hardened_hp_label, (50, 180+SLIST.index("hardened")*60 + scroll_y))
        hardened_hp_minus_button = pygame.Rect(500, 180+SLIST.index("hardened")*60 - button_offset + scroll_y, 50, 50)
        hardened_hp_plus_button = pygame.Rect(560, 180+SLIST.index("hardened")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, hardened_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=hardened_hp_plus_button.center))
        pygame.draw.rect(screen, RED, hardened_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=hardened_hp_minus_button.center))
        if hardened_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            hardened_hp_setting += 1
            if hardened_hp_setting > 99:
                hardened_hp_setting = 99
            pygame.time.delay(50)
        if hardened_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            hardened_hp_setting -= 1
            if hardened_hp_setting < 1:
                hardened_hp_setting = 1
            pygame.time.delay(50)
        hardened_locks_text = font.render(enemy_locking_labels[enemy_locks[22]], True, BLACK)
        hardened_locks_button = pygame.Rect(650, 180+SLIST.index("hardened")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, BROWN, hardened_locks_button, border_radius=0)
        screen.blit(hardened_locks_text, hardened_locks_text.get_rect(center=hardened_locks_button.center))
        if hardened_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[22] > 1: enemy_locks[22] = 0
            else: enemy_locks[22] = enemy_locks[22] + 1
            pygame.time.delay(200)



        accelerator_hp_label = font.render("Accelerator Enemy - HP: " + str(accelerator_hp_setting), True, TAN)
        screen.blit(accelerator_hp_label, (50, 180+SLIST.index("accelerator")*60 + scroll_y))
        accelerator_hp_minus_button = pygame.Rect(500, 180+SLIST.index("accelerator")*60 - button_offset + scroll_y, 50, 50)
        accelerator_hp_plus_button = pygame.Rect(560, 180+SLIST.index("accelerator")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, accelerator_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=accelerator_hp_plus_button.center))
        pygame.draw.rect(screen, RED, accelerator_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=accelerator_hp_minus_button.center))
        if accelerator_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            accelerator_hp_setting += 1
            if accelerator_hp_setting > 99:
                accelerator_hp_setting = 99
            pygame.time.delay(50)
        if accelerator_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            accelerator_hp_setting -= 1
            if accelerator_hp_setting < 1:
                accelerator_hp_setting = 1
            pygame.time.delay(50)
        accelerator_locks_text = font.render(enemy_locking_labels[enemy_locks[23]], True, BLACK)
        accelerator_locks_button = pygame.Rect(650, 180+SLIST.index("accelerator")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, TAN, accelerator_locks_button, border_radius=0)
        screen.blit(accelerator_locks_text, accelerator_locks_text.get_rect(center=accelerator_locks_button.center))
        if accelerator_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[23] > 1: enemy_locks[23] = 0
            else: enemy_locks[23] = enemy_locks[23] + 1
            pygame.time.delay(200)



        cold_hp_label = font.render("Cold Enemy - HP: " + str(cold_hp_setting), True, TEAL)
        screen.blit(cold_hp_label, (50, 180+SLIST.index("cold")*60 + scroll_y))
        cold_hp_minus_button = pygame.Rect(500, 180+SLIST.index("cold")*60 - button_offset + scroll_y, 50, 50)
        cold_hp_plus_button = pygame.Rect(560, 180+SLIST.index("cold")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, cold_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=cold_hp_plus_button.center))
        pygame.draw.rect(screen, RED, cold_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=cold_hp_minus_button.center))
        if cold_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            cold_hp_setting += 1
            if cold_hp_setting > 99:
                cold_hp_setting = 99
            pygame.time.delay(50)
        if cold_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            cold_hp_setting -= 1
            if cold_hp_setting < 1:
                cold_hp_setting = 1
            pygame.time.delay(50)
        cold_locks_text = font.render(enemy_locking_labels[enemy_locks[24]], True, BLACK)
        cold_locks_button = pygame.Rect(650, 180+SLIST.index("cold")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, TEAL, cold_locks_button, border_radius=0)
        screen.blit(cold_locks_text, cold_locks_text.get_rect(center=cold_locks_button.center))
        if cold_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[24] > 1: enemy_locks[24] = 0
            else: enemy_locks[24] = enemy_locks[24] + 1
            pygame.time.delay(200)



        tracer_hp_label = font.render("Tracer Enemy - HP: " + str(tracer_hp_setting), True, SULFUR)
        screen.blit(tracer_hp_label, (50, 180+SLIST.index("tracer")*60 + scroll_y))
        tracer_hp_minus_button = pygame.Rect(500, 180+SLIST.index("tracer")*60 - button_offset + scroll_y, 50, 50)
        tracer_hp_plus_button = pygame.Rect(560, 180+SLIST.index("tracer")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, tracer_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=tracer_hp_plus_button.center))
        pygame.draw.rect(screen, RED, tracer_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=tracer_hp_minus_button.center))
        if tracer_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            tracer_hp_setting += 1
            if tracer_hp_setting > 99:
                tracer_hp_setting = 99
            pygame.time.delay(50)
        if tracer_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            tracer_hp_setting -= 1
            if tracer_hp_setting < 1:
                tracer_hp_setting = 1
            pygame.time.delay(50)
        tracer_locks_text = font.render(enemy_locking_labels[enemy_locks[25]], True, BLACK)
        tracer_locks_button = pygame.Rect(650, 180+SLIST.index("tracer")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, SULFUR, tracer_locks_button, border_radius=0)
        screen.blit(tracer_locks_text, tracer_locks_text.get_rect(center=tracer_locks_button.center))
        if tracer_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[25] > 1: enemy_locks[25] = 0
            else: enemy_locks[25] = enemy_locks[25] + 1
            pygame.time.delay(200)



        savage_hp_label = font.render("Savage Enemy - HP: " + str(savage_hp_setting), True, MAROON)
        screen.blit(savage_hp_label, (50, 180+SLIST.index("savage")*60 + scroll_y))
        savage_hp_minus_button = pygame.Rect(500, 180+SLIST.index("savage")*60 - button_offset + scroll_y, 50, 50)
        savage_hp_plus_button = pygame.Rect(560, 180+SLIST.index("savage")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, savage_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=savage_hp_plus_button.center))
        pygame.draw.rect(screen, RED, savage_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=savage_hp_minus_button.center))
        if savage_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            savage_hp_setting += 1
            if savage_hp_setting > 99:
                savage_hp_setting = 99
            pygame.time.delay(50)
        if savage_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            savage_hp_setting -= 1
            if savage_hp_setting < 1:
                savage_hp_setting = 1
            pygame.time.delay(50)
        savage_locks_text = font.render(enemy_locking_labels[enemy_locks[26]], True, BLACK)
        savage_locks_button = pygame.Rect(650, 180+SLIST.index("savage")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, MAROON, savage_locks_button, border_radius=0)
        screen.blit(savage_locks_text, savage_locks_text.get_rect(center=savage_locks_button.center))
        if savage_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[26] > 1: enemy_locks[26] = 0
            else: enemy_locks[26] = enemy_locks[26] + 1
            pygame.time.delay(200)



        teleporter_hp_label = font.render("Teleporter Enemy - HP: " + str(teleporter_hp_setting), True, PURPLE)
        screen.blit(teleporter_hp_label, (50, 180+SLIST.index("teleporter")*60 + scroll_y))
        teleporter_hp_minus_button = pygame.Rect(500, 180+SLIST.index("teleporter")*60 - button_offset + scroll_y, 50, 50)
        teleporter_hp_plus_button = pygame.Rect(560, 180+SLIST.index("teleporter")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, teleporter_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=teleporter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, teleporter_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=teleporter_hp_minus_button.center))
        if teleporter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            teleporter_hp_setting += 1
            if teleporter_hp_setting > 99:
                teleporter_hp_setting = 99
            pygame.time.delay(50)
        if teleporter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            teleporter_hp_setting -= 1
            if teleporter_hp_setting < 1:
                teleporter_hp_setting = 1
            pygame.time.delay(50)
        teleporter_locks_text = font.render(enemy_locking_labels[enemy_locks[27]], True, BLACK)
        teleporter_locks_button = pygame.Rect(650, 180+SLIST.index("teleporter")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, PURPLE, teleporter_locks_button, border_radius=0)
        screen.blit(teleporter_locks_text, teleporter_locks_text.get_rect(center=teleporter_locks_button.center))
        if teleporter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[27] > 1: enemy_locks[27] = 0
            else: enemy_locks[27] = enemy_locks[27] + 1
            pygame.time.delay(200)



        haunter_hp_label = font.render("Haunter Enemy - HP: " + str(haunter_hp_setting), True, NAVY)
        screen.blit(haunter_hp_label, (50, 180+SLIST.index("haunter")*60 + scroll_y))
        haunter_hp_minus_button = pygame.Rect(500, 180+SLIST.index("haunter")*60 - button_offset + scroll_y, 50, 50)
        haunter_hp_plus_button = pygame.Rect(560, 180+SLIST.index("haunter")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, haunter_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=haunter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, haunter_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=haunter_hp_minus_button.center))
        if haunter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            haunter_hp_setting += 1
            if haunter_hp_setting > 99:
                haunter_hp_setting = 99
            pygame.time.delay(50)
        if haunter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            haunter_hp_setting -= 1
            if haunter_hp_setting < 1:
                haunter_hp_setting = 1
            pygame.time.delay(50)
        haunter_locks_text = font.render(enemy_locking_labels[enemy_locks[28]], True, BLACK)
        haunter_locks_button = pygame.Rect(650, 180+SLIST.index("haunter")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, NAVY, haunter_locks_button, border_radius=0)
        screen.blit(haunter_locks_text, haunter_locks_text.get_rect(center=haunter_locks_button.center))
        if haunter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[28] > 1: enemy_locks[28] = 0
            else: enemy_locks[28] = enemy_locks[28] + 1
            pygame.time.delay(200)



        stream_hp_label = font.render("Stream Enemy - HP: " + str(stream_hp_setting), True, AQUA)
        screen.blit(stream_hp_label, (50, 180+SLIST.index("stream")*60 + scroll_y))
        stream_hp_minus_button = pygame.Rect(500, 180+SLIST.index("stream")*60 - button_offset + scroll_y, 50, 50)
        stream_hp_plus_button = pygame.Rect(560, 180+SLIST.index("stream")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, stream_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=stream_hp_plus_button.center))
        pygame.draw.rect(screen, RED, stream_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=stream_hp_minus_button.center))
        if stream_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            stream_hp_setting += 1
            if stream_hp_setting > 99:
                stream_hp_setting = 99
            pygame.time.delay(50)
        if stream_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            stream_hp_setting -= 1
            if stream_hp_setting < 1:
                stream_hp_setting = 1
            pygame.time.delay(50)
        stream_locks_text = font.render(enemy_locking_labels[enemy_locks[29]], True, BLACK)
        stream_locks_button = pygame.Rect(650, 180+SLIST.index("stream")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, AQUA, stream_locks_button, border_radius=0)
        screen.blit(stream_locks_text, stream_locks_text.get_rect(center=stream_locks_button.center))
        if stream_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[29] > 1: enemy_locks[29] = 0
            else: enemy_locks[29] = enemy_locks[29] + 1
            pygame.time.delay(200)



        sensitive_hp_label = font.render("Sensitive Enemy - HP: " + str(sensitive_hp_setting), True, LAVENDER)
        screen.blit(sensitive_hp_label, (50, 180+SLIST.index("sensitive")*60 + scroll_y))
        sensitive_hp_minus_button = pygame.Rect(500, 180+SLIST.index("sensitive")*60 - button_offset + scroll_y, 50, 50)
        sensitive_hp_plus_button = pygame.Rect(560, 180+SLIST.index("sensitive")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, sensitive_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=sensitive_hp_plus_button.center))
        pygame.draw.rect(screen, RED, sensitive_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=sensitive_hp_minus_button.center))
        if sensitive_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            sensitive_hp_setting += 1
            if sensitive_hp_setting > 99:
                sensitive_hp_setting = 99
            pygame.time.delay(50)
        if sensitive_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            sensitive_hp_setting -= 1
            if sensitive_hp_setting < 1:
                sensitive_hp_setting = 1
            pygame.time.delay(50)
        sensitive_locks_text = font.render(enemy_locking_labels[enemy_locks[30]], True, BLACK)
        sensitive_locks_button = pygame.Rect(650, 180+SLIST.index("sensitive")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, LAVENDER, sensitive_locks_button, border_radius=0)
        screen.blit(sensitive_locks_text, sensitive_locks_text.get_rect(center=sensitive_locks_button.center))
        if sensitive_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[30] > 1: enemy_locks[30] = 0
            else: enemy_locks[30] = enemy_locks[30] + 1
            pygame.time.delay(200)



        stickyshooter_hp_label = font.render("Stickyshooter Enemy - HP: " + str(stickyshooter_hp_setting), True, OLIVE)
        screen.blit(stickyshooter_hp_label, (50, 180+SLIST.index("stickyshooter")*60 + scroll_y))
        stickyshooter_hp_minus_button = pygame.Rect(500, 180+SLIST.index("stickyshooter")*60 - button_offset + scroll_y, 50, 50)
        stickyshooter_hp_plus_button = pygame.Rect(560, 180+SLIST.index("stickyshooter")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, stickyshooter_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=stickyshooter_hp_plus_button.center))
        pygame.draw.rect(screen, RED, stickyshooter_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=stickyshooter_hp_minus_button.center))
        if stickyshooter_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            stickyshooter_hp_setting += 1
            if stickyshooter_hp_setting > 99:
                stickyshooter_hp_setting = 99
            pygame.time.delay(50)
        if stickyshooter_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            stickyshooter_hp_setting -= 1
            if stickyshooter_hp_setting < 1:
                stickyshooter_hp_setting = 1
            pygame.time.delay(50)
        stickyshooter_locks_text = font.render(enemy_locking_labels[enemy_locks[32]], True, BLACK)
        stickyshooter_locks_button = pygame.Rect(650, 180+SLIST.index("stickyshooter")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, OLIVE, stickyshooter_locks_button, border_radius=0)
        screen.blit(stickyshooter_locks_text, stickyshooter_locks_text.get_rect(center=stickyshooter_locks_button.center))
        if stickyshooter_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[32] > 1: enemy_locks[32] = 0
            else: enemy_locks[32] = enemy_locks[32] + 1
            pygame.time.delay(200)



        sparker_hp_label = font.render("Sparker Enemy - HP: " + str(sparker_hp_setting), True, VOLT)
        screen.blit(sparker_hp_label, (50, 180+SLIST.index("sparker")*60 + scroll_y))
        sparker_hp_minus_button = pygame.Rect(500, 180+SLIST.index("sparker")*60 - button_offset + scroll_y, 50, 50)
        sparker_hp_plus_button = pygame.Rect(560, 180+SLIST.index("sparker")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, sparker_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=sparker_hp_plus_button.center))
        pygame.draw.rect(screen, RED, sparker_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=sparker_hp_minus_button.center))
        if sparker_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            sparker_hp_setting += 1
            if sparker_hp_setting > 99:
                sparker_hp_setting = 99
            pygame.time.delay(50)
        if sparker_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            sparker_hp_setting -= 1
            if sparker_hp_setting < 1:
                sparker_hp_setting = 1
            pygame.time.delay(50)
        sparker_locks_text = font.render(enemy_locking_labels[enemy_locks[33]], True, BLACK)
        sparker_locks_button = pygame.Rect(650, 180+SLIST.index("sparker")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, VOLT, sparker_locks_button, border_radius=0)
        screen.blit(sparker_locks_text, sparker_locks_text.get_rect(center=sparker_locks_button.center))
        if sparker_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[33] > 1: enemy_locks[33] = 0
            else: enemy_locks[33] = enemy_locks[33] + 1
            pygame.time.delay(200)



        harden_break_label = font.render("Unhardening Rate: " + str(harden_break_setting), True, BROWN)
        screen.blit(harden_break_label, (50, 180+SLIST.index("unhardening rate")*60 + scroll_y))
        harden_break_minus_button = pygame.Rect(500, 180+SLIST.index("unhardening rate")*60 - button_offset + scroll_y, 50, 50)
        harden_break_plus_button = pygame.Rect(560, 180+SLIST.index("unhardening rate")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, harden_break_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=harden_break_plus_button.center))
        pygame.draw.rect(screen, RED, harden_break_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=harden_break_minus_button.center))
        if harden_break_plus_button.collidepoint(mouse_pos) and mouse_click:
            harden_break_setting += 1
            if harden_break_setting > 40:
                harden_break_setting = 40
            pygame.time.delay(50)
        if harden_break_minus_button.collidepoint(mouse_pos) and mouse_click:
            harden_break_setting -= 1
            if harden_break_setting < 1:
                harden_break_setting = 1
            pygame.time.delay(50)


        enemy_damage_label = font.render("Enemy Damage: " + str(enemy_damage_setting), True, RED)
        screen.blit(enemy_damage_label, (50, 180+SLIST.index("enemy damage")*60 + scroll_y))
        enemy_damage_minus_button = pygame.Rect(500, 180+SLIST.index("enemy damage")*60 - button_offset + scroll_y, 50, 50)
        enemy_damage_plus_button = pygame.Rect(560, 180+SLIST.index("enemy damage")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, enemy_damage_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=enemy_damage_plus_button.center))
        pygame.draw.rect(screen, RED, enemy_damage_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=enemy_damage_minus_button.center))
        if enemy_damage_plus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_damage_setting += 1
            if enemy_damage_setting > 99:
                enemy_damage_setting = 99
            pygame.time.delay(50)
        if enemy_damage_minus_button.collidepoint(mouse_pos) and mouse_click:
            enemy_damage_setting -= 1
            if enemy_damage_setting < 0:
                enemy_damage_setting = 0
            pygame.time.delay(50)


        annihilator_hp_label = font.render("Annihilator Enemy - HP: " + str(annihilator_hp_setting), True, HOT_PINK)
        screen.blit(annihilator_hp_label, (50, 180+SLIST.index("annihilator")*60 + scroll_y))
        annihilator_hp_minus_button = pygame.Rect(500, 180+SLIST.index("annihilator")*60 - button_offset + scroll_y, 50, 50)
        annihilator_hp_plus_button = pygame.Rect(560, 180+SLIST.index("annihilator")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, annihilator_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=annihilator_hp_plus_button.center))
        pygame.draw.rect(screen, RED, annihilator_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=annihilator_hp_minus_button.center))
        if annihilator_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            annihilator_hp_setting += 1
            if annihilator_hp_setting > 99:
                annihilator_hp_setting = 99
            pygame.time.delay(50)
        if annihilator_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            annihilator_hp_setting -= 1
            if annihilator_hp_setting < 1:
                annihilator_hp_setting = 1
            pygame.time.delay(50)
        annihilator_locks_text = font.render(enemy_locking_labels[enemy_locks[34]], True, BLACK)
        annihilator_locks_button = pygame.Rect(650, 180+SLIST.index("annihilator")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, HOT_PINK, annihilator_locks_button, border_radius=0)
        screen.blit(annihilator_locks_text, annihilator_locks_text.get_rect(center=annihilator_locks_button.center))
        if annihilator_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[34] > 1: enemy_locks[34] = 0
            else: enemy_locks[34] = enemy_locks[34] + 1
            pygame.time.delay(200)



        annihilator_projectile_amount_label = font.render("Bullets: " + str(annihilator_projectile_amount_setting), True, HOT_PINK)
        screen.blit(annihilator_projectile_amount_label, (326, 180+SLIST.index("annihilator bullets")*60 + scroll_y))
        annihilator_projectile_amount_minus_button = pygame.Rect(500, 180+SLIST.index("annihilator bullets")*60 - button_offset + scroll_y, 50, 50)
        annihilator_projectile_amount_plus_button = pygame.Rect(560, 180+SLIST.index("annihilator bullets")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, annihilator_projectile_amount_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=annihilator_projectile_amount_plus_button.center))
        pygame.draw.rect(screen, RED, annihilator_projectile_amount_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=annihilator_projectile_amount_minus_button.center))
        if annihilator_projectile_amount_plus_button.collidepoint(mouse_pos) and mouse_click:
            annihilator_projectile_amount_setting += 4
            if annihilator_projectile_amount_setting > 128:
                annihilator_projectile_amount_setting = 128
            pygame.time.delay(50)
        if annihilator_projectile_amount_minus_button.collidepoint(mouse_pos) and mouse_click:
            annihilator_projectile_amount_setting -= 4
            if annihilator_projectile_amount_setting < 4:
                annihilator_projectile_amount_setting = 4
            pygame.time.delay(50)



        frostbeam_hp_label = font.render("Frostbeam Enemy - HP: " + str(frostbeam_hp_setting), True, ICE)
        screen.blit(frostbeam_hp_label, (50, 180+SLIST.index("frostbeam")*60 + scroll_y))
        frostbeam_hp_minus_button = pygame.Rect(500, 180+SLIST.index("frostbeam")*60 - button_offset + scroll_y, 50, 50)
        frostbeam_hp_plus_button = pygame.Rect(560, 180+SLIST.index("frostbeam")*60 - button_offset + scroll_y, 50, 50)
        pygame.draw.rect(screen, GREEN, frostbeam_hp_plus_button, border_radius=0)
        screen.blit(plus_txt, plus_txt.get_rect(center=frostbeam_hp_plus_button.center))
        pygame.draw.rect(screen, RED, frostbeam_hp_minus_button, border_radius=0)
        screen.blit(minus_txt, minus_txt.get_rect(center=frostbeam_hp_minus_button.center))
        if frostbeam_hp_plus_button.collidepoint(mouse_pos) and mouse_click:
            frostbeam_hp_setting += 1
            if frostbeam_hp_setting > 99:
                frostbeam_hp_setting = 99
            pygame.time.delay(50)
        if frostbeam_hp_minus_button.collidepoint(mouse_pos) and mouse_click:
            frostbeam_hp_setting -= 1
            if frostbeam_hp_setting < 1:
                frostbeam_hp_setting = 1
            pygame.time.delay(50)
        frostbeam_locks_text = font.render(enemy_locking_labels[enemy_locks[35]], True, BLACK)
        frostbeam_locks_button = pygame.Rect(650, 180+SLIST.index("frostbeam")*60 - button_offset + scroll_y, 200, 50)
        pygame.draw.rect(screen, ICE, frostbeam_locks_button, border_radius=0)
        screen.blit(frostbeam_locks_text, frostbeam_locks_text.get_rect(center=frostbeam_locks_button.center))
        if frostbeam_locks_button.collidepoint(mouse_pos) and mouse_click:
            if enemy_locks[35] > 1: enemy_locks[35] = 0
            else: enemy_locks[35] = enemy_locks[35] + 1
            pygame.time.delay(200)


        all_enemies_one_color_button_color = SHADOW
        all_enemies_one_color_text_color = WHITE
        if modifiers[0] == 0: all_enemies_one_color_button_color = SHADOW
        elif modifiers[0] == 1: all_enemies_one_color_button_color = GRAY
        elif modifiers[0] == 2: all_enemies_one_color_button_color = RED
        elif modifiers[0] == 3: all_enemies_one_color_button_color = WHITE
        if modifiers[0] == 3: all_enemies_one_color_text_color = BLACK
        else: all_enemies_one_color_text_color = WHITE
        all_enemies_one_color_list = ["No", "Gray", "Red", "White"]
        all_enemies_one_color_text = font.render("Set All Enemies To One Color: " + str(all_enemies_one_color_list[modifiers[0]]), True, all_enemies_one_color_text_color)
        all_enemies_one_color_button = pygame.Rect(50, 180+SLIST.index("all one color")*60 - button_offset + scroll_y, 800, 50)
        pygame.draw.rect(screen, all_enemies_one_color_button_color, all_enemies_one_color_button, border_radius=0)
        screen.blit(all_enemies_one_color_text, all_enemies_one_color_text.get_rect(center=all_enemies_one_color_button.center))
        if all_enemies_one_color_button.collidepoint(mouse_pos) and mouse_click:
            if modifiers[0] == 3: modifiers[0] = 0
            else: modifiers[0] += 1
            pygame.time.delay(200)



        pygame.draw.rect(screen, GRAY, scrollbar_track, border_radius=6)
        pygame.draw.rect(screen, WHITE, scrollbar_handle, border_radius=6)

        

        for event in pygame.event.get():
            if event.type == pygame.MOUSEWHEEL:
                scroll_y += event.y * scroll_speed * 2
                scroll_y = max(min(scroll_y, 0), -max_scroll)
            if event.type == pygame.QUIT:
                pygame.quit(); exit()
            if event.type == pygame.KEYDOWN and (event.key == pygame.K_ESCAPE or event.key == pygame.K_SPACE):
                if 0 in enemy_locks: running = False
            if event.type == pygame.MOUSEBUTTONDOWN:
                if scrollbar_handle.collidepoint(event.pos):
                    dragging_scrollbar = True
                    mouse_offset_y = event.pos[1] - scrollbar_handle.y

            if event.type == pygame.MOUSEBUTTONUP:
                dragging_scrollbar = False

            if event.type == pygame.MOUSEMOTION and dragging_scrollbar:
                new_y = event.pos[1] - mouse_offset_y
                new_y = max(
                    scrollbar_track.y,
                    min(new_y, scrollbar_track.bottom - handle_height)
                )

                ratio = (new_y - scrollbar_track.y) / (scrollbar_track.height - handle_height)
                scroll_y = -int(ratio * max_scroll)
        pygame.display.flip()
        clock.tick(60)

menu_font = pygame.font.Font(None, 48)
text_color = (255, 255, 255)

button_width, button_height = 200, 60
margin = 40
button_gap = 40

total_width = button_width * 2 + button_gap
start_x = (WIDTH - total_width) // 2
y_pos = HEIGHT - button_height - margin - 400


def apply_settings():
    global player_size, player_font, enemy_size, enemy_font, projectile_size, projectile_damage, trail_size
    global min_spawn_delay, initial_spawn_delay, spawn_rate, enemy_damage
    global player_speed, player_speed_base, player2_speed, player2_speed_base, enemy_speed
    global bomb_projectile_speed, shooter_projectile_speed, sniper_projectile_speed, shotgun_projectile_speed, rapidshooter_projectile_speed, burstshooter_projectile_speed, frostbite_projectile_speed
    global stickyshooter_projectile_speed, sparker_projectile_speed, annihilator_projectile_speed
    global regen_delay, player_lives, player2_lives
    global trail_lifetime_ms, trail_interval_ms, burst
    global freeze_duration
    global invincibility_duration, enemy_unlock
    global chase_turn
    global stickiness
    global projectile_fire_rate
    global basic_hp
    global homing_hp
    global fatal_hp
    global flow_hp
    global sticky_hp
    global gloomy_hp
    global trail_hp
    global impostor_hp
    global splitter_hp, split_amount
    global bomb_hp, bomb_projectile_amount
    global shooter_hp
    global sniper_hp, extra_sniper_damage
    global speedy_hp
    global shotgun_hp
    global shotgun_bullets
    global voodoo_hp
    global blind_hp
    global motion_hp
    global charger_hp
    global rapidshooter_hp
    global frostbite_hp, frostbite_projectile_amount
    global addictive_hp, addictive_pull_radius, addictive_pull_strength
    global laser_hp, laser_damage, laser_duration
    global hardened_hp, harden_break
    global accelerator_hp
    global cold_hp
    global tracer_hp
    global savage_hp
    global teleporter_hp
    global haunter_hp
    global stream_hp
    global sensitive_hp
    global stickyshooter_hp
    global burstshooter_hp
    global sparker_hp
    global annihilator_hp, annihilator_projectile_amount
    global frostbeam_hp
    

    # --- SETTINGS SET ---
    player_size = player_size_setting
    player_font = pygame.font.SysFont(None, int(0.96 * player_size))
    enemy_size = enemy_size_setting
    enemy_font = pygame.font.SysFont(None, int(0.96 * enemy_size))
    min_spawn_delay = min_spawn_delay_setting
    initial_spawn_delay = max_spawn_delay_setting
    projectile_size = projectile_size_setting
    trail_size = projectile_size_setting
    projectile_damage = projectile_damage_setting
    spawn_rate = spawn_delay_change_setting
    player_speed = player_speed_setting
    player_speed_base = player_speed_setting
    player2_speed = player_speed_setting
    player2_speed_base = player_speed_setting
    enemy_speed = enemy_speed_setting
    bomb_projectile_speed = 2.5 * (projectile_speed_setting / 5)
    shooter_projectile_speed = 5 * (projectile_speed_setting / 5)
    sniper_projectile_speed = 10 * (projectile_speed_setting / 5)
    shotgun_projectile_speed = 5 * (projectile_speed_setting / 5)
    rapidshooter_projectile_speed = 5 * (projectile_speed_setting / 5)
    burstshooter_projectile_speed = 5 * (projectile_speed_setting / 5)
    frostbite_projectile_speed = 5 * (projectile_speed_setting / 5)
    stickyshooter_projectile_speed = 5 * (projectile_speed_setting / 5)
    sparker_projectile_speed = 5 * (projectile_speed_setting / 5)
    annihilator_projectile_speed = 10 * (projectile_speed_setting / 5)
    regen_delay = regen_delay_setting
    player_lives = player_health_setting
    player2_lives = player_health_setting
    trail_lifetime_ms = trail_duration_setting
    trail_interval_ms = trail_distance_setting
    freeze_duration = freeze_duration_setting
    invincibility_duration = invincibility_duration_setting
    chase_turn = chaser_turn_amount_setting
    stickiness = enemy_stick_setting
    projectile_fire_rate = projectile_fire_rate_setting
    enemy_damage = enemy_damage_setting
    enemy_unlock = enemy_unlock_setting
    burst = burst_setting
    basic_hp = basic_hp_setting
    homing_hp = homing_hp_setting
    fatal_hp = fatal_hp_setting
    flow_hp = flow_hp_setting
    sticky_hp = sticky_hp_setting
    gloomy_hp = gloomy_hp_setting
    trail_hp = trail_hp_setting
    impostor_hp = impostor_hp_setting
    splitter_hp = splitter_hp_setting
    split_amount = split_amount_setting
    bomb_hp = bomb_hp_setting
    bomb_projectile_amount = bomb_projectile_amount_setting
    shooter_hp = shooter_hp_setting
    sniper_hp = sniper_hp_setting
    extra_sniper_damage = extra_sniper_damage_setting
    speedy_hp = speedy_hp_setting
    shotgun_hp = shotgun_hp_setting
    shotgun_bullets = shotgun_bullets_setting
    voodoo_hp = voodoo_hp_setting
    blind_hp = blind_hp_setting
    motion_hp = motion_hp_setting
    charger_hp = charger_hp_setting
    rapidshooter_hp = rapidshooter_hp_setting
    frostbite_hp = frostbite_hp_setting
    frostbite_projectile_amount = frostbite_projectile_amount_setting
    addictive_hp = addictive_hp_setting
    addictive_pull_radius = addictive_pull_radius_setting
    addictive_pull_strength = addictive_pull_strength_setting
    laser_hp = laser_hp_setting
    laser_damage = laser_damage_setting
    laser_duration = laser_duration_setting
    hardened_hp = hardened_hp_setting
    harden_break = harden_break_setting
    accelerator_hp = accelerator_hp_setting
    cold_hp = cold_hp_setting
    tracer_hp = tracer_hp_setting
    savage_hp = savage_hp_setting
    teleporter_hp = teleporter_hp_setting
    haunter_hp = haunter_hp_setting
    stream_hp = stream_hp_setting
    sensitive_hp = sensitive_hp_setting
    burstshooter_hp = burstshooter_hp_setting
    stickyshooter_hp = stickyshooter_hp_setting
    sparker_hp = sparker_hp_setting
    annihilator_hp = annihilator_hp_setting
    annihilator_projectile_amount = annihilator_projectile_amount_setting
    frostbeam_hp = frostbeam_hp_setting
    
    available_enemy_types.clear()
    locked_enemy_types.clear()
    unlock_scores.clear()
    enemy_counter = 0
    for i in enemy_locks:
        enemy_lock_setup(i, enemy_counter)
        enemy_counter += 1
    random.shuffle(locked_enemy_types)
    unlocks = 0
    for unlocked in range(len(locked_enemy_types)):
        unlock_scores.append(enemy_unlock * (1 + unlocked))

    


def TITLE_SCREEN():
    global players
    global player_skins
    global p1_skin_color
    global p2_skin_color
    
    skin_font = pygame.font.SysFont(None, 70)

    start_button = pygame.Rect(WIDTH//2 - 100, 300, 200, 60)
    button_1p = pygame.Rect(WIDTH//2 - 220, 400, 200, 60)
    button_2p = pygame.Rect(WIDTH//2 + 20, 400, 200, 60)
    settings_button = pygame.Rect(WIDTH//2 - 100, 500, 200, 60)
    quit_button = pygame.Rect(WIDTH//2 - 100, 600, 200, 60)
        
    p1_skin_button = pygame.Rect(WIDTH//2 - 160, HEIGHT - 200, 100, 100)
    p2_skin_button = pygame.Rect(WIDTH//2 + 60, HEIGHT - 200, 100, 100)

        
    waiting = True
    while waiting:
        screen.fill((0, 0, 0))
        title_text = big_font.render("Pixels Of Evasion", True, (255, 0, 0))
        screen.blit(title_text, title_text.get_rect(center=(WIDTH//2, 150)))
        
        if players == 2:
            p1_skin_button.centerx = WIDTH / 2 - 100
            p2_skin_button.centerx = WIDTH / 2 + 100
        else:
            p1_skin_button.centerx = WIDTH / 2
            p2_skin_button.centerx = WIDTH + 69696969
            
        mouse_pos = pygame.mouse.get_pos()
        mouse_click = pygame.mouse.get_pressed()[0]

        # --- Start Game button (TOP) ---
        if players in [1, 2]:
            color = GREEN if start_button.collidepoint(mouse_pos) else FOREST
        else:
            color = LIME  # disabled look until a mode is chosen

        pygame.draw.rect(screen, color, start_button, border_radius=0)
        start_text = font.render("Start Game", True, (255, 255, 255))
        screen.blit(start_text, start_text.get_rect(center=start_button.center))

        if start_button.collidepoint(mouse_pos) and mouse_click and players in [1, 2]:
            apply_settings()
            reset_game_state()
            waiting = False

        # --- Quit button ---
        if players in [1, 2]:
            color = YELLOW if quit_button.collidepoint(mouse_pos) else SULFUR
        else:
            color = CREAM  # disabled look until a mode is chosen

        pygame.draw.rect(screen, color, quit_button, border_radius=0)
        quit_text = font.render("Quit", True, (255, 255, 255))
        screen.blit(quit_text, quit_text.get_rect(center=quit_button.center))

        if quit_button.collidepoint(mouse_pos) and mouse_click:
            pygame.quit()
            quit()

        # --- P1 Skin --

        pygame.draw.rect(screen, player_skins[p1_skin_color], p1_skin_button, border_radius=0)
        p1_skin_text = skin_font.render("P1", True, player_skins[p1_skin_color + 1])
        screen.blit(p1_skin_text, p1_skin_text.get_rect(center=p1_skin_button.center))

        if p1_skin_button.collidepoint(mouse_pos) and mouse_click:
            if p1_skin_color+3 == len(player_skins): p1_skin_color = 0
            else: p1_skin_color += 3
            pygame.time.delay(200)


        # --- P2 Skin --

        pygame.draw.rect(screen, player_skins[p2_skin_color], p2_skin_button, border_radius=0)
        p2_skin_text = skin_font.render("P2", True, player_skins[p2_skin_color + 2])
        screen.blit(p2_skin_text, p2_skin_text.get_rect(center=p2_skin_button.center))

        if p2_skin_button.collidepoint(mouse_pos) and mouse_click:
            if p2_skin_color+3 == len(player_skins): p2_skin_color = 0
            else: p2_skin_color += 3
            pygame.time.delay(200)
            

        # --- Settings button ---
        if players in [1, 2]:
            color = BLUE if settings_button.collidepoint(mouse_pos) else NAVY
        else:
            color = SKY  # disabled look until a mode is chosen

        pygame.draw.rect(screen, color, settings_button, border_radius=0)
        settings_text = font.render("Settings", True, (255, 255, 255))
        screen.blit(settings_text, settings_text.get_rect(center=settings_button.center))

        if settings_button.collidepoint(mouse_pos) and mouse_click:
            SETTINGS()
            pygame.time.delay(200)   # <-- prevents instant selection
            continue

        # --- Player buttons (BELOW Start button) ---
        for rect, label, value in [(button_1p, "1 Player", 1), (button_2p, "2 Players", 2)]:
            if players == value:
                color = RED
            elif rect.collidepoint(mouse_pos):
                color = MAROON
            else:
                color = CRISP

            pygame.draw.rect(screen, color, rect, border_radius=0)
            text = font.render(label, True, text_color)
            screen.blit(text, text.get_rect(center=rect.center))

            if rect.collidepoint(mouse_pos) and mouse_click:
                players = value

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()

        pygame.display.flip()
        clock.tick(15)


TITLE_SCREEN()
spawn_enabled = False
p1_ready = False
p2_ready = False

running = True
while running:
    clock.tick(FPS)
    current_time = pygame.time.get_ticks()

    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            reset_game_state()
            TITLE_SCREEN()

    keys = pygame.key.get_pressed()

    # Determine movement for Player 1
    if players == 1:
        p1_dx = (keys[pygame.K_d] or keys[pygame.K_RIGHT]) - (keys[pygame.K_a] or keys[pygame.K_LEFT])
        p1_dy = (keys[pygame.K_s] or keys[pygame.K_DOWN]) - (keys[pygame.K_w] or keys[pygame.K_UP])
    else:
        p1_dx = (keys[pygame.K_d]) - (keys[pygame.K_a])
        p1_dy = (keys[pygame.K_s]) - (keys[pygame.K_w])
    if p1_dx != 0 or p1_dy != 0:
        length1 = math.hypot(p1_dx, p1_dy)
        p1_dx = (p1_dx / length1) * player_speed
        p1_dy = (p1_dy / length1) * player_speed

    keys2 = pygame.key.get_pressed()
    
    # Determine movement for Player 2 (if exists)
    p2_dx, p2_dy = 0, 0
    if players == 2:
        p2_dx = ((keys[pygame.K_l]) - (keys[pygame.K_j]))
        p2_dy = ((keys[pygame.K_k]) - (keys[pygame.K_i]))
        if p2_dx != 0 or p2_dy != 0:
            length2 = math.hypot(p2_dx, p2_dy)
            p2_dx = p2_dx / length2 * player2_speed
            p2_dy = p2_dy / length2 * player2_speed

    # Move players
    if p1_dx != 0 or p1_dy != 0: p1_ready = True
    player_x += p1_dx
    player_y += p1_dy
    player_x = max(player_size / 2, min(WIDTH - player_size / 2, player_x))
    player_y = max(player_size / 2, min(HEIGHT - player_size / 2, player_y))

    if players == 2:
        if p2_dx != 0 or p2_dy != 0: p2_ready = True
        player2_x += p2_dx
        player2_y += p2_dy
        player2_x = max(player_size / 2, min(WIDTH - player_size / 2, player2_x))
        player2_y = max(player_size / 2, min(HEIGHT - player_size / 2, player2_y))

        if player_alive and player2_alive:
            if centered_rect_collision(player_x, player_y, player_size,
                               player2_x, player2_y, player_size):
                overlap_x = (player_size - abs(player_x - player2_x)) / 2
                overlap_y = (player_size - abs(player_y - player2_y)) / 2

                # Push both players apart along the smallest overlap axis
                if overlap_x < overlap_y:
                    if player_x < player2_x:
                        player_x -= overlap_x
                        player2_x += overlap_x
                    else:
                        player_x += overlap_x
                        player2_x -= overlap_x
                else:
                    if player_y < player2_y:
                        player_y -= overlap_y
                        player2_y += overlap_y
                    else:
                        player_y += overlap_y
                        player2_y -= overlap_y


    player_moving = (p1_dx != 0 or p1_dy != 0)

    if current_time > slow_until:
        player_speed = player_speed_base
        player_frozen = False
    if players == 2 and current_time > player2_slow_until:
        player2_speed = player2_speed_base
        player2_frozen = False

    # Update spawner activation
    if not spawn_enabled:
        if p1_ready and players == 1: spawn_enabled = True
        if p1_ready and p2_ready and players == 2: spawn_enabled = True


        
    # --- Dynamic Enemy Unlock ---
    while unlock_scores and truescore >= unlock_scores[0]:
        if len(locked_enemy_types) > 0:
            new_type = locked_enemy_types[0]
            available_enemy_types.append(new_type)
            locked_enemy_types.remove(new_type)
        unlock_scores.pop(0)

    # --- Enemy Spawning ---
    adjusted_score = score / 5  # scale back to old point rate
    spawn_delay = max(
        min_spawn_delay,
        initial_spawn_delay - int(adjusted_score * spawn_rate)
    )
    if spawn_enabled and current_time - last_spawn_time >= spawn_delay:
        enemy_type = random.choice(available_enemy_types)
        angle = random.uniform(0, 2 * math.pi)
        dx = math.cos(angle) * enemy_speed
        dy = math.sin(angle) * enemy_speed
        sussy_dx = math.cos(angle) * player_speed_base
        sussy_dy = math.sin(angle) * player_speed_base
        base_dx = dx
        base_dy = dy

        # Default values
        health = basic_hp
        shoot_delay = 1

        # Determine enemy attributes based on type
        if enemy_type == 1:
            dx *= 1; dy *= 1; health = basic_hp
        elif enemy_type == 2:
            dx *= 0.7; dy *= 0.7; health = homing_hp
        elif enemy_type == 3:
            dx *= 0.5; dy *= 0.5; health = fatal_hp
        elif enemy_type == 4:
            dx *= 2/3; dy *= 2/3; health = flow_hp
        elif enemy_type == 5:
            dx *= 1; dy *= 1; health = sticky_hp
        elif enemy_type == 6:
            dx *= 1; dy *= 1; health = gloomy_hp
        elif enemy_type == 7:
            dx *= 1; dy *= 1; health = trail_hp
        elif enemy_type == 8:
            health = impostor_hp
        elif enemy_type == 9:
            dx *= 1; dy *= 1; health = splitter_hp
        elif enemy_type == 10:
            dx *= 1; dy *= 1; health = bomb_hp
        elif enemy_type == 11:
            dx *= 0.9; dy *= 0.9; health = shooter_hp
            shoot_delay = shooter_delay
        elif enemy_type == 12:
            dx *= 0.3; dy *= 0.3; health = sniper_hp
            shoot_delay = sniper_delay
        elif enemy_type == 13:
            dx *= 2; dy *= 2; health = speedy_hp
        elif enemy_type == 14:
            dx *= 0.9; dy *= 0.9; health = shotgun_hp
            shoot_delay = shotgun_delay
        elif enemy_type == 15:
            dx *= 0.35; dy *= 0.35; health = voodoo_hp
        elif enemy_type == 16:
            dx *= 1; dy *= 1; health = blind_hp
        elif enemy_type == 17:
            dx *= 1; dy *= 1; health = motion_hp
        elif enemy_type == 18:
            dx *= 2; dy *= 2; health = charger_hp
        elif enemy_type == 19:
            dx *= 1.25; dy *= 1.25; health = rapidshooter_hp
            shoot_delay = rapidshooter_delay
        elif enemy_type == 20:
            dx *= 0.5; dy *= 0.5; health = frostbite_hp
        elif enemy_type == 21:
            dx *= 0.75; dy *= 0.75; health = addictive_hp
        elif enemy_type == 22:
            dx *= 0.65; dy *= 0.65; health = laser_hp
        elif enemy_type == 23:
            dx *= 0.5; dy *= 0.5; health = hardened_hp
        elif enemy_type == 24:
            base_dx = dx; base_dy = dy
            dx *= 0; dy *= 0; health = accelerator_hp
            accel = 0.0; accel_rate = 0.02
        elif enemy_type == 25:
            dx *= 0.5; dy *= 0.5; health = cold_hp
        elif enemy_type == 26:
            dx *= 0.7; dy *= 0.7; health = tracer_hp
        elif enemy_type == 27:
            dx *= 2/3; dy *= 2/3; health = savage_hp
        elif enemy_type == 28:
            dx *= 1; dy *= 1; health = teleporter_hp
        elif enemy_type == 29:
            dx *= 0.7; dy *= 0.7; health = haunter_hp
        elif enemy_type == 30:
            dx *= 2/3; dy *= 2/3; health = stream_hp
        elif enemy_type == 31:
            dx *= 2/3; dy *= 2/3; health = sensitive_hp
        elif enemy_type == 32:
            dx *= 1; dy *= 1; health = burstshooter_hp
            shoot_delay = burstshooter_delay
        elif enemy_type == 33:
            dx *= 1; dy *= 1; health = stickyshooter_hp
            shoot_delay = stickyshooter_delay
        elif enemy_type == 34:
            dx *= 1; dy *= 1; health = sparker_hp
            shoot_delay = sparker_delay
        elif enemy_type == 35:
            dx *= 0.35; dy *= 0.35; health = annihilator_hp
        elif enemy_type == 36:
            dx *= 0.65; dy *= 0.65; health = frostbeam_hp

        if enemy_type in targetting_enemies:
            if players == 1:
                target = 1
            else:
                target = random.choice([1, 2])
        else: target = 0
            

        enemies.append({
            "dead": False,
            "x": spawner_pos[0]+25,
            "y": spawner_pos[1]+25,
            "target": target,
            "dx": dx,
            "dy": dy,
            "sussy_dx": sussy_dx,
            "sussy_dy": sussy_dy,
            "base_dx": base_dx,
            "base_dy": base_dy,
            "accel": accel,
            "accel_rate": accel_rate,
            "type": enemy_type,
            "angle": angle,
            "bounces": 0,
            "shrinking": False,
            "size": enemy_size,        # use the global default size initially
            "health": health,
            "ability": 1,
            "stopped": False,
            "stop_start_time": None,
            "last_trail_time": current_time,
            "last_shot_time": current_time,
            "shoot_delay": shoot_delay/(projectile_fire_rate/10),
            "bursts": burst,
            "bursts left": 0,
            "spawn_protected": True,
            "spawn_time": current_time
        })
        last_spawn_time = current_time
        
        for enemy in enemies:
            if players == 2:
                if not player_alive and player2_alive:
                    enemy["target"] = 2
                elif not player2_alive and player_alive:
                    enemy["target"] = 1

    # --- Enemy Movement ---
    for enemy in enemies:
        
        enemy_died = False
        sz = enemy.get("size", enemy_size)
        if enemy["type"] == 1:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= basic_hp: enemy_died = True

        elif enemy["type"] == 2:
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                dx = tx - enemy["x"]; dy = ty - enemy["y"]
            else:
                dx, dy = 0, 0
            target_angle = math.atan2(dy, dx)
            enemy["angle"] = rotate_toward(enemy["angle"], target_angle, chase_turn/250)#THIS IS THE TURN SPEED 0.02
            enemy["dx"] = math.cos(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["dy"] = math.sin(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["angle"] = math.pi - enemy["angle"]; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["angle"] = -enemy["angle"]; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= homing_hp: enemy_died = True

        elif enemy["type"] == 3:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= fatal_hp: enemy_died = True

        elif enemy["type"] == 4:
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            speed_multiplier = 2.5 if closest_dist < 200+enemy_size/2+player_size/2 else 2/3
            enemy["x"] += enemy["dx"] * speed_multiplier
            enemy["y"] += enemy["dy"] * speed_multiplier
            bounced = False
            # X-axis bounce
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
                if enemy["x"] <= 0: enemy["x"] = 0
                elif enemy["x"] >= WIDTH - enemy_size: enemy["x"] = WIDTH - enemy_size/2
            # Y-axis bounce
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
                if enemy["y"] <= 0: enemy["y"] = 0
                elif enemy["y"] >= HEIGHT - enemy_size: enemy["y"] = HEIGHT - enemy_size/2
            # Update bounce count and health once per frame
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            # Remove enemy if health depleted
            if enemy["bounces"] >= flow_hp or enemy["health"] <= 0:
                enemy_died = True
                
        elif enemy["type"] == 5:
            if enemy["stopped"]:
                if current_time - enemy["stop_start_time"] >= stickiness:
                    enemy["stopped"] = False
            else:
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                bounced = False
                if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                    enemy["dx"] *= -1
                    bounced = True
                if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                    enemy["dy"] *= -1
                    bounced = True

                if bounced:
                    enemy["health"] -= 1
                    if enemy["health"] <= 0: enemy_died = True
                    else:
                        enemy["stopped"] = True
                        enemy["stop_start_time"] = current_time

            if enemy["health"] <= 0:
                enemy_died = True

        elif enemy["type"] == 6:
            dist1 = distance(enemy["x"]-enemy_size/2, enemy["y"]-enemy_size/2, player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"]-enemy_size/2, enemy["y"]-enemy_size/2, player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            if closest_dist > 200+enemy_size/2+player_size/2:
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]
                bounced = False
                if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: 
                    enemy["dx"] *= -1; bounced = True
                if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: 
                    enemy["dy"] *= -1; bounced = True
                if bounced:
                    enemy["bounces"] += 1; enemy["health"] -= 1
                if enemy["health"] <= 0: enemy_died = True


        elif enemy["type"] == 7:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if current_time - enemy["last_trail_time"] >= trail_interval_ms:
                trail_squares.append({
                    "x": int(enemy["x"]),
                    "y": int(enemy["y"]),
                    "spawn": current_time,
                    "health": 1,
                    "color": LAVA
                })
                enemy["last_trail_time"] = current_time
            if enemy["health"] <= 0: enemy_died = True

        elif enemy["type"] == 8:
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                if (enemy["target"] == 1 and (p1_dx or p1_dy)) or (enemy["target"] == 2 and (p2_dx or p2_dy)):
                    if player_frozen == True and enemy["target"] == 1:
                        enemy["x"] += enemy["sussy_dx"] * 0.5
                        enemy["y"] += enemy["sussy_dy"] * 0.5
                    elif player2_frozen == True and enemy["target"] == 2:
                        enemy["x"] += enemy["sussy_dx"] * 0.5
                        enemy["y"] += enemy["sussy_dy"] * 0.5
                    else:
                        enemy["x"] += enemy["sussy_dx"]
                        enemy["y"] += enemy["sussy_dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["sussy_dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["sussy_dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= impostor_hp or enemy["health"] <= 0:
                enemy_died = True

        elif enemy["type"] == 9:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            if enemy.get("spawn_protected"):
                if pygame.time.get_ticks() - enemy["spawn_time"] > 500:
                    enemy.pop("spawn_protected")

            hit_edge = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                hit_edge = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                hit_edge = True

            if hit_edge:
                if enemy.get("spawn_protected"):
                    if enemy["x"] < enemy_size/2 or enemy["x"] > WIDTH - enemy_size/2:
                        enemy["dx"] *= -1
                    if enemy["y"] < enemy_size/2 or enemy["y"] > HEIGHT - enemy_size/2:
                        enemy["dy"] *= -1
                    length = math.hypot(enemy["dx"], enemy["dy"])

                    if length != 0:
                        enemy["dx"] = (enemy["dx"] / length) * enemy_speed
                        enemy["dy"] = (enemy["dy"] / length) * enemy_speed
                else:
                    if enemy["health"] > 1:
                        for i in range(split_amount):
                            angle = random.uniform(0, 2 * math.pi)
                            dx = math.cos(angle) * enemy_speed
                            dy = math.sin(angle) * enemy_speed
                            enemies.append({
                                "x": max(1 + enemy_size/2, min(WIDTH - enemy_size/2 - 1, enemy["x"])),
                                "y": max(1 + enemy_size/2, min(HEIGHT - enemy_size/2 - 1, enemy["y"])),
                                "dx": dx,
                                "dy": dy,
                                "type": 9,
                                "angle": angle,
                                "bounces": 0,
                                "health": enemy["health"] - 1,
                                "spawn_protected": True,
                                "spawn_time": pygame.time.get_ticks()
                            })
                    enemy["dead"] = True
                continue
            if enemy.get("waiting"):
                # Check if off edge now
                if 0 < enemy["x"] < WIDTH - enemy_size and 0 < enemy["y"] < HEIGHT - enemy_size:
                    enemy.pop("waiting")

                    
        elif enemy["type"] == 10:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["health"] -= 1

            # Proximity trigger  bomb kills itself and explodes
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            if min(dist1, dist2) < 150+enemy_size/2+player_size/2:
                for i in range(bomb_projectile_amount):  # fire 8 projectiles in all directions
                    ang = i * (2 * math.pi / bomb_projectile_amount)
                    dxp = math.cos(ang) * bomb_projectile_speed
                    dyp = math.sin(ang) * bomb_projectile_speed
                    projectiles.append({
                        "x": enemy["x"] + projectile_size/2,
                        "y": enemy["y"] + projectile_size/2,
                        "dx": dxp,
                        "dy": dyp,
                        "color": MAUVE
                    })
                enemy["health"] = 0
            if enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 11:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced: 
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= shooter_hp or enemy["health"] <= 0:
                enemy_died = True

            # Shoot at player
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                dist = math.hypot(dxp, dyp)
                dxp = dxp / dist * shooter_projectile_speed
                dyp = dyp / dist * shooter_projectile_speed
                projectiles.append({
                    "x": enemy["x"] + projectile_size/2,
                    "y": enemy["y"] + projectile_size/2,
                    "dx": dxp,
                    "dy": dyp,
                    "color": BRONZE   # add color key
                })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 12:  # Get Sniped
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced: 
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= sniper_hp or enemy["health"] <= 0:
                enemy_died = True
            # Shoot at player
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                dist = math.hypot(dxp, dyp)
                dxp = dxp / dist * sniper_projectile_speed
                dyp = dyp / dist * sniper_projectile_speed
                projectiles.append({
                    "x": enemy["x"] + projectile_size/2,
                    "y": enemy["y"] + projectile_size/2,
                    "dx": dxp,
                    "dy": dyp,
                    "color": INDIGO
                })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 13:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= speedy_hp: enemy_died = True
        elif enemy["type"] == 14:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= shotgun_hp or enemy["health"] <= 0:
                enemy_died = True

            # --- Fire 5 bullets in a spread ---
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                base_angle = math.atan2(dyp, dxp)
                spread = math.radians(150/shotgun_bullets)  # total spread angle
                for i in range(shotgun_bullets):
                    angle_offset = spread * (i - (shotgun_bullets - 1)/2) / 4  # center + 2 on each side
                    ang = base_angle + angle_offset
                    projectiles.append({
                        "x": enemy["x"] + projectile_size/2,
                        "y": enemy["y"] + projectile_size/2,
                        "dx": math.cos(ang) * shotgun_projectile_speed,
                        "dy": math.sin(ang) * shotgun_projectile_speed,
                        "color": BRICK
                    })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 15:  # Magenta Voodoo
            if enemy.get("shrinking"):
                enemy["size"] = enemy.get("size", "enemy_size") * 0.85 if isinstance(enemy.get("size", None), (int, float)) else sz * 0.85
                # update local size variable for subsequent checks/drawing
                sz = enemy["size"]
                if enemy["size"] < 2:
                    # remove immediately once tiny
                    if enemy in enemies:
                        enemy["dead"] = True
                    continue
            # movement using current size (sz)
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= sz/2 or enemy["x"] >= WIDTH - sz/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= sz/2 or enemy["y"] >= HEIGHT - sz/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
                # when it loses all HP from bounces, player takes 1 damage
                if enemy["health"] <= 0:
                    if current_time >= invincible_until:
                        if enemy["target"] == 1:
                            player_lives -= enemy_damage
                            p1_regen_block_until = score + regen_delay
                        if enemy["target"] == 2:
                            player2_lives -= enemy_damage
                            p2_regen_block_until = score + regen_delay
                        damage_flash_time = current_time
                        invincible_until = current_time + invincibility_duration
                        if player_lives <= 0:
                            player_alive = False
                        if player2_lives <= 0:
                            player2_alive = False
                    enemy_died = True
        elif enemy["type"] == 16:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= blind_hp or enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 17:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= motion_hp or enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 18: #Charger
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            if enemy["stopped"]:
                if current_time - enemy["stop_start_time"] >= stickiness*4 or closest_dist < 350+enemy_size/2+player_size/2:
                    enemy["stopped"] = False
            else:
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                bounced = False
                if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                    enemy["dx"] *= -1
                    bounced = True
                if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                    enemy["dy"] *= -1
                    bounced = True

                if bounced:
                    enemy["health"] -= 1
                    if enemy["health"] <= 0:
                        enemy_died = True
                    else:
                        enemy["stopped"] = True
                        enemy["stop_start_time"] = current_time

            if enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 19:  # Rapid Shooter
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced: 
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= rapidshooter_hp or enemy["health"] <= 0:
                enemy_died = True

            # Shoot at player
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                dist = math.hypot(dxp, dyp)
                dxp = dxp / dist * rapidshooter_projectile_speed
                dyp = dyp / dist * rapidshooter_projectile_speed
                projectiles.append({
                    "x": enemy["x"] + projectile_size/2,
                    "y": enemy["y"] + projectile_size/2,
                    "dx": dxp,
                    "dy": dyp,
                    "color": GOLD   # add color key
                })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 20:  # Frostbite
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["health"] -= 1

            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            if min(dist1, dist2) < 150+enemy_size/2+player_size/2 and enemy["ability"] == 1:
                for i in range(frostbite_projectile_amount):
                    ang = i * (2 * math.pi / frostbite_projectile_amount)
                    dxp = math.cos(ang) * frostbite_projectile_speed
                    dyp = math.sin(ang) * frostbite_projectile_speed
                    projectiles.append({
                        "x": enemy["x"] + projectile_size/2,
                        "y": enemy["y"] + projectile_size/2,
                        "dx": dxp,
                        "dy": dyp,
                        "color": CYAN
                    })
                enemy["ability"] = 0
            if enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 21:
            if enemy.get("shrinking"):
                enemy["size"] = enemy.get("size", "enemy_size") * 0.85 if isinstance(enemy.get("size", None), (int, float)) else sz * 0.85
                # update local size variable for subsequent checks/drawing
                sz = enemy["size"]
                if enemy["size"] < 2:
                    # remove immediately once tiny
                    if enemy in enemies:
                        enemy["dead"] = True
                    continue
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
            if bounced:
                enemy["health"] -= 1
                if enemy["health"] <= 0:
                    enemy_died = True

            pull_radius = addictive_pull_radius
            base_pull_strength = addictive_pull_strength
            if player_alive and not enemy.get("shrinking"):
                dxp = enemy["x"] - player_x
                dyp = enemy["y"] - player_y
                dist = math.hypot(dxp, dyp)
                if dist < pull_radius-50+enemy_size/2+player_size/2 and dist > 1:
                    pull_strength = base_pull_strength * (1 - dist / (pull_radius-50+enemy_size/2+player_size/2))
                    player_x += (dxp / dist) * pull_strength
                    player_y += (dyp / dist) * pull_strength
            if players == 2 and player2_alive and not enemy.get("shrinking"):
                dxp = enemy["x"] - player2_x
                dyp = enemy["y"] - player2_y
                dist = math.hypot(dxp, dyp)
                if dist < pull_radius and dist > 1:
                    pull_strength = base_pull_strength * (1 - dist / pull_radius)
                    player2_x += (dxp / dist) * pull_strength
                    player2_y += (dyp / dist) * pull_strength
        elif enemy["type"] == 22:
            laser_extend = (60 / FPS) * (90)
            if not enemy.get("laser_mode", False):
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                hit_left = enemy["x"] <= enemy_size/2
                hit_right = enemy["x"] >= WIDTH - enemy_size/2
                hit_top = enemy["y"] <= enemy_size/2
                hit_bottom = enemy["y"] >= HEIGHT - enemy_size/2
                if hit_left or hit_right or hit_top or hit_bottom:
                    enemy["health"] -= 1

                    if enemy["health"] <= 0:
                        enemy["laser_mode"] = True
                        enemy["laser_start"] = pygame.time.get_ticks()
                        if hit_left or hit_right:
                            enemy["laser_orientation"] = "horizontal"
                            enemy["laser_x"] = enemy["x"]
                            enemy["laser_y"] = enemy["y"]
                            enemy["laser_length"] = enemy_size
                        if hit_top or hit_bottom:
                            enemy["laser_orientation"] = "vertical"
                            enemy["laser_x"] = enemy["x"]
                            enemy["laser_y"] = enemy["y"]
                            enemy["laser_length"] = enemy_size
                    else:
                        if hit_left or hit_right:
                            enemy["dx"] *= -1
                        if hit_top or hit_bottom:
                            enemy["dy"] *= -1
            else:
                enemy["laser_length"] += laser_extend
                if current_time - enemy["laser_start"] >= laser_duration:
                    enemy["dead"] = True
                    continue
                laser_width = enemy_size
                if enemy["laser_orientation"] == "vertical":
                    lx = enemy["laser_x"]
                    ly = enemy["laser_y"]
                    if player_alive:
                        if abs(player_x - lx) < (player_size/2 + enemy_size / 2) and abs(player_y - ly) < enemy["laser_length"] / 2:
                            if current_time >= invincible_until:
                                player_lives -= laser_damage
                                p1_regen_block_until = score + regen_delay
                                damage_flash_time = current_time
                                invincible_until = current_time + invincibility_duration
                                if player_lives <= 0: player_alive = False

                    if players == 2 and player2_alive:
                        if abs(player2_x - lx) < (player_size/2 + enemy_size / 2) and abs(player2_y - ly) < enemy["laser_length"] / 2:
                            if current_time >= player2_invincible_until:
                                player2_lives -= laser_damage
                                p2_regen_block_until = score + regen_delay
                                player2_damage_flash_time = current_time
                                player2_invincible_until = current_time + invincibility_duration
                                if player2_lives <= 0: player2_alive = False
                elif enemy["laser_orientation"] == "horizontal":
                    lx = enemy["laser_x"]
                    ly = enemy["laser_y"]
                    if player_alive:
                        if abs(player_y - ly) < (player_size/2 + enemy_size / 2) and abs(player_x - lx) < enemy["laser_length"] / 2:
                            if current_time >= invincible_until:
                                player_lives -= laser_damage
                                p1_regen_block_until = score + regen_delay
                                damage_flash_time = current_time
                                invincible_until = current_time + invincibility_duration
                                if player_lives <= 0: player_alive = False

                    if players == 2 and player2_alive:
                        if abs(player2_y - ly) < (player_size/2 + enemy_size / 2) and abs(player2_x - lx) < enemy["laser_length"] / 2:
                            if current_time >= player2_invincible_until:
                                player2_lives -= laser_damage
                                p2_regen_block_until = score + regen_delay
                                player2_damage_flash_time = current_time
                                player2_invincible_until = current_time + invincibility_duration
                                if player2_lives <= 0: player2_alive = False
                continue



            
        elif enemy["type"] == 23:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True

            

            hardened_dps = 0.1 * (60 / FPS) * (harden_break / 10)

            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999

            if dist1 < 250+enemy_size/2+player_size/2:
                enemy["health"] -= hardened_dps
                if enemy["health"] < 1:
                    enemy["health"] = 1
            if dist2 < 250+enemy_size/2+player_size/2:
                enemy["health"] -= hardened_dps
                if enemy["health"] < 1:
                    enemy["health"] = 1
            if bounced:
                enemy["health"] -= 1
            if enemy["health"] < 1:
                enemy_died = True
        elif enemy["type"] == 24:
            enemy["accel"] += enemy.get("accel_rate", 0.02)
            vx = enemy.get("base_dx", enemy["dx"]) * enemy["accel"]
            vy = enemy.get("base_dy", enemy["dy"]) * enemy["accel"]

            speed_cap = enemy_speed * 1.5  # from your game settings
            speed = math.hypot(vx, vy)
            if speed > speed_cap:
                scale = speed_cap / speed
                vx *= scale
                vy *= scale

            enemy["dx"] = vx
            enemy["dy"] = vy
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]

            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["base_dx"] *= -1
                bounced = True
                if enemy["x"] <= enemy_size: enemy["x"] = enemy_size/2 + enemy["base_dx"]
                elif enemy["x"] >= WIDTH - enemy_size: enemy["x"] = WIDTH - enemy_size/2 + enemy["base_dx"]
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["base_dy"] *= -1
                bounced = True
                if enemy["y"] <= enemy_size: enemy["y"] = enemy_size/2 + enemy["base_dy"]
                elif enemy["y"] >= HEIGHT - enemy_size: enemy["y"] = HEIGHT - enemy_size/2 + enemy["base_dy"]

            if bounced:
                enemy["accel"] = 0.0
                enemy["dx"] = 0
                enemy["dy"] = 0
                enemy["bounces"] += 1
                enemy["health"] -= 1

            if enemy["bounces"] >= accelerator_hp or enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 25:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["dy"] *= -1; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= cold_hp: enemy_died = True
        elif enemy["type"] == 26:
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                dx = tx - enemy["x"]; dy = ty - enemy["y"]
            else:
                dx, dy = 0, 0
            target_angle = math.atan2(dy, dx)
            enemy["angle"] = rotate_toward(enemy["angle"], target_angle, chase_turn/250)
            enemy["dx"] = math.cos(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["dy"] = math.sin(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["angle"] = math.pi - enemy["angle"]; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["angle"] = -enemy["angle"]; bounced = True
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if current_time - enemy["last_trail_time"] >= trail_interval_ms:
                trail_squares.append({
                    "x": int(enemy["x"]),
                    "y": int(enemy["y"]),
                    "spawn": current_time,
                    "health": 1,
                    "color": SULFUR
                })
                enemy["last_trail_time"] = current_time
            if enemy["bounces"] >= tracer_hp: enemy_died = True
        elif enemy["type"] == 27:
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            speed_multiplier = 2.5 if closest_dist < 200+enemy_size/2+player_size/2 else 2/3
            
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                dx = tx - enemy["x"]; dy = ty - enemy["y"]
            else:
                dx, dy = 0, 0
            target_angle = math.atan2(dy, dx)
            enemy["angle"] = rotate_toward(enemy["angle"], target_angle, chase_turn/500)
            enemy["dx"] = math.cos(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["dy"] = math.sin(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["x"] += enemy["dx"] * speed_multiplier; enemy["y"] += enemy["dy"] * speed_multiplier
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["angle"] = math.pi - enemy["angle"]; bounced = True
                if enemy["x"] <= 0: enemy["x"] = 0
                elif enemy["x"] >= WIDTH - enemy_size: enemy["x"] = WIDTH - enemy_size/2
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["angle"] = -enemy["angle"]; bounced = True
                if enemy["y"] <= 0: enemy["y"] = 0
                elif enemy["y"] >= HEIGHT - enemy_size: enemy["y"] = HEIGHT - enemy_size/2
            if bounced: enemy["bounces"] += 1; enemy["health"] -= 1
            if enemy["bounces"] >= savage_hp: enemy_died = True
        elif enemy["type"] == 28:
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
                enemy["x"] = spawner_pos[0]+25
                enemy["y"] = spawner_pos[1]+25
            if enemy["bounces"] >= teleporter_hp: enemy_died = True
        elif enemy["type"] == 29:
            target_pos = get_target_position(enemy)
            if target_pos:
                tx, ty = target_pos
                dx = tx - enemy["x"]; dy = ty - enemy["y"]
            else:
                dx, dy = 0, 0
            target_angle = math.atan2(dy, dx)
            enemy["angle"] = rotate_toward(enemy["angle"], target_angle, chase_turn/250)
            enemy["dx"] = math.cos(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["dy"] = math.sin(enemy["angle"]) * (enemy_speed * 0.7)
            enemy["x"] += enemy["dx"]; enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["angle"] = math.pi - enemy["angle"]; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["angle"] = -enemy["angle"]; bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
                enemy["x"] = spawner_pos[0]+25
                enemy["y"] = spawner_pos[1]+25
            if enemy["bounces"] >= haunter_hp: enemy_died = True
        elif enemy["type"] == 30:
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            speed_multiplier = 2.5 if closest_dist < 200+enemy_size/2+player_size/2 else 2/3
            enemy["x"] += enemy["dx"] * speed_multiplier
            enemy["y"] += enemy["dy"] * speed_multiplier
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2: enemy["angle"] = math.pi - enemy["angle"]; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2: enemy["angle"] = -enemy["angle"]; bounced = True
            if bounced:
                enemy["bounces"] += 1
                enemy["health"] -= 1
                enemy["x"] = spawner_pos[0]+25
                enemy["y"] = spawner_pos[1]+25
            if enemy["bounces"] >= stream_hp or enemy["health"] <= 0:
                enemy_died = True
        elif enemy["type"] == 31:
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            speed_multiplier = 2.5 if closest_dist < 200+enemy_size/2+player_size/2 else 2/3
            enemy["x"] += enemy["dx"] * speed_multiplier
            enemy["y"] += enemy["dy"] * speed_multiplier
            bounced = False
            # X-axis bounce
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1
                bounced = True
                if enemy["x"] <= 0: enemy["x"] = 0
                elif enemy["x"] >= WIDTH - enemy_size: enemy["x"] = WIDTH - enemy_size/2
            # Y-axis bounce
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1
                bounced = True
                if enemy["y"] <= 0: enemy["y"] = 0
                elif enemy["y"] >= HEIGHT - enemy_size: enemy["y"] = HEIGHT - enemy_size/2
            hardened_dps = 0.1 * (60 / FPS) * (harden_break / 10)
            if dist1 < 200+enemy_size/2+player_size/2:
                enemy["health"] -= hardened_dps
                if enemy["health"] < 1:
                    enemy["health"] = 1
            if dist2 < 150+enemy_size/2+player_size/2:
                enemy["health"] -= hardened_dps
                if enemy["health"] < 1:
                    enemy["health"] = 1
            if bounced:
                enemy["health"] -= 1
                enemy["bounces"] += 1
            if enemy["health"] < 1:
                enemy_died = True
        elif enemy["type"] == 32:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced: 
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= burstshooter_hp or enemy["health"] <= 0:
                enemy_died = True
            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"] or (current_time - enemy["last_shot_time"] >= 50 and enemy["bursts left"] > 1):
                if enemy["bursts left"] < 2: enemy["bursts left"] = enemy["bursts"]
                else: enemy["bursts left"] -= 1
                target_pos = get_target_position(enemy)
                if target_pos:
                    tx, ty = target_pos
                else:
                    tx, ty = player_x, player_y
                dxp = tx - (enemy["x"])
                dyp = ty - (enemy["y"])
                dist = math.hypot(dxp, dyp)
                dxp = dxp / dist * burstshooter_projectile_speed
                dyp = dyp / dist * burstshooter_projectile_speed
                projectiles.append({
                    "x": enemy["x"] + projectile_size/2,
                    "y": enemy["y"] + projectile_size/2,
                    "dx": dxp,
                    "dy": dyp,
                    "color": SILVER   # add color key
                })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 33: #Stickyshooter
            dist1 = distance(enemy["x"], enemy["y"], player_x, player_y) if player_alive else 9999
            dist2 = distance(enemy["x"], enemy["y"], player2_x, player2_y) if players == 2 and player2_alive else 9999
            closest_dist = min(dist1, dist2)
            if enemy["stopped"]:
                if current_time - enemy["stop_start_time"] >= stickiness*4 or closest_dist < 350+enemy_size/2+player_size/2:
                    enemy["stopped"] = False
                if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                    target_pos = get_target_position(enemy)
                    if target_pos:
                        tx, ty = target_pos
                    else:
                        tx, ty = player_x, player_y
                    dxp = tx - (enemy["x"])
                    dyp = ty - (enemy["y"])
                    dist = math.hypot(dxp, dyp)
                    dxp = dxp / dist * shooter_projectile_speed
                    dyp = dyp / dist * shooter_projectile_speed
                    projectiles.append({
                        "x": enemy["x"] + projectile_size/2,
                        "y": enemy["y"] + projectile_size/2,
                        "dx": dxp,
                        "dy": dyp,
                        "color": OLIVE   # add color key
                    })
                    enemy["last_shot_time"] = current_time
            else:
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                bounced = False
                if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                    enemy["dx"] *= -1
                    bounced = True
                if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                    enemy["dy"] *= -1
                    bounced = True

                if bounced:
                    enemy["health"] -= 1
                    if enemy["health"] <= 0:
                        enemy_died = True
                    else:
                        enemy["stopped"] = True
                        enemy["stop_start_time"] = current_time

            if enemy["health"] <= 0:
                enemy_died = True
                
        elif enemy["type"] == 34:
            enemy["x"] += enemy["dx"]
            enemy["y"] += enemy["dy"]
            bounced = False
            if enemy["x"] <= enemy_size/2 or enemy["x"] >= WIDTH - enemy_size/2:
                enemy["dx"] *= -1; bounced = True
            if enemy["y"] <= enemy_size/2 or enemy["y"] >= HEIGHT - enemy_size/2:
                enemy["dy"] *= -1; bounced = True
            if bounced: 
                enemy["bounces"] += 1
                enemy["health"] -= 1
            if enemy["bounces"] >= sparker_hp or enemy["health"] <= 0:
                enemy_died = True

            if current_time - enemy["last_shot_time"] >= enemy["shoot_delay"]:
                angle = random.uniform(0, math.tau)
                dxp = math.cos(angle)
                dyp = math.sin(angle)
                dist = math.hypot(dxp, dyp)
                dxp = dxp / dist * sparker_projectile_speed
                dyp = dyp / dist * sparker_projectile_speed
                projectiles.append({
                    "x": enemy["x"] + projectile_size/2,
                    "y": enemy["y"] + projectile_size/2,
                    "dx": dxp,
                    "dy": dyp,
                    "color": VOLT   # add color key
                })
                enemy["last_shot_time"] = current_time
        elif enemy["type"] == 35:
            if enemy.get("shrinking"):
                enemy["size"] = enemy.get("size", "enemy_size") * 0.85 if isinstance(enemy.get("size", None), (int, float)) else sz * 0.85
            sz = enemy["size"]
            if enemy["size"] < 2:
                # remove immediately once tiny
                if enemy in enemies:
                    enemy["dead"] = True
                continue
            laser_extend = (60 / FPS) * (90)
            if not enemy.get("laser_mode", False):
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                hit_left = enemy["x"] <= enemy_size/2
                hit_right = enemy["x"] >= WIDTH - enemy_size/2
                hit_top = enemy["y"] <= enemy_size/2
                hit_bottom = enemy["y"] >= HEIGHT - enemy_size/2
                if hit_left or hit_right or hit_top or hit_bottom:
                    enemy["health"] -= 1

                    if enemy["health"] <= 0:
                        for i in range(annihilator_projectile_amount):  # fire 8 projectiles in all directions
                            ang = i * (2 * math.pi / annihilator_projectile_amount)
                            dxp = math.cos(ang) * annihilator_projectile_speed
                            dyp = math.sin(ang) * annihilator_projectile_speed
                            projectiles.append({
                                "x": enemy["x"] + projectile_size/2,
                                "y": enemy["y"] + projectile_size/2,
                                "dx": dxp,
                                "dy": dyp,
                                "color": HOT_PINK
                            })
                        enemy["laser_mode"] = True
                        enemy["laser_start"] = pygame.time.get_ticks()
                        if hit_left or hit_right:
                            enemy["laser_orientation"] = "horizontal"
                            enemy["laser_x"] = enemy["x"]
                            enemy["laser_y"] = enemy["y"]
                            enemy["laser_length"] = enemy_size
                        if hit_top or hit_bottom:
                            enemy["laser_orientation"] = "vertical"
                            enemy["laser_x"] = enemy["x"]
                            enemy["laser_y"] = enemy["y"]
                            enemy["laser_length"] = enemy_size
                    else:
                        if hit_left or hit_right:
                            enemy["dx"] *= -1
                        if hit_top or hit_bottom:
                            enemy["dy"] *= -1
            else:
                enemy["laser_length"] += laser_extend
                if current_time - enemy["laser_start"] >= laser_duration:
                    enemy["dead"] = True
                    continue
                laser_width = enemy_size
                if enemy["laser_orientation"] == "vertical":
                    lx = enemy["laser_x"]
                    ly = enemy["laser_y"]
                    if player_alive:
                        if abs(player_x - lx) < (player_size/2 + enemy_size / 2) and abs(player_y - ly) < enemy["laser_length"] / 2:
                            if current_time >= invincible_until + 100:
                                player_lives -= laser_damage
                                p1_regen_block_until = score + regen_delay
                                damage_flash_time = current_time
                                invincible_until = current_time + invincibility_duration
                                if player_lives <= 0: player_alive = False

                    if players == 2 and player2_alive:
                        if abs(player2_x - lx) < (player_size/2 + enemy_size / 2) and abs(player2_y - ly) < enemy["laser_length"] / 2:
                            if current_time >= player2_invincible_until + 100:
                                player2_lives -= laser_damage
                                p2_regen_block_until = score + regen_delay
                                player2_damage_flash_time = current_time
                                player2_invincible_until = current_time + invincibility_duration
                                if player2_lives <= 0: player2_alive = False
                elif enemy["laser_orientation"] == "horizontal":
                    lx = enemy["laser_x"]
                    ly = enemy["laser_y"]
                    if player_alive:
                        if abs(player_y - ly) < (player_size/2 + enemy_size / 2) and abs(player_x - lx) < enemy["laser_length"] / 2:
                            if current_time >= invincible_until + 100:
                                player_lives -= laser_damage
                                p1_regen_block_until = score + regen_delay
                                damage_flash_time = current_time
                                invincible_until = current_time + invincibility_duration
                                if player_lives <= 0: player_alive = False

                    if players == 2 and player2_alive:
                        if abs(player2_y - ly) < (player_size/2 + enemy_size / 2) and abs(player2_x - lx) < enemy["laser_length"] / 2:
                            if current_time >= player2_invincible_until + 100:
                                player2_lives -= laser_damage
                                p2_regen_block_until = score + regen_delay
                                player2_damage_flash_time = current_time
                                player2_invincible_until = current_time + invincibility_duration
                                if player2_lives <= 0: player2_alive = False
                continue
        elif enemy["type"] == 36:
            laser_extend = (60 / FPS) * (90)
            if not enemy.get("laser_mode", False):
                enemy["x"] += enemy["dx"]
                enemy["y"] += enemy["dy"]

                hit_left = enemy["x"] <= enemy_size/2
                hit_right = enemy["x"] >= WIDTH - enemy_size/2
                hit_top = enemy["y"] <= enemy_size/2
                hit_bottom = enemy["y"] >= HEIGHT - enemy_size/2
                if hit_left or hit_right or hit_top or hit_bottom:
                    enemy["health"] -= 1

                    if enemy["health"] <= 0:
                        enemy["laser_mode"] = True
                        enemy["laser_start"] = pygame.time.get_ticks()
                        if hit_left or hit_right:
                            enemy["laser_orientation"] = "horizontal"
                            enemy["laser_x"] = enemy["x"]
                            enemy["laser_y"] = enemy["y"]
                            enemy["laser_length"] = enemy_size
                        if hit_top or hit_bottom:
                            enemy["laser_orientation"] = "vertical"
                            enemy["laser_x"] = enemy["x"]
                            enemy["laser_y"] = enemy["y"]
                            enemy["laser_length"] = enemy_size
                    else:
                        if hit_left or hit_right:
                            enemy["dx"] *= -1
                        if hit_top or hit_bottom:
                            enemy["dy"] *= -1
            else:
                enemy["laser_length"] += laser_extend
                if current_time - enemy["laser_start"] >= laser_duration:
                    enemy["dead"] = True
                    continue
                laser_width = enemy_size
                if enemy["laser_orientation"] == "vertical":
                    lx = enemy["laser_x"]
                    ly = enemy["laser_y"]
                    if player_alive:
                        if abs(player_x - lx) < (player_size/2 + enemy_size / 2) and abs(player_y - ly) < enemy["laser_length"] / 2:
                            slow_until = current_time + freeze_duration
                            player_speed = player_speed_base / 2
                            player_frozen = True
                            if current_time >= invincible_until + 100:
                                player_lives -= laser_damage
                                p1_regen_block_until = score + regen_delay
                                damage_flash_time = current_time
                                invincible_until = current_time + invincibility_duration
                                if player_lives <= 0: player_alive = False

                    if players == 2 and player2_alive:
                        if abs(player2_x - lx) < (player_size/2 + enemy_size / 2) and abs(player2_y - ly) < enemy["laser_length"] / 2:
                            player2_slow_until = current_time + freeze_duration
                            player2_speed = player2_speed_base / 2
                            player2_frozen = True
                            if current_time >= player2_invincible_until + 100:
                                player2_lives -= laser_damage
                                p2_regen_block_until = score + regen_delay
                                player2_damage_flash_time = current_time
                                player2_invincible_until = current_time + invincibility_duration
                                if player2_lives <= 0: player2_alive = False
                elif enemy["laser_orientation"] == "horizontal":
                    lx = enemy["laser_x"]
                    ly = enemy["laser_y"]
                    if player_alive:
                        if abs(player_y - ly) < (player_size/2 + enemy_size / 2) and abs(player_x - lx) < enemy["laser_length"] / 2:
                            slow_until = current_time + freeze_duration
                            player_speed = player_speed_base / 2
                            player_frozen = True
                            if current_time >= invincible_until + 100:
                                player_lives -= laser_damage
                                p1_regen_block_until = score + regen_delay
                                damage_flash_time = current_time
                                invincible_until = current_time + invincibility_duration
                                if player_lives <= 0: player_alive = False

                    if players == 2 and player2_alive:
                        if abs(player2_y - ly) < (player_size/2 + enemy_size / 2) and abs(player2_x - lx) < enemy["laser_length"] / 2:
                            player2_slow_until = current_time + freeze_duration
                            player2_speed = player2_speed_base / 2
                            player2_frozen = True
                            if current_time >= player2_invincible_until + 100:
                                player2_lives -= laser_damage
                                p2_regen_block_until = score + regen_delay
                                player2_damage_flash_time = current_time
                                player2_invincible_until = current_time + invincibility_duration
                                if player2_lives <= 0: player2_alive = False
                continue













        if player_alive and centered_rect_collision(player_x, player_y, player_size,
                                            enemy["x"], enemy["y"], enemy_size):
            if enemy["type"] == 17:
                if not player_moving:  # Only damages if player is still
                    if current_time >= invincible_until:
                        player_lives -= enemy_damage
                        p1_regen_block_until = score + regen_delay
                        damage_flash_time = current_time
                        invincible_until = current_time + invincibility_duration
                        enemy["dead"] = True
                        if player_lives <= 0:
                            player_alive = False
                continue
            elif enemy["type"] == 16:
                if player_moving:  # Only damages if player is moving
                    if current_time >= invincible_until:
                        player_lives -= enemy_damage
                        p1_regen_block_until = score + regen_delay
                        damage_flash_time = current_time
                        invincible_until = current_time + invincibility_duration
                        enemy["dead"] = True
                        if player_lives <= 0:
                            player_alive = False
                continue
            elif enemy["type"] == 15 or enemy["type"] == 35 or enemy["type"] == 21:
                if not enemy.get("shrinking", False):
                    enemy["shrinking"] = True
                continue
            elif enemy["type"] == 25:
                slow_until = current_time + freeze_duration
                player_speed = player_speed_base / 2
                player_frozen = True
            elif enemy["type"] == 3:
                player_lives = 0
                player_alive = False
            else:
                if current_time >= invincible_until:
                    player_lives -= enemy_damage
                    p1_regen_block_until = score + regen_delay
                    damage_flash_time = current_time
                    invincible_until = current_time + invincibility_duration
                    enemy["dead"] = True
                    if player_lives <= 0:
                        player_alive = False
                continue
                                
        if players == 2 and player2_alive and centered_rect_collision(player2_x, player2_y, player_size,
                                                                      enemy["x"], enemy["y"], enemy_size):
            if enemy["type"] == 17:
                if p2_dx == 0 and p2_dy == 0:  # not moving
                    if current_time >= player2_invincible_until:
                        player2_lives -= enemy_damage
                        p2_regen_block_until = score + regen_delay
                        player2_damage_flash_time = current_time
                        player2_invincible_until = current_time + invincibility_duration
                        enemy["dead"] = True
                        if player2_lives <= 0:
                            player2_alive = False
                continue
            elif enemy["type"] == 16:
                if (p2_dx != 0 or p2_dy != 0):
                    if current_time >= player2_invincible_until:
                        player2_lives -= enemy_damage
                        p2_regen_block_until = score + regen_delay
                        player2_damage_flash_time = current_time
                        player2_invincible_until = current_time + invincibility_duration
                        enemy["dead"] = True
                        if player2_lives <= 0:
                            player2_alive = False
                continue
            elif enemy["type"] == 15 or enemy["type"] == 35 or enemy["type"] == 21:
                if not enemy.get("shrinking", False):
                    enemy["shrinking"] = True
                continue
            elif enemy["type"] == 25:
                player2_slow_until = current_time + freeze_duration
                player2_speed = player2_speed_base / 2
                player2_frozen = True
            elif enemy["type"] == 3:
                player2_lives = 0
                player2_alive = False
            else:
                if current_time >= player2_invincible_until:
                    player2_lives -= enemy_damage
                    p2_regen_block_until = score + regen_delay
                    player2_damage_flash_time = current_time
                    player2_invincible_until = current_time + invincibility_duration
                    enemy["dead"] = True
                    if player2_lives <= 0:
                        player2_alive = False
            continue
        if not player_alive and (players == 1 or not player2_alive):
            result = GAME_OVER(truescore, score_p1, score_p2)
            if result == "TITLE":
                TITLE_SCREEN()
                continue
            running = False
            break

        
        if enemy_died:
            if enemy in enemies:
                enemy["dead"] = True


    # --- Trail squares update ---
    new_trails = []
    for sq in trail_squares:
        if current_time - sq["spawn"] > trail_lifetime_ms:
            continue
        if player_alive and centered_rect_collision(player_x, player_y, player_size,
                                                    sq["x"], sq["y"], trail_size):
            if current_time >= invincible_until:
                player_lives -= projectile_damage
                p1_regen_block_until = score + regen_delay
                damage_flash_time = current_time
                invincible_until = current_time + invincibility_duration
                if player_lives <= 0:
                    player_alive = False
                    break
            sq["health"] -= 1
            if sq["health"] > 0:
                new_trails.append(sq)
            continue
        if players == 2 and player2_alive and centered_rect_collision(player2_x, player2_y, player_size,
                                                              sq["x"], sq["y"], trail_size):
            if current_time >= player2_invincible_until:
                player2_lives -= projectile_damage
                p2_regen_block_until = score + regen_delay
                player2_damage_flash_time = current_time
                player2_invincible_until = current_time + invincibility_duration
                if player2_lives <= 0:
                    player2_alive = False
                    break
            sq["health"] -= 1
            if sq["health"] > 0:
                new_trails.append(sq)
            continue
        new_trails.append(sq)
    trail_squares = new_trails

    # --- Projectiles movement ---
    new_projectiles = []
    for p in projectiles:
        # move (p stores center coordinates)
        p["x"] += p["dx"]
        p["y"] += p["dy"]

        # center-to-center collision test (more reliable with mixed coordinate conventions)
        player_cx = player_x + player_size / 2
        player_cy = player_y + player_size / 2
        proj_cx = p["x"]
        proj_cy = p["y"]

        # collision if distance < sum of radii
        if player_alive and centered_rect_collision(player_x, player_y, player_size,
                                                    p["x"] - projectile_size/2, p["y"] - projectile_size/2, projectile_size):
            if p.get("color") == CYAN:
                slow_until = current_time + freeze_duration  # 10 seconds
                player_speed = player_speed_base / 2
                player_frozen = True
            elif p.get("color") == INDIGO:
                if current_time >= invincible_until:
                    player_lives -= projectile_damage + extra_sniper_damage
                    p1_regen_block_until = score + regen_delay
                    damage_flash_time = current_time
                    invincible_until = current_time + invincibility_duration
                    if player_lives <= 0:
                        player_alive = False
                        break
                continue
            else:
                if current_time >= invincible_until:
                    player_lives -= projectile_damage
                    p1_regen_block_until = score + regen_delay
                    damage_flash_time = current_time
                    invincible_until = current_time + invincibility_duration
                    if player_lives <= 0:
                        player_alive = False
                        break
                continue
        if players == 2:
            player2_cx = player2_x + player_size / 2
            player2_cy = player2_y + player_size / 2
            if player2_alive and centered_rect_collision(player2_x, player2_y, player_size,
                                                    p["x"] - projectile_size/2, p["y"] - projectile_size/2, projectile_size):
                if p.get("color") == CYAN:
                    player2_slow_until = current_time + freeze_duration
                    player2_speed = player2_speed_base / 2
                    player2_frozen = True
                elif p.get("color") == INDIGO:
                    if current_time >= player2_invincible_until:
                        player2_lives -= projectile_damage + extra_sniper_damage
                        p2_regen_block_until = score + regen_delay
                        player2_damage_flash_time = current_time
                        player2_invincible_until = current_time + invincibility_duration
                        if player2_lives <= 0:
                            player2_alive = False
                            break
                    continue
                else:
                    if current_time >= player2_invincible_until:
                        player2_lives -= projectile_damage
                        p2_regen_block_until = score + regen_delay
                        player2_damage_flash_time = current_time
                        player2_invincible_until = current_time + invincibility_duration
                        if player2_lives <= 0:
                            player2_alive = False
                            break
                    continue

        # Keep projectile on screen (using center coords)
        if 0 - projectile_size < p["x"] < WIDTH + projectile_size and 0 - projectile_size < p["y"] < HEIGHT + projectile_size:
            new_projectiles.append(p)

    projectiles = new_projectiles

    enemies[:] = [e for e in enemies if not e.get("dead", False)]


    # --- Drawing ---
    screen.fill(BLACK)

    # draw spawner
    pygame.draw.rect(screen, BLACK, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE))
    pygame.draw.rect(screen, CRISP, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE), 3)


        # --- FULL SPAWNER INDICATOR --
    center = (spawner_pos[0] + SPAWNER_SIZE // 2,
        spawner_pos[1] + SPAWNER_SIZE // 2)

    if spawn_enabled:
        # Normal pulse + rotation once spawning starts
        indicator_ratio = min(1.0, (current_time - last_spawn_time) / spawn_delay)

        def lerp_color(c1, c2, t):
            return tuple(int(c1[i] + (c2[i] - c1[i]) * t) for i in range(3))

        pulse_color = lerp_color(CRISP, RED, indicator_ratio)

        # Glow
        glow_size = SPAWNER_SIZE * 4
        glow_surface = pygame.Surface((glow_size, glow_size), pygame.SRCALPHA).convert_alpha()
        alpha = int(40 + 180 * indicator_ratio)
        start_glow_radius = SPAWNER_SIZE * 2
        end_glow_radius = SPAWNER_SIZE // 2
        glow_radius = int(start_glow_radius * (1 - indicator_ratio) + end_glow_radius * indicator_ratio)
        r, g, b = pulse_color[:3]
        r = max(0, min(255, int(r)))
        g = max(0, min(255, int(g)))
        b = max(0, min(255, int(b)))
        safe_alpha = max(0, min(255, int(alpha)))
        pygame.draw.circle(glow_surface, (r, g, b, safe_alpha),
                           (glow_size // 2, glow_size // 2), glow_radius)
        screen.blit(glow_surface, (center[0] - glow_size // 2, center[1] - glow_size // 2))

        # Rotating arcs
        angle_progress = current_time / 500.0
        arc_radius = glow_radius + 5
        for i in range(3):
            start_angle = angle_progress + i * (2 * math.pi / 3)
            end_angle = start_angle + math.pi / 4
            r, g, b = pulse_color[:3]
            r = max(0, min(255, int(r)))
            g = max(0, min(255, int(g)))
            b = max(0, min(255, int(b)))
            safe_color = (r, g, b)
            pygame.draw.arc(screen, safe_color,
                            (center[0] - arc_radius, center[1] - arc_radius,
                             arc_radius * 2, arc_radius * 2),
                            start_angle, end_angle, 5)
    else:
        # Dormant look before player moves
        pulse_color = CRISP
        pygame.draw.rect(screen, pulse_color, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE), 3)
        pygame.draw.circle(screen, pulse_color, center, SPAWNER_SIZE // 2, 2)


    frost_overlay = pygame.Surface((player_size + 10, player_size + 10), pygame.SRCALPHA)
    frost_overlay.fill((175, 255, 255, 180))


    # --- spawner core ---
    pygame.draw.rect(screen, BLACK, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE))
    pygame.draw.rect(screen, CRISP, (*spawner_pos, SPAWNER_SIZE, SPAWNER_SIZE), 3)

    # draw trail squares
    for sq in trail_squares:
        color = sq.get("color", LAVA)
        pygame.draw.rect(screen, color, (sq["x"] - trail_size // 2, sq["y"] - trail_size // 2, trail_size, trail_size))

    # draw projectiles
    for p in projectiles:
        color = p.get("color", HOT_PINK)
        draw_x = int(p["x"] - projectile_size / 2)
        draw_y = int(p["y"] - projectile_size / 2)
        pygame.draw.rect(screen, color, (draw_x - projectile_size//2, draw_y - projectile_size//2, projectile_size, projectile_size))

    # draw enemies
    for enemy in enemies:
        if enemy["type"] == 15: color = MAGENTA
        elif modifiers[0] == 1: color = GRAY
        elif modifiers[0] == 2: color = RED
        elif modifiers[0] == 3: color = WHITE
        elif modifiers[0] == 0:
            if enemy["type"] == 1: color = GRAY
            elif enemy["type"] == 2: color = SALMON
            elif enemy["type"] == 3: color = RED
            elif enemy["type"] == 4: color = AZURE
            elif enemy["type"] == 5: color = GREEN
            elif enemy["type"] == 6: color = VIOLET
            elif enemy["type"] == 7: color = LAVA
            elif enemy["type"] == 8:
                if enemy["target"] == 1: color = player_skins[p1_skin_color]
                if enemy["target"] == 2: color = player_skins[p2_skin_color]
                else: color = WHITE
            elif enemy["type"] == 9: color = LIME
            elif enemy["type"] == 10: color = MAUVE
            elif enemy["type"] == 11: color = BRONZE
            elif enemy["type"] == 12: color = INDIGO
            elif enemy["type"] == 13: color = SKY
            elif enemy["type"] == 14: color = BRICK
            elif enemy["type"] == 16: color = BLUE
            elif enemy["type"] == 17: color = ORANGE
            elif enemy["type"] == 18: color = YELLOW
            elif enemy["type"] == 19: color = GOLD
            elif enemy["type"] == 20: color = CYAN
            elif enemy["type"] == 21: color = PINK
            elif enemy["type"] == 22: color = TURQUOISE
            elif enemy["type"] == 23: color = BROWN
            elif enemy["type"] == 24: color = TAN
            elif enemy["type"] == 25: color = TEAL
            elif enemy["type"] == 26: color = SULFUR
            elif enemy["type"] == 27: color = MAROON
            elif enemy["type"] == 28: color = PURPLE
            elif enemy["type"] == 29: color = NAVY
            elif enemy["type"] == 30: color = AQUA
            elif enemy["type"] == 31: color = LAVENDER
            elif enemy["type"] == 32: color = SILVER
            elif enemy["type"] == 33: color = OLIVE
            elif enemy["type"] == 34: color = VOLT
            elif enemy["type"] == 35: color = HOT_PINK
            elif enemy["type"] == 36: color = ICE


        
        if enemy["type"] == 22 and enemy.get("laser_mode", False):
            if enemy["laser_orientation"] == "vertical":
                pygame.draw.rect(screen, TURQUOISE, (enemy["laser_x"]-enemy_size/2, enemy["laser_y"]-enemy["laser_length"]/2, enemy_size, enemy["laser_length"]))

            elif enemy["laser_orientation"] == "horizontal": #enemy["laser_length"]
                pygame.draw.rect(screen, TURQUOISE, (enemy["laser_x"]-enemy["laser_length"]/2, enemy["laser_y"]-enemy_size/2, enemy["laser_length"], enemy_size))
            continue

        if enemy["type"] == 35 and enemy.get("laser_mode", False):
            if enemy["laser_orientation"] == "vertical":
                pygame.draw.rect(screen, HOT_PINK, (enemy["laser_x"]-enemy_size/2, enemy["laser_y"]-enemy["laser_length"]/2, enemy_size, enemy["laser_length"]))

            elif enemy["laser_orientation"] == "horizontal": #enemy["laser_length"]
                pygame.draw.rect(screen, HOT_PINK, (enemy["laser_x"]-enemy["laser_length"]/2, enemy["laser_y"]-enemy_size/2, enemy["laser_length"], enemy_size))
            continue
        
        if enemy["type"] == 36 and enemy.get("laser_mode", False):
            if enemy["laser_orientation"] == "vertical":
                pygame.draw.rect(screen, ICE, (enemy["laser_x"]-enemy_size/2, enemy["laser_y"]-enemy["laser_length"]/2, enemy_size, enemy["laser_length"]))

            elif enemy["laser_orientation"] == "horizontal": #enemy["laser_length"]
                pygame.draw.rect(screen, ICE, (enemy["laser_x"]-enemy["laser_length"]/2, enemy["laser_y"]-enemy_size/2, enemy["laser_length"], enemy_size))
            continue


        sz = int(enemy.get("size", enemy_size))
        pygame.draw.rect(
            screen,
            color,
            (enemy["x"] - sz // 2,
             enemy["y"] - sz // 2,
             sz,
             sz)
        )

        if players == 1:
            if enemy["type"] == 8: enemy_text_color = player_skins[p1_skin_color + 1]
            else: enemy_text_color = BLACK
        elif players == 2:
            if enemy["type"] in targetting_enemies:
                if enemy["target"] == 1:
                    if enemy["type"] == 8 or p1_skin_color == p2_skin_color: enemy_text_color = player_skins[p1_skin_color + 1]
                    else: enemy_text_color = player_skins[p1_skin_color]
                elif enemy["target"] == 2:
                    if enemy["type"] == 8 or p1_skin_color == p2_skin_color: enemy_text_color = player_skins[p2_skin_color + 2]
                    else: enemy_text_color = player_skins[p2_skin_color]
            else: enemy_text_color = BLACK
        
        if enemy["type"] == 8:
            if enemy["target"] == 1: text_surface = enemy_font.render(str(player_lives), True, enemy_text_color)
            elif enemy["target"] == 2: text_surface = enemy_font.render(str(player2_lives), True, enemy_text_color)
        else:
            text_surface = enemy_font.render(str(max(int(enemy.get("health", 0)), 0)), True, enemy_text_color)

        text_rect = text_surface.get_rect(center=(enemy["x"], enemy["y"]))
        screen.blit(text_surface, text_rect)

        if enemy["type"] == 8:
            if player_frozen == True and enemy["target"] == 1:
                screen.blit(
                    frost_overlay,
                    (enemy["x"] - frost_overlay.get_width() // 2,
                     enemy["y"] - frost_overlay.get_height() // 2)
                )
            elif player2_frozen == True and enemy["target"] == 2:
                screen.blit(
                    frost_overlay,
                    (enemy["x"] - frost_overlay.get_width() // 2,
                     enemy["y"] - frost_overlay.get_height() // 2)
                )

    
    # draw player (flash red if hit)
    if player_alive:
        if current_time - damage_flash_time < 100:
            pygame.draw.rect(screen, RED, (player_x - player_size//2, player_y - player_size//2, player_size, player_size))
        elif current_time - heal_flash_time < 150:
            pygame.draw.rect(screen, LIME, (player_x - player_size//2, player_y - player_size//2, player_size, player_size))
        else:
            pygame.draw.rect(screen, player_skins[p1_skin_color], (player_x - player_size//2, player_y - player_size//2, player_size, player_size))
        
    if players == 2 and player2_alive:
        if current_time - player2_damage_flash_time < 100:
            pygame.draw.rect(screen, RED, (player2_x - player_size//2, player2_y - player_size//2, player_size, player_size))
        elif current_time - player2_heal_flash_time < 150:
            pygame.draw.rect(screen, LIME, (player2_x - player_size//2, player2_y - player_size//2, player_size, player_size))
        else:
            pygame.draw.rect(screen, player_skins[p2_skin_color], (player2_x - player_size//2, player2_y - player_size//2, player_size, player_size))

    if spawn_enabled:
        score += 0.1 * (60 / FPS) #SCORE SET
        if truescore < score:
            truescore = math.floor(score)
        if player_alive:
            score_p1 = truescore
        if player2_alive:
            score_p2 = truescore
    
    # draw player lives in center
    if players == 1: player_life_text = player_font.render(str(player_lives), True, player_skins[p1_skin_color + 1])
    else: player_life_text = player_font.render(str(player_lives), True, player_skins[p1_skin_color + 1])
    player_life_rect = player_life_text.get_rect(center=(player_x, player_y))
    screen.blit(player_life_text, player_life_rect)

    if players == 2:
        player2_life_text = player_font.render(str(player2_lives), True, player_skins[p2_skin_color + 2])
        player2_life_rect = player2_life_text.get_rect(center=(player2_x, player2_y))
        screen.blit(player2_life_text, player2_life_rect)

    if player_frozen:
        screen.blit(
            frost_overlay,
            (player_x - frost_overlay.get_width() // 2,
             player_y - frost_overlay.get_height() // 2)
        )
    if player2_frozen:
        screen.blit(
            frost_overlay,
            (player2_x - frost_overlay.get_width() // 2,
             player2_y - frost_overlay.get_height() // 2)
        )

    # draw HUD
    if players == 1:
        p1_text = font.render(f"Score: {score_p1}", True, player_skins[p1_skin_color])
        screen.blit(p1_text, (20, 20))
    elif players == 2:
        if p1_skin_color == p2_skin_color:
            p1_text = font.render(f"P1 Score: {score_p1}", True, player_skins[p1_skin_color + 1])
            screen.blit(p1_text, (20, 20))
            p2_text = font.render(f"P2 Score: {score_p2}", True, player_skins[p2_skin_color + 2])
            screen.blit(p2_text, (20, 60))
        else:
            p1_text = font.render(f"P1 Score: {score_p1}", True, player_skins[p1_skin_color])
            screen.blit(p1_text, (20, 20))
            p2_text = font.render(f"P2 Score: {score_p2}", True, player_skins[p2_skin_color])
            screen.blit(p2_text, (20, 60))

    if player_alive and score >= p1_regen_block_until and player_lives < player_health_setting and regen_delay != 6969:
        player_lives += 1
        heal_flash_time = current_time
        p1_regen_block_until = score + regen_delay

    if players == 2 and player2_alive and score >= p2_regen_block_until and player2_lives < player_health_setting and regen_delay != 6969:
        player2_lives += 1
        player2_heal_flash_time = current_time
        p2_regen_block_until = score + regen_delay

    if not player_alive and (players == 1 or not player2_alive):
        result = GAME_OVER(truescore, score_p1, score_p2)
        if result == "TITLE":
            TITLE_SCREEN()
            continue
        running = False
        break
    
    pygame.display.flip()

pygame.quit()
